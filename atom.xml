<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以技术之名</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.iamlay.com/"/>
  <updated>2020-09-01T04:31:22.279Z</updated>
  <id>www.iamlay.com/</id>
  
  <author>
    <name>Ray</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《将博客搬至CSDN》</title>
    <link href="www.iamlay.com/2020/09/01/CSDN/"/>
    <id>www.iamlay.com/2020/09/01/CSDN/</id>
    <published>2020-09-01T04:29:05.000Z</published>
    <updated>2020-09-01T04:31:22.279Z</updated>
    
    <content type="html"><![CDATA[<p>本人的博客将移步至CSDN，请前往CSDN观看本人的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人的博客将移步至CSDN，请前往CSDN观看本人的博客&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>以技术之名周报08#| Swift代码规范| 2020-08-28</title>
    <link href="www.iamlay.com/2020/08/28/week2020-36/"/>
    <id>www.iamlay.com/2020/08/28/week2020-36/</id>
    <published>2020-08-28T06:36:38.000Z</published>
    <updated>2020-08-28T06:50:39.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Part-01-代码格式"><a href="#Part-01-代码格式" class="headerlink" title="Part-01:  代码格式"></a>Part-01:  代码格式</h4><ul><li><p>1.1使用4个空格替代一个<code>Tabs</code></p></li><li><p>1.2 单行过长会引起阅读不适，每行代码尽量限制在 160 字符内 （<code>Xcode -&gt; Preferences -&gt; Text Editing -&gt; Page guide at column</code>设置为 160 将会很有帮助</p></li><li><p>1.3 确保每个文件末尾都有一个新行</p></li><li><p>1.4 确保任何地方都没有尾随的空格（ <code>Xcode -&gt; Preferences -&gt; Text Editing -&gt; Automatically trim trailing whitespace 加上 Including whitespace-only lines</code>）</p></li><li><p>不要把左大括号放在新行 — 我们使用 <a href="https://en.m.wikipedia.org/wiki/Indentation_style#1TBS" target="_blank" rel="noopener">1TBS 风格</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">    func someMethod() &#123;</span><br><span class="line">        if x &#x3D;&#x3D; y &#123;</span><br><span class="line">            &#x2F;* ... *&#x2F;</span><br><span class="line">        &#125; else if x &#x3D;&#x3D; z &#123;</span><br><span class="line">            &#x2F;* ... *&#x2F;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;* ... *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>1.6 当为属性、常量、变量、字典的键、函数参数、协议实现或父类书写类型时，不要在冒号<code>:</code>前面加上空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指明类型</span><br><span class="line">let pirateViewController: PirateViewController</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字典语法（注意我们左对齐而不是对齐冒号）</span><br><span class="line">let ninjaDictionary: [String: AnyObject] &#x3D; [</span><br><span class="line">    &quot;fightLikeDairyFarmer&quot;: false,</span><br><span class="line">    &quot;disgusting&quot;: true</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明函数</span><br><span class="line">func myFunction&lt;T, U: SomeProtocol&gt;(firstArgument: U, secondArgument: T) where T.RelatedType &#x3D;&#x3D; U &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用函数</span><br><span class="line">someFunction(someArgument: &quot;Kitten&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">class PirateViewController: UIViewController &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 协议</span><br><span class="line">extension PirateViewController: UITableViewDataSource &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>1.7 通常， , 逗号后面应该有一个空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myArray &#x3D; [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li><li><p>1.8 二元运算符前后都应该有一个空格，比如 + 、 == 或 -&gt;。当然， ( 后面和 ) 前面就不要有空格了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myValue &#x3D; 20 + (30 &#x2F; 2) * 3</span><br><span class="line">if 1 + 1 &#x3D;&#x3D; 3 &#123;</span><br><span class="line">    fatalError(&quot;The universe is broken.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func pancake(with syrup: Syrup) -&gt; Pancake &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>1.9 我们遵循 Xcode 推荐的缩进风格（即按住 CTRL-I 时，代码不再发生变化）。当声明的函数跨越多行时，推荐使用 Xcode 7.3 默认的语法风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 针对跨行函数声明，Xcode 添加了缩进</span><br><span class="line">func myFunctionWithManyParameters(parameterOne: String,</span><br><span class="line">                                  parameterTwo: String,</span><br><span class="line">                                  parameterThree: String) &#123;</span><br><span class="line">    &#x2F;&#x2F; 对于这种语句，Xcode 缩进到这</span><br><span class="line">    print(&quot;\(parameterOne) \(parameterTwo) \(parameterThree)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 针对多行的 &#96;if&#96; 语句增加换行缩进</span><br><span class="line">if myFirstValue &gt; (mySecondValue + myThirdValue)</span><br><span class="line">    &amp;&amp; myFourthValue &#x3D;&#x3D; .someEnumValue &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这行语句缩进到这</span><br><span class="line">    print(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>1.10 当调用一个多参数函数时，将每个参数放置有额外缩进的单独行中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someFunctionWithManyArguments(</span><br><span class="line">    firstArgument: &quot;Hello, I am a string&quot;,</span><br><span class="line">    secondArgument: resultFromSomeFunction(),</span><br><span class="line">    thirdArgument: someOtherLocalProperty)</span><br></pre></td></tr></table></figure></li><li><p>1.11 处理大到足以分成多行的隐式数组或字典时，按照方法、if 语句等语法中大括号的风格使用 <code>[</code> 和<code>]</code>方法中的闭包也应该用类似的风格处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">someFunctionWithABunchOfArguments(</span><br><span class="line">    someStringArgument: &quot;hello I am a string&quot;,</span><br><span class="line">    someArrayArgument: [</span><br><span class="line">        &quot;dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa&quot;,</span><br><span class="line">        &quot;string one is crazy - what is it thinking?&quot;</span><br><span class="line">    ],</span><br><span class="line">    someDictionaryArgument: [</span><br><span class="line">        &quot;dictionary key 1&quot;: &quot;some value 1, but also some more text here&quot;,</span><br><span class="line">        &quot;dictionary key 2&quot;: &quot;some value 2&quot;</span><br><span class="line">    ],</span><br><span class="line">    someClosure: &#123; parameter1 in</span><br><span class="line">        print(parameter1)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>1.12 尽可能避免多行语句，推荐使用局部常量或其他方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">let firstCondition &#x3D; x &#x3D;&#x3D; firstReallyReallyLongPredicateFunction()</span><br><span class="line">let secondCondition &#x3D; y &#x3D;&#x3D; secondReallyReallyLongPredicateFunction()</span><br><span class="line">let thirdCondition &#x3D; z &#x3D;&#x3D; thirdReallyReallyLongPredicateFunction()</span><br><span class="line">if firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition &#123;</span><br><span class="line">    &#x2F;&#x2F; 做某事</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">if x &#x3D;&#x3D; firstReallyReallyLongPredicateFunction()</span><br><span class="line">    &amp;&amp; y &#x3D;&#x3D; secondReallyReallyLongPredicateFunction()</span><br><span class="line">    &amp;&amp; z &#x3D;&#x3D; thirdReallyReallyLongPredicateFunction() &#123;</span><br><span class="line">    &#x2F;&#x2F; 做某事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-02-命名规范"><a href="#Part-02-命名规范" class="headerlink" title="Part-02:  命名规范"></a>Part-02:  命名规范</h4></li><li><p>2.1 在 Swift 中不需要 Objective-C 风格的前缀（比如用 <code>GuybrushThreepwood</code> 代替 <code>LIGuybrushThreepwood</code>)</p></li><li><p>2.2 使用<code>PascalCase</code> 为类型命名（比如 <code>struct</code> 、 <code>enum</code>、<code>class</code>、 <code>typedef</code> 、 <code>associatedtype</code>等等）。</p></li><li><p>2.3 对于函数、方法、属性、常量、变量、参数名称、枚举选项，使用 <code>camelCase</code>（首字母小写）。</p></li><li><p>2.4 实际上，当处理通常全部大写的缩写或其他名称时，代码里用到的任何名称都使用大写。例外情况是，如果这个单词位于以需要用小写开头的名称的开头 —— 在这种情况下，请使用全部小写字母作为首字母缩写词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 「HTML」是常量名称的开头，所以我们使用小写「html」 </span><br><span class="line">let htmlBodyContent: String &#x3D; &quot;&lt;p&gt;Hello, World!&lt;&#x2F;p&gt;&quot;</span><br><span class="line">&#x2F;&#x2F; 推荐使用 ID 而不是 Id</span><br><span class="line">let profileID: Int &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; 推荐 URLFinder 而不是 UrlFinder</span><br><span class="line">class URLFinder &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.5 所有与实例无关的常量都应该用 static 修饰。所有这些 static 常量都应该放置在他们的 class 、 struct 或 enum 标记过的部分中。 对于有很多常量的类，你应该将拥有类似或相同前缀、后缀 和 / 或者使用情况的常量进行分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐    </span><br><span class="line">class MyClassName &#123;</span><br><span class="line">    &#x2F;&#x2F; MARK: - 常量</span><br><span class="line">    static let buttonPadding: CGFloat &#x3D; 20.0</span><br><span class="line">    static let indianaPi &#x3D; 3</span><br><span class="line">    static let shared &#x3D; MyClassName()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">class MyClassName &#123;</span><br><span class="line">    &#x2F;&#x2F; 不要使用 &#96;k&#96; 前缀</span><br><span class="line">    static let kButtonPadding: CGFloat &#x3D; 20.0</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 不用为常量使用命名空间</span><br><span class="line">    enum Constant &#123;</span><br><span class="line">        static let indianaPi &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.6 对于泛型和关联类型，使用 PascalCase 描述泛型。如果这个单词和它遵循的协议或者它继承的父类冲突，你可以在关联类型或泛型名称后面追加 Type 后缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass&lt;Model&gt; &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line">protocol Modelable &#123;</span><br><span class="line">    associatedtype Model</span><br><span class="line">&#125;</span><br><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype IteratorType: Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.7 名称应具有描述性的和明确性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">class RoundAnimatingButton: UIButton &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">class CustomButton: UIButton &#123; &#x2F;* ... *&#x2F; &#125;</span><br></pre></td></tr></table></figure></li><li><p>2.8 不要缩写、使用缩写名称或单字母名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">class RoundAnimatingButton: UIButton &#123;</span><br><span class="line">    let animationDuration: NSTimeInterval</span><br><span class="line"></span><br><span class="line">    func startAnimating() &#123;</span><br><span class="line">        let firstSubview &#x3D; subviews.first</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">class RoundAnimating: UIButton &#123;</span><br><span class="line">    let aniDur: NSTimeInterval</span><br><span class="line"></span><br><span class="line">    func srtAnmating() &#123;</span><br><span class="line">        let v &#x3D; subviews.first</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.9 如果不明显，请在常量或变量名称中包含类型信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">class ConnectionTableViewCell: UITableViewCell &#123;</span><br><span class="line">    let personImageView: UIImageView</span><br><span class="line"></span><br><span class="line">    let animationDuration: TimeInterval</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于属性名称明显可以看出它是字符串，在实例变量名称中就可以不包含字符串了。</span><br><span class="line">    let firstName: String</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 虽然不推荐，但使用 &#96;Controller&#96; 代替 &#96;ViewController&#96; 也是可以的。</span><br><span class="line">    let popupController: UIViewController</span><br><span class="line">    let popupViewController: UIViewController</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当使用 &#96;UIViewController&#96; 的子类时，例如 table view controller、    </span><br><span class="line">        &#x2F;&#x2F; collection view controller 、 split view controller 等，</span><br><span class="line">    &#x2F;&#x2F; 在名称中完整表明其类型</span><br><span class="line">    let popupTableViewController: UITableViewController</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当使用 outlet 时，确保在属性名称中指明 outlet 的类型。</span><br><span class="line">    @IBOutlet weak var submitButton: UIButton!</span><br><span class="line">    @IBOutlet weak var emailTextField: UITextField!</span><br><span class="line">    @IBOutlet weak var nameLabel: UILabel!</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">class ConnectionTableViewCell: UITableViewCell &#123;</span><br><span class="line">    &#x2F;&#x2F; 这不是 &#96;UIImage&#96; 所以不应该被叫做 image 而应该使用 </span><br><span class="line">        &#x2F;&#x2F; personImageView</span><br><span class="line">    let personImage: UIImageView</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这不是 &#96;String&#96;，所以它应该叫做 &#96;textLabel&#96;</span><br><span class="line">    let text: UILabel</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#96;animation&#96; 没有很清晰地表明是时间间隔</span><br><span class="line">    &#x2F;&#x2F; 使用 &#96;animationDuration&#96; 或 &#96;animationTimeInterval&#96; 代替它</span><br><span class="line">    let animation: TimeInterval</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#96;transition&#96; 没有很明显地表明是 &#96;String&#96;</span><br><span class="line">    &#x2F;&#x2F; 使用 &#96;transitionText&#96; 或 &#96;transitionString&#96; 代替它</span><br><span class="line">    let transition: String</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是 view controller — 而不是 view</span><br><span class="line">    let popupView: UIViewController</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如前所述，我们不想使用缩写，所以不要用 &#96;VC&#96; 代替 &#96;ViewController&#96;</span><br><span class="line">    let popupVC: UIViewController</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 虽然在技术上这仍然是 &#96;UIViewController&#96;，但这个属性应该表明我们正在使用 *Table* View Controller</span><br><span class="line">    let popupViewController: UITableViewController</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 为了一致性，你应该把类型名称放在属性名称的结尾而不是开头。</span><br><span class="line">    @IBOutlet weak var btnSubmit: UIButton!</span><br><span class="line">    @IBOutlet weak var buttonSubmit: UIButton!</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当处理 outlet 时，我们应该总是在属性名称中含有类型。</span><br><span class="line">    &#x2F;&#x2F; 例如，我们应该用 &#96;firstNameLabel&#96; 代替。</span><br><span class="line">    @IBOutlet weak var firstName: UILabel!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.10 命名函数参数时，请确保函数可以被轻易地阅读并理解每个参数的目的</p></li><li><p>2.11 按照 Apple 的 API 设计规范，如果<code>protocol</code>描述「某事物在做什么」，那么应被命名为名词（比如 <code>Collection</code> ）。 如果<code>protocol</code>描述「一种能力」，使用后缀 <code>able</code> 、<code>ible</code> 或<code>ing</code>（比如 <code>Equatable</code> 、<code>ProgressReporting</code> ）。如果两种选项都不适用你的用例，你也可以在协议名称后加一个 <code>Protocol</code> 后缀。一些<code>protocol</code>的例子如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里的名称是描述「协议在做什么」的名词。</span><br><span class="line">protocol TableViewSectionProvider &#123;</span><br><span class="line">    func rowHeight(at row: Int) -&gt; CGFloat</span><br><span class="line">    var numberOfRows: Int &#123; get &#125;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里的协议是一种能力，我们恰当地命名它。</span><br><span class="line">protocol Loggable &#123;</span><br><span class="line">    func logCurrentState()</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设有个 &#96;InputTextView&#96; 类，但我们也想让协议概括一些能力—使用 &#96;Protocol&#96; 后缀非常恰当。</span><br><span class="line">protocol InputTextViewProtocol &#123;</span><br><span class="line">    func sendTrackingEvent()</span><br><span class="line">    func inputText() -&gt; String</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-03-编码风格"><a href="#Part-03-编码风格" class="headerlink" title="Part-03:  编码风格"></a>Part-03:  编码风格</h4><h5 id="3-1-通用"><a href="#3-1-通用" class="headerlink" title="3.1 通用#"></a>3.1 通用#</h5></li><li><p>3.1.1 尽可能选择<code>let</code>而非<code>var</code></p></li><li><p>3.1.2 当从一个集合转换到另一个集合时，建议首选<code>map</code>，<code>filter</code>，<code>reduce</code> 等高阶函数。在使用这些方法时，请确保使用的闭包没有任何副作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">let stringOfInts &#x3D; [1, 2, 3].flatMap &#123; String($0) &#125;</span><br><span class="line">&#x2F;&#x2F; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">var stringOfInts: [String] &#x3D; []</span><br><span class="line">for integer in [1, 2, 3] &#123;</span><br><span class="line">    stringOfInts.append(String(integer))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">let evenNumbers &#x3D; [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125;</span><br><span class="line">&#x2F;&#x2F; [4, 8, 16, 42]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">var evenNumbers: [Int] &#x3D; []</span><br><span class="line">for integer in [4, 8, 15, 16, 23, 42] &#123;</span><br><span class="line">    if integer % 2 &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        evenNumbers.append(integer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3.1.3 如果常量或变量的类型可以被推导，则不去主动声明它的类型</p></li><li><p>3.1.4 如果一个方法返回多个值，那么推荐使用<code>inout</code>修饰的元组类型作为返回值类型 （如果类型不够一目了然，最好使用命名元组来表明你要返回的内容） 。 如果你会多次使用到某个特定的元组，那么可以考虑使用 <code>typealias</code> 。 如果你的元组里返回了 3 个及以上的元素，那么使用 <code>struct</code>或者<code>class</code>可能比元组更合适。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func pirateName() -&gt; (firstName: String, lastName: String) &#123;</span><br><span class="line">    return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let name &#x3D; pirateName()</span><br><span class="line">let firstName &#x3D; name.firstName</span><br><span class="line">let lastName &#x3D; name.lastName</span><br></pre></td></tr></table></figure></li><li><p>3.1.5 在为类声明代理或者协议的时候，要注意循环引用，通常这些属性在声明时要用 weak 修饰。</p></li><li><p>3.1.6 在逃逸闭包中直接调用 self 的时候，要注意是否会引起循环引用。 - 当可能发生循环引用时尝试使用 <a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163" target="_blank" rel="noopener">capture list</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">myFunctionWithEscapingClosure() &#123; [weak self] (error) -&gt; Void in</span><br><span class="line">    &#x2F;&#x2F; 你可以这么做</span><br><span class="line"></span><br><span class="line">    self?.doSomething()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 你也可以这么做</span><br><span class="line"></span><br><span class="line">    guard let strongSelf &#x3D; self else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strongSelf.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3.1.7 不要使用 labeled breaks</p></li><li><p>3.1.8 流程控制语句的条件语句不需要加括弧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">if x &#x3D;&#x3D; y &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">if (x &#x3D;&#x3D; y) &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3.1.9 可以使用点语法直接写出枚举值，前面不需要写出枚举类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">imageView.setImageWithURL(url, type: .person)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">imageView.setImageWithURL(url, type: AsyncImageView.Type.person)</span><br></pre></td></tr></table></figure></li><li><p>3.1.10 在声明类方法的时候不要使用缩写，因为和 enum 相比，推导类的上下文会更难</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">imageView.backgroundColor &#x3D; UIColor.white</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">imageView.backgroundColor &#x3D; .white</span><br></pre></td></tr></table></figure></li><li><p>3.1.11 除非必要，否则尽量不使用<code>self.</code></p></li><li><p>3.1.12 写方法时，要考虑这个方法是否会被重载。如果不会，标记为<code>final</code>，但请记住，这是为了防止以测试为目的而重载方法。通常，<code>final</code>方法会将编译时间缩短，所以适时使用它是非常棒的。 但是，在库中应用 <code>final</code>关键词要非常小心。因为相对于在本地项目中将某些内容改为非 <code>final</code> ，在库中将某些内容改为非 <code>final</code>可不是小事</p></li><li><p>3.1.13 使用诸如 <code>else</code> 、<code>catch</code> 等后面跟随代码块的语句，将关键字 和代码块放在同一行。强调一下，我们遵循 <code>1TBS</code>风格 。<code>if / else</code>和<code>do / catch</code> 的示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if someBoolean &#123;</span><br><span class="line">    &#x2F;&#x2F; 做某些事</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 做另一些事</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">    let fileContents &#x3D; try readFile(&quot;filename.txt&quot;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.1.14 在定义与类相关的函数或属性而不是定义类的实例变量时时，推荐<code>static</code>，而不是 <code>class</code>。如果你特别需要在子类中重载这个函数的功能时，请使用<code>class</code>。但是，你应该考虑使用<code>protocol</code>来达到这个目的</li></ul></li><li><p>3.1.15 如果有一个函数是无参数的、无副作用的而且返回某个对象或值，更推荐使用计算属性来代替它</p></li></ul><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><ul><li>3.2.1 如果需要写访问修饰符关键字的话，请将它写在开头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">private static let myPrivateNumber: Int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">static private let myPrivateNumber: Int</span><br></pre></td></tr></table></figure></li><li>3.2.2 访问修饰符关键字不应该独占一行，而是将它和其描述的东西放在一行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">open class Pirate &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">open</span><br><span class="line">class Pirate &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.2.3 通常情况下，访问修饰符关键字默认是 internal ，所以不用写出来</li><li>3.2.4 如果属性需要被单元测试访问，则需要将它标记为 internal ，以便于使用 @testable import ModuleName 。如果属性 应该 是私有的，但是出于单元测试的目的将它声明为 internal，一定要添加适当的文档注释来解释这一点。 为了更加简明，你可以使用 - warning: 标记语法，如下所示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 这个属性定义海盗的名字。</span><br><span class="line"> - warning: 不要为 &#96;@testable&#96; 添加 &#96;private&#96; 访问修饰符 </span><br><span class="line"> *&#x2F;</span><br><span class="line">let pirateName &#x3D; &quot;LeChuck&quot;</span><br></pre></td></tr></table></figure></li><li>3.2.5 尽可能使用<code>private</code> 而不是<code>fileprivate</code></li><li>3.2.6 当在<code>public</code>和 <code>open</code>两者之间选择一个时，如果你打算让某些内容在模块外也可以被继承，推荐使用<code>open</code>，否则请使用 <code>public</code>。注意，任何 <code>internal</code>或更高访问权限的内容，都可以通过使用 <code>@testable import</code> 在测试中被继承。所以这不应该成为使用 <code>open</code> 的理由。通常，在涉及到库的时候，更倾向于自由地使用<code>open</code>。但是， <code>open</code>可以轻易地同时改变应用程序中多个模块的内容。当涉及到这类代码库中的模块时，更倾向于保守地使用 <code>open</code></li></ul><h5 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h5><p>推荐创建自定义运算符。<br>如果要引入自定义运算符，确保你有一个很好的理由，为什么你想把一个新的运算符引入全局范围，而不是使用其他现有的运算符。<br>可以重写现有的运算符以支持新类型 (特别是 == ) 然而，你新定义的必须保存运算符的语义。例如， == 必须是检测是否相等并返回检测结果的布尔值</p><h5 id="Switch-语句和枚举"><a href="#Switch-语句和枚举" class="headerlink" title="Switch 语句和枚举"></a>Switch 语句和枚举</h5><ul><li>3.4.1 当使用具有有限可能性的 <code>switch</code>语句 <code>( enum )</code>，不包括 <code>default</code>的其他情况。将未处理的情况放置在 <code>default</code>里，并使用 break 来结束执行</li><li>3.4.2 在 Swift 中由于 <code>switch</code>的各种情况中默认有<code>break</code>，如果不需要，可以省略<code>break</code>关键字</li><li>3.4.3 <code>case</code>和 <code>switch</code>的声明要按照 Swift 的规范独占一行</li><li>3.4.4 当定义具有关联值的情况时，确保这个值被适当的标记，例如：<code>case hunger(hungerLevel: Int)</code>而不是<code>case hunger(Int)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Problem &#123;</span><br><span class="line">    case attitude</span><br><span class="line">    case hair</span><br><span class="line">    case hunger(hungerLevel: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleProblem(problem: Problem) &#123;</span><br><span class="line">    switch problem &#123;</span><br><span class="line">    case .attitude:</span><br><span class="line">        print(&quot;At least I don&#39;t have a hair problem.&quot;)</span><br><span class="line">    case .hair:</span><br><span class="line">        print(&quot;Your barber didn&#39;t know when to stop.&quot;)</span><br><span class="line">    case .hunger(let hungerLevel):</span><br><span class="line">        print(&quot;The hunger level is \(hungerLevel).&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.4.5 更推荐使用<code>fallthrough</code>关键字来处理一系列的<code>cases （例如: case 1, 2, 3: ）</code></li><li>3.4.6 如果您有一个不应该达到的默认情况，最好抛出一个错误（或处理其他类似的方法，如断言<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func handleDigit(_ digit: Int) throws &#123;</span><br><span class="line">    switch digit &#123;</span><br><span class="line">    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:</span><br><span class="line">        print(&quot;Yes, \(digit) is a digit!&quot;)</span><br><span class="line">    default:</span><br><span class="line">        throw Error(message: &quot;The given number was not a digit.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h5></li><li>3.5.1 使用隐式解包可选类型的唯一机会是使用 <code>@IBOutlet</code> 的时候。在其他情况下，使用非可选或常规可选的属性会更好。是的，有某些情况下，你可以「保证」使用时属性不会为 nil ，但是安全和一致会更好。同样，不要使用强制解包</li><li>3.5.2 不要使用 <code>as!</code>或 <code>try!</code></li><li>3.5.3 如果你不打算真正地使用存在可选类型中的值，但需要判断这个值是否为 <code>nil</code>，显式地检查这个值是不是<code>nil</code> ，而不是使用 <code>if let</code>语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">if someOptional !&#x3D; nil &#123;</span><br><span class="line">    &#x2F;&#x2F; 做某件事</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">if let _ &#x3D; someOptional &#123;</span><br><span class="line">    &#x2F;&#x2F; 做某件事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.5.4 不要使用 <code>unowned</code>你可以将<code>unowned</code>视为被隐式解包的 <code>weak</code>属性的等价物（虽然 <code>unowned</code>因为完全忽略引用计数而略有性能上的提升）。因为我们不想有隐式解包，所以我们同样也不想要 <code>unowned</code>属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">weak var parentViewController: UIViewController?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">weak var parentViewController: UIViewController!</span><br><span class="line">unowned var parentViewController: UIViewController</span><br></pre></td></tr></table></figure></li><li>3.5.5 在解包可选类型时，在恰当的地方使用相同名称来命名解包的常量或变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guard let myValue &#x3D; myValue else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-协议"><a href="#3-6-协议" class="headerlink" title="3.6 协议"></a>3.6 协议</h5>在实现协议时，有两种方式组织代码：</li></ul><p>1、使用 <code>// MARK:</code>注释将协议实现和其他部分的代码隔开。<br>2、在同一资源文件中 <code>class/struct</code>实现代码以外的地方，使用扩展。</p><p>记住使用扩展时，无论怎样，扩展中的方法不要被子类重载，这会使测试变麻烦。如果这是一个通用的使用场景，为了一致性使用方法 <code>1</code>可能会更好。否则，<code>2</code>可以使关系的拆分更清楚。<br>即使使用方法<code>2</code> ，也要添加<code>// MARK:</code>语句，以便在 <code>Xcode</code>的方法 / 属性 / 类等的列表 UI 中更加易读</p><h5 id="3-7-属性"><a href="#3-7-属性" class="headerlink" title="3.7 属性"></a>3.7 属性</h5><ul><li>3.7.1 如果创建只读的计算属性，提供不带 get {} 的获取方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var computedProperty: String &#123;</span><br><span class="line">    if someBool &#123;</span><br><span class="line">        return &quot;I&#39;m a mighty pirate!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;I&#39;m selling these fine leather jackets.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.7.2 使用 <code>get {}</code>、 <code>set {}</code>、 <code>willSet</code> 和<code>didSet</code>时，缩进这些块</li><li>3.7.3 虽然你可以为 <code>willSet/didSet</code>和<code>set</code>自定义新值或旧值的名称，但请使用默认提供的标准标识符 <code>newValue / oldValue</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var storedProperty: String &#x3D; &quot;I&#39;m selling these fine leather jackets.&quot; &#123;</span><br><span class="line">    willSet &#123;</span><br><span class="line">        print(&quot;will set to \(newValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;did set from \(oldValue) to \(storedProperty)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var computedProperty: String  &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        if someBool &#123;</span><br><span class="line">            return &quot;I&#39;m a mighty pirate!&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return storedProperty</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">        storedProperty &#x3D; newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.7.4 你可以按如下方式声明一个单例属性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PirateManager &#123;</span><br><span class="line">    static let shared &#x3D; PirateManager()</span><br><span class="line"></span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-闭包"><a href="#3-8-闭包" class="headerlink" title="3.8 闭包"></a>3.8 闭包</h5></li><li>3.8.1 如果可以明确参数类型，即可以省略参数类型也可以显示参数类型。你可以根据场景决定是否添加一些说明来提高代码的可读性，或者是省略一些无关紧要的部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 省略参数类型</span><br><span class="line">doSomethingWithClosure() &#123; response in</span><br><span class="line">    print(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 明确参数类型</span><br><span class="line">doSomethingWithClosure() &#123; response: NSURLResponse in</span><br><span class="line">    print(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 参数名缩写</span><br><span class="line">[1, 2, 3].flatMap &#123; String($0) &#125;</span><br></pre></td></tr></table></figure></li><li>3.8.2 声明了一个闭包，不需要用括号括起来，除非需要（例如，闭包类型是可选的，或者这个闭包在另一个闭包内）。闭包的参数都是是放在圆括号里，如果用 <code>()</code>就表示没有参数，用<code>Void</code>表示无返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let completionBlock: (Bool) -&gt; Void &#x3D; &#123; (success) in</span><br><span class="line">    print(&quot;Success? \(success)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let completionBlock: () -&gt; Void &#x3D; &#123;</span><br><span class="line">    print(&quot;Completed!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let completionBlock: (() -&gt; Void)? &#x3D; nil</span><br></pre></td></tr></table></figure></li><li>3.8.3 在闭包中尽可能的让参数保持在同一行，避免过多换行。（确保每行小于 160 个字符)</li><li>3.8.4 如果闭包的含义不太明确可以使用尾随闭包（如果一个方法同时含有成功和失败的两个闭包就不建议使用尾随闭包）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 尾随闭包</span><br><span class="line">doSomething(1.0) &#123; (parameter1) in</span><br><span class="line">    print(&quot;Parameter 1 is \(parameter1)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无尾随闭包</span><br><span class="line">doSomething(1.0, success: &#123; (parameter1) in</span><br><span class="line">    print(&quot;Success with \(parameter1)&quot;)</span><br><span class="line">&#125;, failure: &#123; (parameter1) in</span><br><span class="line">    print(&quot;Failure with \(parameter1)&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="3-9-数组"><a href="#3-9-数组" class="headerlink" title="3.9 数组"></a>3.9 数组</h5></li><li>3.9.1 通常要避免直接用下标的方式访问数组。尽可能使用访问器，比如<code>.first</code> 或<code>.last</code>。它们是可选类型并且不会导致崩溃。推荐尽可能地使用 <code>for item in items</code>语法而不是类似与 <code>for i in 0 ..&lt; items.count</code>的语法。如果你需要直接用下标访问数组，一定要做适当的边界检查。你可以使用<code>for (index, value) in items.enumerated()</code>来一并得到索引和值</li><li>3.9.2 不要使用 <code>+=</code> 或<code>+</code>操作符来追加或串联到数组。而是使用 <code>.append()</code>或<code>.append(contentsOf:)</code>，因为在 Swift 当前的状况下它们（至少在编译方面）拥有更高的性能。如果基于其他数组声明数组而且想让它保持不变，使用<code>let myNewArray = [arr1, arr2].joined()</code>，而不是<code>let myNewArray = arr1 + arr2</code></li></ul><h5 id="3-10-错误处理"><a href="#3-10-错误处理" class="headerlink" title="3.10 错误处理"></a>3.10 错误处理</h5><p>假设函数 myFunction 应该返回 String，但是，某些时候它会运行错误。在出错时返回 nil 的情况下，通用的处理方式是让函数返回可选类型 String?。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func readFile(named filename: String) -&gt; String? &#123;</span><br><span class="line">    guard let file &#x3D; openFile(named: filename) else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let fileContents &#x3D; file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    return fileContents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSomeFile() &#123;</span><br><span class="line">    let filename &#x3D; &quot;somefile.txt&quot;</span><br><span class="line">    guard let fileContents &#x3D; readFile(named: filename) else &#123;</span><br><span class="line">        print(&quot;Unable to open file \(filename).&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(fileContents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反，在适当的时候，我们应该使用 Swift 的 <code>try/catch</code>操作来了解失败原因。</p><p>你可以使用<code>struct</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Error: Swift.Error &#123;</span><br><span class="line">    public let file: StaticString</span><br><span class="line">    public let function: StaticString</span><br><span class="line">    public let line: UInt</span><br><span class="line">    public let message: String</span><br><span class="line"></span><br><span class="line">    public init(message: String, file: StaticString &#x3D; #file, function: StaticString &#x3D; #function, line: UInt &#x3D; #line) &#123;</span><br><span class="line">        self.file &#x3D; file</span><br><span class="line">        self.function &#x3D; function</span><br><span class="line">        self.line &#x3D; line</span><br><span class="line">        self.message &#x3D; message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func readFile(named filename: String) throws -&gt; String &#123;</span><br><span class="line">    guard let file &#x3D; openFile(named: filename) else &#123;</span><br><span class="line">        throw Error(message: &quot;Unable to open file named \(filename).&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let fileContents &#x3D; file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    return fileContents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSomeFile() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        let fileContents &#x3D; try readFile(named: filename)</span><br><span class="line">        print(fileContents)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些例外情况，使用可选类型比使用错误处理更有意义。当返回结果语义上可能是<code>nil</code>，而不是取回结果时的错误值时，返回可选类型比使用错误处理更有意义。</p><p>通常，如果方法可能「失败」，并且返回值为可选类型，失败的原因就不是很明显了，那么方法抛出错误可能会更有意义。</p><h5 id="3-11-使用guard-语句"><a href="#3-11-使用guard-语句" class="headerlink" title="3.11 使用guard 语句"></a>3.11 使用<code>guard</code> 语句</h5><ul><li>3.11.1 一般情况下，我们推荐在适用的地方使用「尽早返回」的策略 而不是在 if 语句里嵌套代码。在这种使用场景下，使用 guard 语句通常很有用，而且可以提升代码的可读性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">func eatDoughnut(at index: Int) &#123;</span><br><span class="line">    guard index &gt;&#x3D; 0 &amp;&amp; index &lt; doughnuts.count else &#123;</span><br><span class="line">        &#x2F;&#x2F; 尽早返回因为索引越界了</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let doughnut &#x3D; doughnuts[index]</span><br><span class="line">    eat(doughnut)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">func eatDoughnut(at index: Int) &#123;</span><br><span class="line">    if index &gt;&#x3D; 0 &amp;&amp; index &lt; doughnuts.count &#123;</span><br><span class="line">        let doughnut &#x3D; doughnuts[index]</span><br><span class="line">        eat(doughnut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.11.2 当解包可选类型时，推荐 guard 语句而不是 if 语句来减少代码中嵌套缩进的数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">guard let monkeyIsland &#x3D; monkeyIsland else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">bookVacation(on: monkeyIsland)</span><br><span class="line">bragAboutVacation(at: monkeyIsland)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">if let monkeyIsland &#x3D; monkeyIsland &#123;</span><br><span class="line">    bookVacation(on: monkeyIsland)</span><br><span class="line">    bragAboutVacation(at: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 甚至更不推荐</span><br><span class="line">if monkeyIsland &#x3D;&#x3D; nil &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">bookVacation(on: monkeyIsland!)</span><br><span class="line">bragAboutVacation(at: monkeyIsland!)</span><br></pre></td></tr></table></figure></li><li>3.11.3 在解包类型不复杂，需要在使用 <code>if</code>还是 <code>guard</code>之间做抉择时，要记住最重要的是代码的可读性。会有很多可能的情况，例如依赖于两个不同的布尔值、复杂逻辑语句涉及到多个判断等，所以通常使用您的最佳的判断来写出可读且一致的代码。如果你不确定 <code>guard</code>或 <code>if</code>哪个更具可读性或者它们看起来同样可读，推荐使用 <code>guard</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里 &#96;if&#96; 语句的可读性很高</span><br><span class="line">if operationFailed &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里 &#96;guard&#96; 语句的可读性很高</span><br><span class="line">guard isSuccessful else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 像这种双重否定逻辑很难读懂—即不要这样做</span><br><span class="line">guard !operationFailed else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.11.4 如果在两种语句之间做选择，使用 <code>if</code>语句比使用 <code>guard</code>语句更有意义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">if isFriendly &#123;</span><br><span class="line">    print(&quot;Hello, nice to meet you!&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;You have the manners of a beggar.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">guard isFriendly else &#123;</span><br><span class="line">    print(&quot;You have the manners of a beggar.&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, nice to meet you!&quot;)</span><br></pre></td></tr></table></figure></li><li>3.11.5 只有在失败会导致退出当前上下文的情况下，才应该使用 <code>guard</code>。 下面是一个例子，在其中使用两个 if 语句而不是使用两个 <code>guard</code> 语句更有意义 — 有两个不相互阻塞的无关条件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if let monkeyIsland &#x3D; monkeyIsland &#123;</span><br><span class="line">    bookVacation(onIsland: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if let woodchuck &#x3D; woodchuck, canChuckWood(woodchuck) &#123;</span><br><span class="line">    woodchuck.chuckWood()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.11.6 通常，我们可能遇到需要使用 guard 语句解包多个可选类型的情况。一般情况下，如果处理每个解包的失败是相同的（例如，<code>return</code>、<code>break</code>、<code>continue</code>、<code>throw</code>或一些其他的 <code>@noescape</code>），将解包合入一个 <code>guard</code>语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 因为只是返回，所以合并为一个。</span><br><span class="line">guard let thingOne &#x3D; thingOne,</span><br><span class="line">    let thingTwo &#x3D; thingTwo,</span><br><span class="line">    let thingThree &#x3D; thingThree else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为在每种情况下处理特定的错误，所以拆分成单独的语句。</span><br><span class="line">guard let thingOne &#x3D; thingOne else &#123;</span><br><span class="line">    throw Error(message: &quot;Unwrapping thingOne failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let thingTwo &#x3D; thingTwo else &#123;</span><br><span class="line">    throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let thingThree &#x3D; thingThree else &#123;</span><br><span class="line">    throw Error(message: &quot;Unwrapping thingThree failed.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.11.7 不要将 guard 语句写成只有一行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐</span><br><span class="line">guard let thingOne &#x3D; thingOne else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不推荐</span><br><span class="line">guard let thingOne &#x3D; thingOne else &#123; return &#125;</span><br></pre></td></tr></table></figure><h4 id="Part-04-文档-注释"><a href="#Part-04-文档-注释" class="headerlink" title="Part-04: 文档 / 注释"></a>Part-04: 文档 / 注释</h4></li></ul><h5 id="4-1-文档"><a href="#4-1-文档" class="headerlink" title="4.1 文档"></a>4.1 文档</h5><p>如果函数比简单的 O (1) 操作负责，通常应该考虑为函数加个文档。因为方法签名的一些信息可能不是那么明显。如果实现方式有任何怪癖，无论在技术上有趣、棘手、不明显等等，都应该被文档化。应该为复杂的类 / 结构体 / 枚举 / 协议和属性添加文档。所有的<code>public</code> <code>函数 / 类 / 属性 / 常量 / 结构体 / 枚举 / 协议</code>等也应该被文档化。（如果，他们的签名 / 名称不能使他们含义 / 功能很明显）。</p><p>写完文档注释之后，你应该按住<code>option</code> 键并单击函数 / 属性 / 类等等来确认文档注释被正确地格式化了。</p><p>务必查看 Swift 注释标记中提供的全套功能，详见 <a href="https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1" target="_blank" rel="noopener">Apple 的文档</a></p><p>原则:</p><ul><li>4.1.1 160 个字符列的限制（和代码的部分一样</li><li>4.1.2 如果文档注释在一行内，使用（ <code>/** */</code>）</li><li>4.1.3 不要在每一个附加行前面加<code>*</code></li><li>4.1.4 使用新的 <code>- parameter</code>语法而不是旧的 <code>:param:</code>语法（务必使用小写的 <code>parameter</code>而并不是 <code>Parameter</code>）。 按住 <code>Option</code>键并单击你写的方法以确保快速帮助看起来是正确的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Human &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     这个方法向某人喂某种事物。</span><br><span class="line"></span><br><span class="line">     - parameter food: 你想被他吃的食物</span><br><span class="line">     - parameter person: 应该吃食物的人</span><br><span class="line">     - returns: 如果食物被那个人吃了，为 True；否则为 false。 </span><br><span class="line">    *&#x2F;</span><br><span class="line">    func feed(_ food: Food, to person: Human) -&gt; Bool &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>4.1.5 如果你要给方法的参数 / 返回值 / 抛出的异常写文档，即使某些文档最终会有重复，也请将它们都写入文档（这比文档看起来不完整更可取）。有时，如果仅有一个参数需要写文档，在描述中提及它更好一些</li><li>4.1.6 对于复杂的类，请使用一些看起来合适的示例来描述类的用法。记住在 <code>Swift</code>注释文档中可以使用 <code>markdown</code>语法。因此，换行符、列表等等都是适用的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> ## 功能支持</span><br><span class="line"></span><br><span class="line"> 这个类做了一些很棒的事情。它支持：</span><br><span class="line"></span><br><span class="line"> - 功能 1</span><br><span class="line"> - 功能 2</span><br><span class="line"> - 功能 3</span><br><span class="line"></span><br><span class="line"> ## 示例</span><br><span class="line"></span><br><span class="line"> 这有一个用例，由于它表示一个代码块，所以使用四个空格缩进：</span><br><span class="line"></span><br><span class="line">     let myAwesomeThing &#x3D; MyAwesomeClass()</span><br><span class="line">     myAwesomeThing.makeMoney()</span><br><span class="line"></span><br><span class="line"> ## 警告</span><br><span class="line"></span><br><span class="line"> 有一些你需要注意的事项：</span><br><span class="line"></span><br><span class="line"> 1. 事项一</span><br><span class="line"> 2. 事项二</span><br><span class="line"> 3. 事项三</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyAwesomeClass &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>4.1.7 提及代码时，请使用代码提示<code>-</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 或许这里使用 &#96;UIViewController&#96; 做了某事</span><br><span class="line"> - warning: 在运行这个函数之前，请确保 &#96;someValue&#96; 为 &#96;true&#96;。</span><br><span class="line"> *&#x2F;</span><br><span class="line">func myFunction() &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>4.1.8 写文档注释时，尽可能保持简洁<h5 id="4-2-其他注释原则"><a href="#4-2-其他注释原则" class="headerlink" title="4.2 其他注释原则"></a>4.2 其他注释原则</h5></li><li>4.2.1 始终在<code>//</code>后面加个空格</li><li>4.2.2 始终在自己的行中写注释</li><li>4.2.3 使用 <code>// MARK: -</code>无论是什么 时，在注释后加个空行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Pirate &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: - 实例属性</span><br><span class="line"></span><br><span class="line">    private let pirateName: String</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: - 构造函数</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        &#x2F;* ... *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Part-05-转载"><a href="#Part-05-转载" class="headerlink" title="Part-05:转载"></a>Part-05:转载</h4><p><a href="https://github.com/linkedin/swift-style-guide/" target="_blank" rel="noopener">原文地址</a><br><a href="https://learnku.com/ios/t/23230/linkedin-official-swift-style-guide" target="_blank" rel="noopener">译文地址</a></p>]]></content>
    
    <summary type="html">
    
      本周周报主要是对iOS开发过程中Swift的编码规范进行的总结，主要从代码格式、命名规范、编码风格、文档注释四个方面展开。对一个成熟的团队来讲，保证统一合理的代码风格，对后期项目的维护非常的重要，代码风格的统一越早开始越好。
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="转载" scheme="www.iamlay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS代码规范 - OC版</title>
    <link href="www.iamlay.com/2020/08/26/iOSCodeSpecification/"/>
    <id>www.iamlay.com/2020/08/26/iOSCodeSpecification/</id>
    <published>2020-08-26T04:59:15.000Z</published>
    <updated>2020-08-28T02:45:15.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Part1-1：-Objective-C命名规范"><a href="#Part1-1：-Objective-C命名规范" class="headerlink" title="Part1-1： Objective-C命名规范"></a>Part1-1： Objective-C命名规范</h4><h5 id="一般性原则"><a href="#一般性原则" class="headerlink" title="一般性原则"></a>一般性原则</h5><ul><li>遵循大部分开发语言的一般性命名原则。</li><li>方法名不要使用 new 作为前缀。</li><li>驼峰命名规则，第一个单词的首字符小写。</li><li>一般方法不使用前缀命名。</li><li>私有方法可以使用统一的前缀来分组和辨识。</li><li>表示对象行为的方法,名称以动词开头。</li></ul><p>以动词开头的方法命名,标识对象的行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) selectTabViewItem:(NSTableViewItem *)tableViewItem</span><br></pre></td></tr></table></figure><blockquote><p>名称中不要出现<br>do或does,因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰。</p></blockquote><ul><li>如果方法返回方法接收者的某个属性,直接用属性名称命名。不要使用 get，除非是间接返回一个或多个值。</li></ul><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSSize) cellSize;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSSize) getCellSize;</span><br></pre></td></tr></table></figure><ul><li>参数要用描述该参数的关键字命名</li></ul><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) sendAction:(SEL)aSelector  :(id)anObject  :(BOOL)flag;</span><br></pre></td></tr></table></figure><ul><li>参数前面的单词要能描述该参数</li></ul><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id) viewWithTag:(int)aTag;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id) taggedView:(int)aTag;</span><br></pre></td></tr></table></figure><ul><li>细化基类中的已有方法:创建一个新方法,其名称是在被细化方法名称后面追加参数关键词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithFrame:(CGRect)frameRect;&#x2F;&#x2F;NSView, UIView.</span><br><span class="line">- (id)initWithFrame:(NSRect)frameRect mode:(int)aMode  cellClass:(Class)factoryId numberOfRows:(int)rowsHigh numberOfColumns (int)colsWide;&#x2F;&#x2F;NSMatrix, a subclass of NSView</span><br></pre></td></tr></table></figure><ul><li>不要使用 and 来连接用属性作参数的关键字</li></ul><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (int)runModalForDirectory:(NSString *)path file:(NSString *)name types:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure><p>虽然上面的例子中使用 add 看起来也不错,但当你方法有太多参数关键字时就有问题。</p><ul><li>如果方法描述两种独立的行为,使用 and 来串接它们</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) openFile:(NSString *)fullPath withApplication:(NSString NSWorkspace *)appName andDeactivate:(BOOL)flag;&#x2F;&#x2F;NSWorkspace.</span><br></pre></td></tr></table></figure><h5 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h5><blockquote><p>访问方法是对象属性的读取与设置方法。其命名有特定的格式依赖于属性的描述内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setNoun:(type)aNoun;</span><br><span class="line">- (type) noun;</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setgColor:(NSColor *)aColor;</span><br><span class="line">- (NSColor *) color;</span><br></pre></td></tr></table></figure><ul><li>如果属性是用形容词描述的,则命名格式为:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setAdjective:(BOOL)flag;</span><br><span class="line">- (BOOL) isAdjective;</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setEditable:(BOOL)flag;</span><br><span class="line">- (BOOL) isEditable;</span><br></pre></td></tr></table></figure><ul><li>如果属性是用动词描述的,则命名格式为:(动词要用现在时时态)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setVerbObject:(BOOL)flag;</span><br><span class="line">- (BOOL) verbObject;</span><br></pre></td></tr></table></figure>例如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setShowAlpha:(BOOL)flag;</span><br><span class="line">- (BOOL) showsAlpha;</span><br></pre></td></tr></table></figure><ul><li>不要使用动词的过去分词形式作形容词使用</li></ul><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAcceptsGlyphInfo:(BOOL)flag;</span><br><span class="line">- (BOOL)acceptsGlyphInfo;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setGlyphInfoAccepted:(BOOL)flag;</span><br><span class="line">- (BOOL)glyphInfoAccepted;</span><br></pre></td></tr></table></figure><ul><li>可以使用情态动词(can, should, will 等)来提高清晰性,但不要使用 do 或 does</li></ul><p>推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setCanHide:(BOOL)flag;             </span><br><span class="line">- (BOOL) canHide;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setDoseAcceptGlyphInfo:(BOOL)flag;</span><br><span class="line">- (BOOL) doseAcceptGlyphInfo;</span><br></pre></td></tr></table></figure><ul><li>只有在方法需要间接返回多个值的情况下,才使用 get</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br></pre></td></tr></table></figure><p>像上面这样的方法,在其实现里应允许接受 NULL 作为其 in/out 参数,以表示调用者对一个或多个返回 值不感兴趣。</p><p><strong>委托方法:</strong> 委托方法是那些在特定事件发生时可被对象调用,并声明在对象的委托类中的方法。它们有独特的命名约 定,这些命名约定同样也适用于对象的数据源方法。</p><ul><li>名称以标示发送消息的对象的类名开头,省略类名的前缀并小写类第一个字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br></pre></td></tr></table></figure><ul><li>冒号紧跟在类名之后(随后的那个参数表示委派的对象)。该规则不适用于只有一个 sender 参数的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) applicationOpenUntitledFile:(NSApplication *)sender;</span><br></pre></td></tr></table></figure><ul><li>上面的那条规则也不适用于响应通知的方法。在这种情况下,方法的唯一参数表示通知对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) windowDidChangeScreen:(NSNotification *)notification;</span><br></pre></td></tr></table></figure><ul><li>用于通知委托对象操作即将发生或已经发生的方法名中要使用 did 或 will</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) browserDidScroll:(NSBrowser *)sender;</span><br><span class="line">- (NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)window;</span><br></pre></td></tr></table></figure><p>用于询问委托对象可否执行某操作的方法名中可使用 did 或 will,但最好使用 should</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) windowShouldClose:(id)sender;</span><br></pre></td></tr></table></figure><h5 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h5><p>管理对象(集合中的对象被称之为元素)的集合类,约定要具备如下形式的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void) addElement:(elementType)adObj;</span><br><span class="line">- (void) removeElement:(elementType)anObj;</span><br><span class="line">- (NSArray *)elements;</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void) addLayoutManager:(NSLayoutManager *)adObj;</span><br><span class="line">- (void) removeLayoutManager:(NSLayoutManager *)anObj;</span><br><span class="line">- (NSArray *)layoutManagers;</span><br></pre></td></tr></table></figure><p>集合方法命名有如下一些限制和约定:</p><ul><li>如果集合中的元素无序,返回 NSSet,而不是 NSArray</li><li>如果将元素插入指定位置的功能很重要,则需具备如下方法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) insertElement:(elementType)anObj atIndex:(int)index;</span><br><span class="line">- (void) removeElementAtIndex:(int)index;</span><br></pre></td></tr></table></figure><p>集合方法的实现要考虑如下细节:</p><ul><li>以上集合类方法通常负责管理元素的所有者关系,在 add 或 insert 的实现代码里会 retain 元素,在 remove 的实现代码中会 release 元素</li><li>当被插入的对象需要持有指向集合对象的指针时,通常使用 set… 来命名其设置该指针的方法,且不 要 retain 集合对象。比如上面的 insertLayerManager:atIndex: 这种情形,NSLayoutManager 类使 用如下方法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void) setTextStorage:(NSTextStorage *)textStorage;</span><br><span class="line">- (NSTextStorage *)textStorage;</span><br></pre></td></tr></table></figure><p>通常你不会直接调用 setTextStorage:,而是覆写它。<br>另一个关于集合约定的例子来自 NSWindow 类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;</span><br><span class="line">- (void) removeChildWindow:(NSWindow *)childWin;</span><br><span class="line">- (NSArray *)childWindows;</span><br><span class="line">- (NSWindow *) parentWindow;</span><br><span class="line">- (void) setParentWindow:(NSWindow *)window;</span><br></pre></td></tr></table></figure><h5 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h5><p>命名方法参数时要考虑如下规则:</p><ul><li>如同方法名,参数名小写第一个单词的首字符,大写后继单词的首字符。如:removeObject:(id)anObject</li><li>不要在参数名中使用 pointer 或 ptr,让参数的类型来说明它是指针</li><li>避免使用 one, two,…,作为参数名</li><li>避免为节省几个字符而缩写</li></ul><p>照 Cocoa 惯例,以下关键字与参数联合使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...action:(SEL)aSelector</span><br><span class="line">..alignment:(int)mode</span><br><span class="line">...atIndex:(int)index</span><br><span class="line">...content:(NSRect)aRect</span><br><span class="line">...doubleValue:(double)aDouble</span><br><span class="line">...floatValue:(float)aFloat</span><br><span class="line">...font:(NSFont *)fontObj</span><br><span class="line">...frame:(NSRect)frameRect</span><br><span class="line">...intValue:(int)anInt</span><br><span class="line">...keyEquivalent:(NSString *)charCode</span><br><span class="line">...length:(int)numBytes</span><br><span class="line">...point:(NSPoint)aPoint</span><br><span class="line">...stringValue:(NSString *)aString</span><br><span class="line">...tag:(int)anInt</span><br><span class="line">...target:(id)anObject</span><br><span class="line">...title:(NSString *)aString</span><br></pre></td></tr></table></figure><h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><blockquote><p>大多数情况下,私有方法命名相同与公共方法命名约定相同,但通常我们约定给私有方法添加前缀,以便 与公共方法区分开来。即使这样,私有方法的名称很容易导致特别的问题。当你设计一个继承自 Cocoa framework 某个类的子类时,你无法知道你的私有方法是否不小心覆盖了框架中基类的同名方法。</p></blockquote><p>Cocoa framework 的私有方法名称通常以下划线作为前缀(如:_fooData),以标示其私有属性。基于这 样的事实,遵循以下两条建议:</p><ul><li>不要使用下划线作为你自己的私有方法名称的前缀,Apple 保留这种用法。</li><li>若要继承 Cocoa framework 中一个超大的类(如:NSView),并且想要使你的私有方法名称与基类中的区别开来,你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性, 建议用”p_Method”格式，p代表private。</li></ul><p>尽管为私有方法名称添加前缀的建议与前面类中方法命名的约定冲突,这里的意图有所不同:为了防止不 小心地覆盖基类中的私有方法。</p><h4 id="Part1-2：-Objective-C语法规范"><a href="#Part1-2：-Objective-C语法规范" class="headerlink" title="Part1-2： Objective-C语法规范"></a>Part1-2： Objective-C语法规范</h4><h5 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h5><p>应该 <code>始终</code> 使用点语法来访问或者修改属性，访问其他实例时首选括号。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.backgroundColor &#x3D; [UIColor orangeColor];</span><br><span class="line">[UIApplication sharedApplication].delegate;</span><br></pre></td></tr></table></figure><p>反对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setBackgroundColor:[UIColor orangeColor]];</span><br><span class="line">UIApplication.sharedApplication.delegate;</span><br></pre></td></tr></table></figure><h5 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h5><ul><li>一个缩进使用 4 个空格，永远不要使用制表符（tab）缩进。请确保在 Xcode 中设置了此偏好。</li><li>方法的大括号和其他的大括号（if/else/switch/while 等等）始终和声明在同一行开始，在新的一行结束。</li></ul><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (user.isHappy) &#123;</span><br><span class="line">    &#x2F;&#x2F; Do something</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    &#x2F;&#x2F; Do something else</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法之间应该正好空一行，这有助于视觉清晰度和代码组织性。在方法中的功能块之间应该使用空白分开，但往往可能应该创建一个新的方法。</li><li><code>@synthesize</code> 和 <code>@dynamic</code>在实现中每个都应该占一个新行。</li></ul><h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><p>条件判断主体部分应该始终使用大括号括住来防止出错，即使它可以不用大括号（例如它只需要一行）。这些错误包括添加第二行（代码）并希望它是 if 语句的一部分时。还有另外一种<a href="http://programmers.stackexchange.com/a/16530" target="_blank" rel="noopener">更危险的</a>，当 if 语句里面的一行被注释掉，下一行就会在不经意间成为了这个 if 语句的一部分。此外，这种风格也更符合所有其他的条件判断，因此也更容易检查。</p><p>推荐:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!error) &#123;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!error)</span><br><span class="line">    return success;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!error) return success;</span><br></pre></td></tr></table></figure><h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><p>三目运算符，? ，只有当它可以增加代码清晰度或整洁时才使用。单一的条件都应该优先考虑使用。多条件时通常使用 if 语句会更易懂，或者重构为实例变量。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; a &gt; b ? x : y;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; a &gt; b ? x &#x3D; c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p>当引用一个返回错误参数（error parameter）的方法时，应该针对返回值，而非错误变量。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">if (![self trySomethingWithError:&amp;error]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">[self trySomethingWithError:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些苹果的 API 在成功的情况下会写一些垃圾值给错误参数（如果非空），所以针对错误变量可能会造成虚假结果（以及接下来的崩溃）。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>在方法签名中，在 -/+ 符号后应该有一个空格。方法片段之间也应该有一个空格。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setExampleText:(NSString *)text image:(UIImage *)image;</span><br></pre></td></tr></table></figure><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>变量名应该尽可能命名为描述性的。除了 <code>for()</code>循环外，其他情况都应该避免使用单字母的变量名。 星号表示指针属于变量，例如：<code>NSString *text</code>不要写成 <code>NSString* text</code>或者 <code>NSString * text</code> ，常量除外。 尽量定义属性来代替直接使用实例变量。除了初始化方法<code>（init， initWithCoder:，等）</code>， <code>dealloc</code> 方法和自定义的 <code>setters</code>和 <code>getters</code>内部，应避免直接访问实例变量。更多有关在初始化方法和 <code>dealloc</code> 方法中使用访问器方法的信息，参见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6" target="_blank" rel="noopener">这里</a>。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NYTSection: NSObject</span><br><span class="line">@property (nonatomic) NSString *headline;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NYTSection : NSObject &#123;</span><br><span class="line">    NSString *headline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="变量限定符"><a href="#变量限定符" class="headerlink" title="变量限定符"></a>变量限定符</h6><p>当涉及到在 ARC 中被引入变量限定符时， 限定符 (__strong, __weak, __unsafe_unretained, __autoreleasing) 应该位于星号和变量名之间，如：NSString * __weak text。</p><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>尽可能遵守苹果的命名约定，尤其那些涉及到<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" target="_blank" rel="noopener">内存管理规则</a>，<a href="http://stackoverflow.com/a/2865194/340508" target="_blank" rel="noopener">NARC</a>的。</p><p>长的和描述性的方法名和变量名都不错。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *settingsButton;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *setBut;</span><br></pre></td></tr></table></figure><p>类名和常量应该始终使用三个字母的前缀（例如 NYT），但 Core Data 实体名称可以省略。为了代码清晰，常量应该使用相关类的名字作为前缀并使用驼峰命名法。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSTimeInterval NYTArticleViewControllerNavigationFadeAnimationDuration &#x3D; 0.3;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSTimeInterval fadetime &#x3D; 1.7;</span><br></pre></td></tr></table></figure><p>属性和局部变量应该使用驼峰命名法并且首字母小写。</p><p>为了保持一致，实例变量应该使用驼峰命名法命名，并且首字母小写，以下划线为前缀。这与 LLVM 自动合成的实例变量相一致。 如果 LLVM 可以自动合成变量，那就让它自动合成。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@synthesize descriptiveVariableName &#x3D; _descriptiveVariableName;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id varnm;</span><br></pre></td></tr></table></figure><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>当需要的时候，注释应该被用来解释 为什么 特定代码做了某些事情。所使用的任何注释必须保持最新否则就删除掉。</p><p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。</p><p><code>init</code>和 <code>dealloc</code></p><p><code>dealloc</code>方法应该放在实现文件的最上面，并且刚好在<code>@synthesize</code> 和 <code>@dynamic</code>语句的后面。在任何类中，init 都应该直接放在<code>dealloc</code>方法的下面。</p><p>init 方法的结构应该像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init]; &#x2F;&#x2F; 或者调用指定的初始化方法</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        &#x2F;&#x2F; Custom initialization</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>每当创建 <code>NSString</code>，<code>NSDictionary</code>， <code>NSArray</code>，和<code>NSNumber</code> 类的不可变实例时，都应该使用字面量。要注意 <code>nil</code>值不能传给<code>NSArray</code>和 <code>NSDictionary</code>字面量，这样做会导致崩溃。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *names &#x3D; @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</span><br><span class="line">NSDictionary *productManagers &#x3D; @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;;</span><br><span class="line">NSNumber *shouldUseLiterals &#x3D; @YES;</span><br><span class="line">NSNumber *buildingZIPCode &#x3D; @10018;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *names &#x3D; [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];</span><br><span class="line">NSDictionary *productManagers &#x3D; [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];</span><br><span class="line">NSNumber *shouldUseLiterals &#x3D; [NSNumber numberWithBool:YES];</span><br><span class="line">NSNumber *buildingZIPCode &#x3D; [NSNumber numberWithInteger:10018];</span><br></pre></td></tr></table></figure><h5 id="CGRect-函数"><a href="#CGRect-函数" class="headerlink" title="CGRect 函数"></a>CGRect 函数</h5><p>当访问一个 CGRect 的 x， y， width， height 时，应该使用CGGeometry 函数代替直接访问结构体成员。苹果的 CGGeometry 参考中说到：</p><blockquote><p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p></blockquote><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame &#x3D; self.view.frame;</span><br><span class="line">CGFloat x &#x3D; CGRectGetMinX(frame);</span><br><span class="line">CGFloat y &#x3D; CGRectGetMinY(frame);</span><br><span class="line">CGFloat width &#x3D; CGRectGetWidth(frame);</span><br><span class="line">CGFloat height &#x3D; CGRectGetHeight(frame);</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame &#x3D; self.view.frame;</span><br><span class="line">CGFloat x &#x3D; frame.origin.x;</span><br><span class="line">CGFloat y &#x3D; frame.origin.y;</span><br><span class="line">CGFloat width &#x3D; frame.size.width;</span><br><span class="line">CGFloat height &#x3D; frame.size.height;</span><br></pre></td></tr></table></figure><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>常量首选内联字符串字面量或数字，因为常量可以轻易重用并且可以快速改变而不需要查找和替换。常量应该声明为 static 常量而不是 #define ，除非非常明确地要当做宏来使用。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static NSString * const NYTAboutViewControllerCompanyName &#x3D; @&quot;The New York Times Company&quot;;</span><br><span class="line">static const CGFloat NYTImageThumbnailHeight &#x3D; 50.0;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CompanyName @&quot;The New York Times Company&quot;</span><br><span class="line">#define thumbnailHeight 2</span><br></pre></td></tr></table></figure><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>当使用 <code>enum</code> 时，建议使用新的基础类型规范，因为它具有更强的类型检查和代码补全功能。现在 SDK 包含了一个宏来鼓励使用使用新的基础类型<code>- NS_ENUM()</code></p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NYTAdRequestState) &#123;</span><br><span class="line">    NYTAdRequestStateInactive,</span><br><span class="line">    NYTAdRequestStateLoading</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h5><p>当用到位掩码时，使用 <code>NS_OPTIONS</code> 宏。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NYTAdCategory) &#123;</span><br><span class="line">    NYTAdCategoryAutos      &#x3D; 1 &lt;&lt; 0,</span><br><span class="line">    NYTAdCategoryJobs       &#x3D; 1 &lt;&lt; 1,</span><br><span class="line">    NYTAdCategoryRealState  &#x3D; 1 &lt;&lt; 2,</span><br><span class="line">    NYTAdCategoryTechnology &#x3D; 1 &lt;&lt; 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h5><p>私有属性应该声明在类实现文件的延展（匿名的类目）中。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NYTAdvertisement ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) GADBannerView *googleAdView;</span><br><span class="line">@property (nonatomic, strong) ADBannerView *iAdView;</span><br><span class="line">@property (nonatomic, strong) UIWebView *adXWebView;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="图片命名"><a href="#图片命名" class="headerlink" title="图片命名"></a>图片命名</h5><p>图片名称应该被统一命名以保持组织的完整。它们应该被命名为一个说明它们用途的驼峰式字符串，其次是自定义类或属性的无前缀名字（如果有的话），然后进一步说明颜色 和/或 展示位置，最后是它们的状态。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefreshBarButtonItem &#x2F; RefreshBarButtonItem@2x 和 RefreshBarButtonItemSelected &#x2F; RefreshBarButtonItemSelected@2x</span><br><span class="line">ArticleNavigationBarWhite &#x2F; ArticleNavigationBarWhite@2x 和 ArticleNavigationBarBlackSelected &#x2F; ArticleNavigationBarBlackSelected@2x.</span><br></pre></td></tr></table></figure><p>图片目录中被用于类似目的的图片应归入各自的组中。</p><h5 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h5><p>因为 <code>nil</code>解析为 <code>NO</code>，所以没有必要在条件中与它进行比较。永远不要直接和 YES 进行比较，因为 YES 被定义为 1，而 BOOL 可以多达 8 位。</p><p>这使得整个文件有更多的一致性和更大的视觉清晰度。</p><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!someObject) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (someObject &#x3D;&#x3D; nil) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 BOOL 来说, 这有两种用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isAwesome)</span><br><span class="line">if (![someObject boolValue])</span><br></pre></td></tr></table></figure><p>反对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ([someObject boolValue] &#x3D;&#x3D; NO)</span><br><span class="line">if (isAwesome &#x3D;&#x3D; YES) &#x2F;&#x2F; 永远别这么做</span><br></pre></td></tr></table></figure><p>如果一个 <code>BOOL</code> 属性名称是一个形容词，属性可以省略<code>“is”</code>前缀，但为 get 访问器指定一个惯用的名字，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, getter&#x3D;isEditable) BOOL editable;</span><br></pre></td></tr></table></figure><p>内容和例子来自 Cocoa 命名指南 。</p><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>单例对象应该使用线程安全的模式创建共享的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static id sharedInstance &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance &#x3D; [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将会预防有时可能产生的许多崩溃。</p><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。 注：对于模块使用 @import 语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Frameworks</span><br><span class="line">@import QuartzCore;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Models</span><br><span class="line">#import &quot;NYTUser.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Views</span><br><span class="line">#import &quot;NYTButton.h&quot;</span><br><span class="line">#import &quot;NYTUserView.h&quot;</span><br></pre></td></tr></table></figure><h3 id="Part1-3：-代码注释规范"><a href="#Part1-3：-代码注释规范" class="headerlink" title="Part1-3： 代码注释规范"></a>Part1-3： 代码注释规范</h3><p>当需要的时候，注释应该被用来解释 为什么 特定代码做了某些事情。所使用的任何注释必须保持最新，否则就删除掉。</p><p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。</p><p>#####文件注释<br>采用Xcode自动生成的注释格式，修改部分参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  AppDelegate.m</span><br><span class="line">&#x2F;&#x2F;  oc code good</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by roycms on 16-10-30.</span><br><span class="line">&#x2F;&#x2F;  Copyright (c) 2016 roycms.cn LLC. All rights reserved.</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p>其中<code>项目名称</code>、<code>创建人</code>、<code>公司版权</code>需要填写正确。</p><h5 id="import注释"><a href="#import注释" class="headerlink" title="import注释"></a>import注释</h5><p>如果有一个以上的 import 语句，就对这些语句进行<code>[分组][Import_1]</code>。每个分组的注释是可选的。<br>注：对于模块使用<code>[@import][Import_2]</code> 语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Frameworks</span><br><span class="line">@import QuartzCore;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Models</span><br><span class="line">#import &quot;NYTUser.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Views</span><br><span class="line">#import &quot;NYTButton.h&quot;</span><br><span class="line">#import &quot;NYTUserView.h&quot;</span><br></pre></td></tr></table></figure><h5 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h5><p>采用javadoc的格式，可以使用XCode插件VVDocumenter-Xcode快速添加，只需输入///即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  功能描述</span><br><span class="line"> *</span><br><span class="line"> *  @param tableView 参数说明</span><br><span class="line"> *  @param section   参数说明</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回值说明</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123;</span><br><span class="line">    return [self.familyNames objectAtIndex:section];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码块注释"><a href="#代码块注释" class="headerlink" title="代码块注释"></a>代码块注释</h5><p>单行的用<code>//</code>+空格开头，多汗的采用<code>/* */</code>注释 <code>##TODO</code>注释 TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了。</p><p>格式：<code>//TODO</code>:说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    &#x2F;&#x2F;TODO:增加初始化</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更多规范"><a href="#更多规范" class="headerlink" title="更多规范"></a>更多规范</h4><ul><li><a href="https://github.com/roycms/IosCodeSpecification" target="_blank" rel="noopener">切图规范</a></li></ul><h4 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h4><p><a href="https://github.com/iamlay/IosCodeSpecification" target="_blank" rel="noopener">iOSCodeSpecification</a></p>]]></content>
    
    <summary type="html">
    
      本文主要对iOS开发中需要注意的命名规范、语法规范、注释规范做的总结
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="转载" scheme="www.iamlay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的Next主题中配置Google Analytics之后不生效的问题</title>
    <link href="www.iamlay.com/2020/06/27/HexoGoogleAnalytics/"/>
    <id>www.iamlay.com/2020/06/27/HexoGoogleAnalytics/</id>
    <published>2020-06-27T04:02:27.000Z</published>
    <updated>2020-06-27T08:26:56.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 最近在优化Hexo博客，添加网站分析的功能，在配置Google Analytics之后，一直无法生效，最终发现是因为网站配置文件<code>_config.yml</code>中配置的<code>url</code>和 <code>GitHub Pages</code>的<code>自定义域名</code>不一致导致的。如果没有配置<code>自定义域名</code>的话应该没有问题，但是如果<code>配置了自定义域名</code>的话，一定要保证网站配置文件<code>_config.yml</code>中配置的<code>url</code>和 <code>GitHub Pages</code>的<code>自定义域名</code>一致。</p></blockquote><p>####Part01 - Google Analytics配置<br><code>Google Analytics</code>的配置非常简单，使用<code>NexT</code>主题的用户在<code>Google Analytics官网</code>获取到<code>tracking_id</code>,并在<code>NexT主题配置文件</code>配置好</p><ol><li>获取<code>tracking_id</code><br><img src="./GoogleAnalytics01.png" alt="Alt text"></li><li>在<code>NexT</code>主题配置文件<code>_config.ym</code>配置<code>tracking_id</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Google Analytics</span><br><span class="line">google_analytics:</span><br><span class="line">  tracking_id: UA-170943611-2</span><br><span class="line">  # By default, NexT will load an external gtag.js script on your site.</span><br><span class="line">  # If you only need the pageview feature, set the following option to true to get a better performance.</span><br><span class="line">  only_pageview: false</span><br></pre></td></tr></table></figure></li><li>然后执行Hexo部署命令，部署到网站<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>我们来看一下网站中关于<code>Google Analytics</code>的代码,只有<code>CONGIG.hostname</code>和<code>location.hostname</code>一致的时候才会生效，自己可以在控制台打印一下两者是不是一致。那么<code>CONGIG.hostname</code>和<code>location.hostname</code>都是在哪里配置的呢？？？<br><img src="./GoogleAnalytics02.png" alt="Alt text"></li></ol><p>####Part02 - 配置<code>CONGIG.hostname</code>和<code>location.hostname</code></p><ol><li>配置<code>CONGIG.hostname</code></li></ol><p>正如上文所说，<code>CONGIG.hostname</code>指向得是<code>Hexo</code>根目录下<code>_config.yml</code>中配置的<code>url</code><br><img src="./GoogleAnalytics03.png" alt="Alt text"></p><ol start="2"><li>配置<code>location.hostname</code><br><code>location.hostname</code>指向的是<code>Github网站</code>中仓库的<code>Github Page</code>配置的<code>自定义域名</code></li></ol><p><img src="./GoogleAnalytics04.png" alt="Alt text"></p><p>到这里基本就配置完毕了，可以看下实际效果</p><p><img src="./GoogleAnalytics05.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      本片文章主要是解决在优化Hexo网站的过程中遇到的 `Google Analytics`不生效的问题。
    
    </summary>
    
    
      <category term="网站" scheme="www.iamlay.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报07#| 推荐一款稳定的XXX - Cloudss| 2020-06-25</title>
    <link href="www.iamlay.com/2020/06/25/VPN/"/>
    <id>www.iamlay.com/2020/06/25/VPN/</id>
    <published>2020-06-25T03:03:44.000Z</published>
    <updated>2020-06-27T08:51:59.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Part01-背景"><a href="#Part01-背景" class="headerlink" title="Part01- 背景"></a>Part01- 背景</h4><blockquote><p>对一个开发人员来讲，学会科学上网非常重要。有一些插件使用国内的网络下载非常慢或者直接无法下载，非常的让人捉急。在开发中遇到无法解决的问题的时候，我们很可能求助各种技术网站或者emmmm — 百度。</p><p>使用百度的弊端显而易见：搜索结果前排是一大堆的广告，后面跟着千篇一律的答案，要在各种转载复制的文章中找到最佳的解决方案非常耗费时间。我曾经遇到一个问题，使用百度一个下午一无所获，换成Google之后五分解决问题，这件事情直接导致我放弃使用百度搜索，转向Google搜索。</p></blockquote><p> 但是，因为众所周知的原因Google是没有办法访问的，对很多人来讲找到一款便宜稳定的<code>VPN</code>又要花费非常多的时间。相信初级开发者都使用过广为推荐的<code>蓝灯</code>，我最早使用的VPN也是<code>蓝灯</code>，但是免费版本的<code>蓝灯</code>一方面限速限量，另一方面在国内开各种会议的时候直接嗝屁。非常影响体验。后来走上了自己购买国外服务器搭梯子的道路：我当时是在<code>Vultr.com</code>上面买的服务器，然后使用<code>Outline</code>上网，但是在国内两会期间也会被墙，感觉自己搭建服务器花费的时间成本和获得体验是不成正比的，就放弃了。</p><p>后来同事推荐了一个VPN购买网站<a href="https://store.cloudss.org/aff.php?aff=5579" target="_blank" rel="noopener">CloudSS</a>，<a href="https://store.cloudss.org/aff.php?aff=5579" target="_blank" rel="noopener">CloudSS</a>提供的是<code>V2Ray</code>    服务，到现在用了差不多9个月的时间，中间没有出现过被墙，即便是在国内两会期间也非常稳定，所以给大家种草。<br>![Alt text](./截屏2020-06-25 下午2.58.03.png)</p><p>大家无需翻墙，可以直接访问<a href="https://store.cloudss.org/aff.php?aff=5579" target="_blank" rel="noopener">ClodSS的官网</a>,没查出来<a href="https://store.cloudss.org/aff.php?aff=5579" target="_blank" rel="noopener">ClodSS</a>是哪里的公司，但是官网支持<code>英语</code>和<code>汉语</code>两种语言：<img src="./VPN02.png" alt="Alt text"></p><h4 id="Part02-购买"><a href="#Part02-购买" class="headerlink" title="Part02- 购买"></a>Part02- 购买</h4><p><code>用户中心</code> -&gt; <code>购买服务</code> -&gt;<code>购买页面</code>-&gt;<code>立即订购</code>-&gt;<code>支付</code> -&gt;<code>购买成功</code></p><p><strong>购买服务入口：</strong><br><img src="./VPN03.png" alt="Alt text"></p><p><strong>服务选择页面：</strong></p><p><img src="./VPN04.png" alt="Alt text"></p><hr><h2 id="这里说下，CloudSS有四种产品：-V2-Trail-3G-A-、V2-25G-A-、V2-S1-A-、V2-S2-A。-这几种产品都支持iOS、Android、Windows、Mac四种类型的设备"><a href="#这里说下，CloudSS有四种产品：-V2-Trail-3G-A-、V2-25G-A-、V2-S1-A-、V2-S2-A。-这几种产品都支持iOS、Android、Windows、Mac四种类型的设备" class="headerlink" title="这里说下，CloudSS有四种产品： V2-Trail-3G-A 、V2-25G-A 、V2-S1-A 、V2-S2-A。 这几种产品都支持iOS、Android、Windows、Mac四种类型的设备"></a><strong>这里说下，<a href="https://store.cloudss.org/aff.php?aff=5579" target="_blank" rel="noopener">CloudSS</a>有四种产品： <code>V2-Trail-3G-A</code> 、<code>V2-25G-A</code> 、<code>V2-S1-A</code> 、<code>V2-S2-A</code>。 这几种产品都支持iOS、Android、Windows、Mac四种类型的设备</strong></h2><h5 id="V2-Trail-3G-A"><a href="#V2-Trail-3G-A" class="headerlink" title="V2-Trail-3G-A"></a>V2-Trail-3G-A</h5><p>3G流量，可以使用7天，$9.9,<br>但是可以在支付的时候填<code>v2ray</code>的优惠码，价格就变成0.2$了，每个人一次机会，相当于体验版,不限制同时使用的设备数量;</p><p><img src="./VPN05.png" alt="Alt text"></p><h5 id="V2-25G-A"><a href="#V2-25G-A" class="headerlink" title="V2-25G-A"></a>V2-25G-A</h5><p>25G流量，使用30天，不限制设备数量，不限制节点数量<br><img src="./VPN06.png" alt="Alt text"></p><h5 id="V2-S1-A"><a href="#V2-S1-A" class="headerlink" title="V2-S1-A"></a>V2-S1-A</h5><p>每月128G流量，使用半年，最多5台设备同时登录，不限制节点数量</p><p><img src="./VPN07.png" alt="Alt text"></p><h5 id="V2-S2-A"><a href="#V2-S2-A" class="headerlink" title="V2-S2-A"></a>V2-S2-A</h5><p>每月256G流量，使用一年，最多5台设备同时登录，不限制节点数量</p><p><img src="./VPN08.png" alt="Alt text"></p><p>大家可以根据自己的需要选好需要的产品，然后加到购物车，支付就可以了。支持<code>支付宝</code>和<code>Paypal</code>两种支付方式。<br><img src="./VPN09.png" alt="Alt text"></p><p><img src="./VPN10.png" alt="Alt text"></p><h4 id="Part03-使用服务"><a href="#Part03-使用服务" class="headerlink" title="Part03- 使用服务"></a>Part03- 使用服务</h4><p>购买成功之后，可以在网站看到自己购买的服务，如图：</p><p><img src="./VPN11.png" alt="Alt text"></p><p>点击购买的服务，进入到服务页面，可以看到：<br><img src="./VPN12.png" alt="Alt text"></p><p>大家可以先根据第一步的<code>使用教程</code>，下载下来自己设备需要的软件，安装完成之后，将第二步中<code>复制的地址</code>添加到软件中,然后就可以愉快的上网了。看一下<code>使用教程页面</code>:<br><img src="./VPN13.png" alt="Alt text"></p><p>使用教程页面给出了每种平台使用的软件的下载地址，并给出了配置的详细步骤，这里我就不多说了。有一个细节非常值得一提，因为我使用的移动设备是iOS，使用的软件是<code>Shadowrocket</code>,但是<code>Shadowrocket</code>在中国区是不能下载的，而且也是一个付费软件，<a href="https://store.cloudss.org/aff.php?aff=5579" target="_blank" rel="noopener">CloudSS</a>给免费提供了下载<code>Shadowrocket</code>的账号和密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple商店账号：acc@shadowrocket.online</span><br><span class="line">Apple商店密码：88FREE@shadowrocket.online</span><br></pre></td></tr></table></figure><p>现在，我们来看看效果：</p><p>Mac端：<br><img src="./VPN14.png" alt="Alt text"></p><p>iPhone端：</p><p><img src="./VPN15.png" alt="Alt text"></p><p>希望这篇文章对大家有帮助，避免浪费更多的时间在稂莠不齐的VPN中，提升大家的生产力！</p>]]></content>
    
    <summary type="html">
    
      这片Blog的主要目的是给大家介绍一款不错的`VPN`,希望大家不要把很多的时间浪费在寻找各种稂莠不齐的`VPN`中，希望大家科学上网，提升自己的生产力！
    
    </summary>
    
    
      <category term="随笔" scheme="www.iamlay.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报06#| ReactiveCocoa入门篇| 2020-05-10</title>
    <link href="www.iamlay.com/2020/05/10/week19/"/>
    <id>www.iamlay.com/2020/05/10/week19/</id>
    <published>2020-05-10T12:58:53.000Z</published>
    <updated>2020-05-10T13:42:10.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Part-01-背景"><a href="#Part-01-背景" class="headerlink" title="Part-01 背景"></a>Part-01 背景</h3><p>作为一个iOS开发者，写的每一行代码都是对事件的反馈，像Button点击、网络请求、属性改变（KVO）、用户位置改变等。但是这些事件的处理采用的是Actions、delegate、KVO、回调等不同的方式。<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>针对不同的事件定义了的标准接口，这样不同的事件可以更容易链式调用、过滤、组合。</p><p>ReactiveCocoa组合了一对编程范式：<a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">函数式编程</a>：使用更高级别的函数，该函数用其他函数作为他的参数。<a href="http://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">响应式编程</a>:一种面向数据流和变化传播的声明式编程范式。所以，ReactiveCocoa也被称之为函数响应式编程框架。</p><p>ReactiveCocoa教程马上开始，接下来的教程侧重点在实用价值，所以给出的是实操而不是长篇大论。</p><h3 id="Part-02-实践"><a href="#Part-02-实践" class="headerlink" title="Part-02 实践"></a>Part-02 实践</h3><h4 id="ReactivePlayground"><a href="#ReactivePlayground" class="headerlink" title="ReactivePlayground"></a>ReactivePlayground</h4><p>在接下来的整个ReactiveCocoa教程中，我们将通过ReactivePlayground这个应用来逐步引入响应式编程。下载<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlayground-Starter.zip" target="_blank" rel="noopener">ReactivePlayground工程</a>，确保可以正常的build和run.</p><p>ReactivePlaygroun是一款非常简单的应用，主要就是给用户展示了一个登录的页面。输入用户的账号和密码，验证通过之后，进入到一个有一只可爱猫咪的页面。</p><p><img src="./week1901.jpg" alt="Alt text"></p><p>打开工程，找到  <strong>RWViewController.m</strong>文件，你花费多久的时间可以找到<strong>Sign In</strong> Button变成enabing状态所需要的条件？展示/隐藏 <strong>signInFaulure</strong> Label的规则是什么？ 也许，你花费两三分钟的时间就可以回答这些问题，但是当你面对更加复杂的项目的时候，你分析同样的问题可能就会花费相当长的时间。</p><p>这就是ReactiveCocoa的优势所在，ReactiveCocoa能够让应用程序的基本意图变得更加清晰。那让我们开始我们的工作吧！！！</p><h4 id="添加ReactiveCocoa框架"><a href="#添加ReactiveCocoa框架" class="headerlink" title="添加ReactiveCocoa框架"></a>添加ReactiveCocoa框架</h4><p>最方便的方式就是通过<a href="http://cocoapods.org/" target="_blank" rel="noopener">CocoaPods.</a>的方式导入框架。如果在此之前你没有使用过<a href="http://cocoapods.org/" target="_blank" rel="noopener">CocoaPods.</a>，可以按照本网站的<a href="https://www.raywenderlich.com/?p=12139" target="_blank" rel="noopener">CocoaPods 入门教程</a>进行操作，或者至少通过该教程的初始步骤进行操作，以便安装必备的组件。</p><blockquote><p>如果因为某些原因你不想引入CocoaPods，你仍旧可以通过其他的方式使用ReactiveCocoa。可以参考Github上面的<a href="https://github.com/ReactiveCocoa/ReactiveCocoa#importing-reactivecocoa" target="_blank" rel="noopener">引入ReactiveCocoa</a>文档，一步步操作。</p></blockquote><p>打开终端，进入到下载工程的根目录，执行下面的指令创建Podfile文件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch Podfile</span><br><span class="line">open -e Podfile</span><br></pre></td></tr></table></figure><p>用文本编辑器打开Podfile文件，复制下面的代码到里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;7.0&#39;</span><br><span class="line">pod &#39;ReactiveCocoa&#39;, &#39;2.1.8&#39;</span><br></pre></td></tr></table></figure><p>这两句代码的意思是设置iOS平台且最小支持的版本是7.0、添加ReactiveCocoa框架作为依赖。保存文件，继续在终端执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>你会看到终端打印出类似下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing ReactiveCocoa (2.1.8)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] From now on use &#96;RWReactivePlayground.xcworkspace&#96;.</span><br></pre></td></tr></table></figure><p>这意味着ReactiveCocoa framework已经被下载下来了，CocoaPods创建一个Xcode workspace文件将应用和framework整合起来了</p><p><img src="./week1902.png" alt="Alt text"></p><h4 id="开始实施"><a href="#开始实施" class="headerlink" title="开始实施"></a>开始实施</h4><p>正如上面介绍中提到的，ReacticeCocoa为应用程序中发生的事件流提供了一个标准的接口。这种接口在ReactiveCocoa中称为信号(Signal),通过<code>RACSignal</code>类来表示。</p><p>打开<code>RWViewController.m</code>文件，引入ReactiveCocoa头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br></pre></td></tr></table></figure><p>暂时先不用替换任何现有代码，只需要做一些操作即可。添加下面的代码到<code>viewDidload</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.usernameTextField.rac_textSignal subscribeNext:^(id x)&#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>运行应用程序，在username textField中输入文字，查看控制台输出的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2013-12-24 14:48:50.359 RWReactivePlayground[9193:a0b] i</span><br><span class="line">2013-12-24 14:48:50.436 RWReactivePlayground[9193:a0b] is</span><br><span class="line">2013-12-24 14:48:50.541 RWReactivePlayground[9193:a0b] is </span><br><span class="line">2013-12-24 14:48:50.695 RWReactivePlayground[9193:a0b] is t</span><br><span class="line">2013-12-24 14:48:50.831 RWReactivePlayground[9193:a0b] is th</span><br><span class="line">2013-12-24 14:48:50.878 RWReactivePlayground[9193:a0b] is thi</span><br><span class="line">2013-12-24 14:48:50.901 RWReactivePlayground[9193:a0b] is this</span><br><span class="line">2013-12-24 14:48:51.009 RWReactivePlayground[9193:a0b] is this </span><br><span class="line">2013-12-24 14:48:51.142 RWReactivePlayground[9193:a0b] is this m</span><br><span class="line">2013-12-24 14:48:51.236 RWReactivePlayground[9193:a0b] is this ma</span><br><span class="line">2013-12-24 14:48:51.335 RWReactivePlayground[9193:a0b] is this mag</span><br><span class="line">2013-12-24 14:48:51.439 RWReactivePlayground[9193:a0b] is this magi</span><br><span class="line">2013-12-24 14:48:51.535 RWReactivePlayground[9193:a0b] is this magic</span><br><span class="line">2013-12-24 14:48:51.774 RWReactivePlayground[9193:a0b] is this magic?</span><br></pre></td></tr></table></figure><p>可以看到，每当改变textfield内容的时候，block中的代码都会执行。这里既没有target-action、也没有代理方法，仅仅用到了signals和block，令人激动万分！</p><p>ReactiveCocoa的 <code>信号</code>（通过RACSignal表示）发送事件流给它的订阅者。主要是有三种类型的事件：<code>next</code>、<code>error</code>、<code>completed</code>. 信号会因为<code>error</code>或者<code>complete</code>结束，但在结束之前可以发送任意数量的<code>next</code>事件。</p><p><code>RACSignal</code>有多种方法用于订阅不同的事件类型，每种方法都一个或者多个block，事件发生的时候可以用来执行你想要的逻辑。比如：<code>subscribeNext:</code>方法就提供了这样一个block，每当<code>next</code>事件发生的时候，就会执行该block;</p><p>ReactiveCocoa框架通过<code>类别</code>给标准的UIKit控件添加信号，因此你可以订阅这些控件的事件。这就是你可以在textfield上使用<code>rac_textSignal</code>属性的原因。</p><p>ReactiveCocoa有大量的可以用来操纵事件流的<code>操作符</code>。比如：你只对长度超过三个字符的用户名感兴趣，那么就可以使用    <code>filter</code>操作符。将viewDidload中添加的代码更新为下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text &#x3D; value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>运行程序，然后在文本框继续输入字符，你会发现控制台在textfield的内容长度超过3的时候才打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2013-12-26 08:17:51.335 RWReactivePlayground[9654:a0b] is t</span><br><span class="line">2013-12-26 08:17:51.478 RWReactivePlayground[9654:a0b] is th</span><br><span class="line">2013-12-26 08:17:51.526 RWReactivePlayground[9654:a0b] is thi</span><br><span class="line">2013-12-26 08:17:51.548 RWReactivePlayground[9654:a0b] is this</span><br><span class="line">2013-12-26 08:17:51.676 RWReactivePlayground[9654:a0b] is this </span><br><span class="line">2013-12-26 08:17:51.798 RWReactivePlayground[9654:a0b] is this m</span><br><span class="line">2013-12-26 08:17:51.926 RWReactivePlayground[9654:a0b] is this ma</span><br><span class="line">2013-12-26 08:17:51.987 RWReactivePlayground[9654:a0b] is this mag</span><br><span class="line">2013-12-26 08:17:52.141 RWReactivePlayground[9654:a0b] is this magi</span><br><span class="line">2013-12-26 08:17:52.229 RWReactivePlayground[9654:a0b] is this magic</span><br><span class="line">2013-12-26 08:17:52.486 RWReactivePlayground[9654:a0b] is this magic?</span><br></pre></td></tr></table></figure><p>其实，在这里你创建了一个非常简单的管道。这就是响应式编程的本质，通过数据流的方式来表达应用程序的功能。下面的图片看起来更为直观：<br><img src="./week1903.png" alt="Alt text"></p><p>上图可以看到，<code>rac_textSignal</code>是事件的初始来源，数据流通过一个<code>filter</code>过滤,该<code>filter</code>仅允许字符长度大于等于3的事件通过。该管道的最后一步是<code>subscribeNext:</code>,在这一步可以通过block打印事件的值。</p><p>这里需要注意的一点是，<code>filter</code>的返回值也是<code>RACSignal</code>,可以通过下面的方式揭示管道的执行过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameSourceSignal &#x3D; </span><br><span class="line">    self.usernameTextField.rac_textSignal;</span><br><span class="line"></span><br><span class="line">RACSignal *filteredUsername &#x3D; [usernameSourceSignal  </span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text &#x3D; value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">[filteredUsername subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>因为在<code>RACSignal</code>执行的每一种操作符返回还是<code>RACSignal</code>,因此也被称为<a href="http://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">fluentinterface</a>。该功能可以使你构造管道，而无需用局部变量引用每个步骤。<br>    &gt; Note: ReacticeCocoa使用了大量的blocks。如果你之前没有接触过block,你应该先看看Apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html" target="_blank" rel="noopener">Blocks Programming Topics</a>,如果你像我一样对block很熟悉，但是对语法有点疑惑的话，可以访问<a href="http://fuckingblocksyntax.com/" target="_blank" rel="noopener">http://fuckingblocksyntax.com/</a>来巩固下你的知识。</p><p>####隐式转换</p><p>将之前的拆分的代码恢复成流式语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text &#x3D; value; &#x2F;&#x2F; implicit cast</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>上面指定位置代码的隐式转换不够优雅，因为传递给该block的值始终是NSString类型，所以可以直接更改参数类型本身，更新代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>运行代码，会发现和之前的效果一致。</p><h4 id="什么是-【事件-】？"><a href="#什么是-【事件-】？" class="headerlink" title="什么是 【事件 】？"></a>什么是 【事件 】？</h4><p>到目前为止，本教程已经描述了不同的事件类型，但是没有详细介绍这些事件的结构。有趣的是，事件可以包含任何东西！</p><p>为了证明这一点，向该管道添加另一种操作符，更新代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[[self.usernameTextField.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return @(text.length);</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSNumber *length) &#123;</span><br><span class="line">    return [length integerValue] &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>运行代码，发现控制台将会打印text field的内容长度而不是内容本身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2013-12-26 12:06:54.566 RWReactivePlayground[10079:a0b] 4</span><br><span class="line">2013-12-26 12:06:54.725 RWReactivePlayground[10079:a0b] 5</span><br><span class="line">2013-12-26 12:06:54.853 RWReactivePlayground[10079:a0b] 6</span><br><span class="line">2013-12-26 12:06:55.061 RWReactivePlayground[10079:a0b] 7</span><br><span class="line">2013-12-26 12:06:55.197 RWReactivePlayground[10079:a0b] 8</span><br><span class="line">2013-12-26 12:06:55.300 RWReactivePlayground[10079:a0b] 9</span><br><span class="line">2013-12-26 12:06:55.462 RWReactivePlayground[10079:a0b] 10</span><br><span class="line">2013-12-26 12:06:55.558 RWReactivePlayground[10079:a0b] 11</span><br><span class="line">2013-12-26 12:06:55.646 RWReactivePlayground[10079:a0b] 12</span><br></pre></td></tr></table></figure><p>新增的<code>map</code>操作通过提供的block来转换事件数据流。对于接收到的每一个<code>next</code>事件，它都会执行该block, 然后发出返回值，该返回值仍旧是一个<code>next</code>事件。上面的代码中，    <code>map</code>操作符拿到<code>NSString</code>类型的值，获得其长度，并将其转换成<code>NSNumber</code>类型返回。</p><p>有关此功能的图形描述，可以看下面的图片：<br><img src="./week1904.png" alt="Alt text"></p><p>如你所见，<code>map</code>操作符之后的所有的步骤收到的都是<code>NSNumber</code>实例。你可以使用<code>map</code>操作符将收到数据转换成任意类型的对象。</p><blockquote><p>Note: 上面代码中的text.length 返回的是NSInteger类型，它是一种基本类型。为了将其作为事件的内容来使用，必须将其进行包装。Objectice-C提供了一种简洁的字面量语法来进行此此操作@(texr.length)</p></blockquote><p>现在应该使用所学的概念来更新<strong>ReactivePlayground</strong>的代码。</p><h4 id="创建-Valid-State-Signals"><a href="#创建-Valid-State-Signals" class="headerlink" title="创建 Valid State Signals"></a>创建 Valid State Signals</h4><p>首先要做的就是，创建一对信号来指示<code>username</code>和<code>password</code>是否是有效的。在<strong>RWViewController.m</strong>的viewDidload方法中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *validUsernameSignal &#x3D;</span><br><span class="line">  [self.usernameTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidUsername:text]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *validPasswordSignal &#x3D;</span><br><span class="line">  [self.passwordTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidPassword:text]);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>如你所见，上面的代码将<code>map</code>操作符应用到每一个textfield的<code>rac_textSignal</code>，输出由Bool值封装的NSNumber对象。</p><p>接下来继续转换这些信号，以便它们能够为textfield提供合适的背景色。你通过订阅这些信号，拿到相应的值就可以更新textfield的背景色，一个可行的选择如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[validPasswordSignal</span><br><span class="line">  map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.passwordTextField.backgroundColor &#x3D; color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>先不要添加上面的代码，因为我们还有更加优雅的方式。</p><p>我们的目的是将信号的输出值赋值给textfield的background属性，但是上面的代码并不具备很好的表达性，赋值语句太过于靠后了。</p><p>幸运的是ReactiveCocoa有一个宏定义，允许你更加优雅的来表达这个功能。将下面的代码直接添加到viewDidload中两个signals的下方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.passwordTextField, backgroundColor) &#x3D;</span><br><span class="line">  [validPasswordSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">      return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">RAC(self.usernameTextField, backgroundColor) &#x3D;</span><br><span class="line">  [validUsernameSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">     return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p><code>RAC</code>宏定义允许你将信号的输出赋值给对象的属性，它需要两个参数，第一个是包含要设置属性的对象。第二个是参数是属性名称。每次信号发出下一个事件时，传递的值都会赋值给给定的属性。</p><p>是不是非常优雅的解决方案？</p><p>最后一件要做的事情是移除洗面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.usernameTextField.backgroundColor &#x3D; self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">self.passwordTextField.backgroundColor &#x3D; self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br></pre></td></tr></table></figure><p>通过下面的图像，可视化当前的逻辑。可以看到，这里有两个简单的管道，它们获取文本信号，然后通过<code>map</code>将它们映射为有指示有效性的Bool值，然后再映射为UIColor,将UIcolor绑定到textfield 的backgroundcolor上。<br><img src="/week1905.png" alt="Alt text"></p><p>你是否好奇，为什么创建了两个分离的信号<code>validPasswordSignal</code>和<code>validUsernameSignal</code>,而不是为每个textfield创建一个单一的流畅管道。保持耐心，这种疯狂背后的方法很快将变得清晰！！！</p><h4 id="Combining-signals-组合信号"><a href="#Combining-signals-组合信号" class="headerlink" title="Combining signals (组合信号)"></a>Combining signals (组合信号)</h4><p>当前情况下， <strong>Sigin  In</strong>Button只有在username和password输入框都有效的情况下才能点击，是时候通过响应式的方式来做这件事情了。</p><p>当前的代码已经有能发出boolean类型值的<strong>信号</strong>，来显示username和password是否是有效的：<code>validUsernameSignal</code>和<code>validPasswordSignal</code>。你要做的就是将这两种信号组合起来，以确定何时是该Button处于enable状态。</p><p>在viewDidload方法中添加下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signUpActiveSignal &#x3D; [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</span><br><span class="line">   reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;</span><br><span class="line">        return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>上面的代码通过<code>combineLatest:reduce:</code>方法组合<code>validUsernameSignal</code>和<code>validPasswordSignal</code>提交的最新值成为一个新的信号。每当两个信号中的任意一个提交了新值<code>reduce</code> block都会执行,其返回值将成为<code>组合信号</code>的下一个值。</p><blockquote><p>RACSignal组合方法可以组合任意数量的信号，reduce block中的参数对应着每个<code>源信号</code>的值。ReacticeCocoa有一个小的实用类<code>RACBlockTrampoline</code>,该类用来处理reduce block中的可变参数列表。</p></blockquote><p>现在你就有了一个合适的信号，继续添加下面的代码到    <code>viewDidload</code>方法的最后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123;</span><br><span class="line">   self.signInButton.enabled &#x3D; [signupActive boolValue];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><p>在运行程序之前，移除下面的属性和代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) BOOL passwordIsValid;</span><br><span class="line">@property (nonatomic) BOOL usernameIsValid;</span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line">&#x2F;&#x2F; handle text changes for both text fields</span><br><span class="line">[self.usernameTextField addTarget:self</span><br><span class="line">                           action:@selector(usernameTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br><span class="line">[self.passwordTextField addTarget:self </span><br><span class="line">                           action:@selector(passwordTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br></pre></td></tr></table></figure><p>同时也移除<code>updateUIState</code>、<code>usernameTextFieldChange</code>和<code>passwordTextfieldChange</code>方法。最后确保移除viewDidload中对<code>updateUIState</code>的调用。</p><p>运行程序，测试<strong>Sign In</strong> button，当username和password都是有效的时候，<code>Sign In</code> Button应该也是enabled的。这个逻辑如下图：<br><img src="./week1906.png" alt="Alt text"></p><p>上图揭示了一对非常重要的概念，这对概念可以让你用ReactiveCocoa执行非常强大的任务</p><ul><li>拆分 - 信号可以有多个订阅者，并充当多个后续管道步骤的源。上图中，指示username和password有效性的boolean信号被拆分，并用于不同的目的。</li><li>组合 - 可以组合多个信号创建新的信号，上图只是组合的boolean信号，实际上你可以组合任意类型的信号。</li></ul><p>这些更改的结果是不再需要指示两个textfield是否有效的私有属性，这是使用响应式的主要特征之一 ： 不再需要实例变量来追踪瞬时状态。</p><h4 id="Reactice-Sign-In-（响应式登录）"><a href="#Reactice-Sign-In-（响应式登录）" class="headerlink" title="Reactice Sign-In （响应式登录）"></a>Reactice Sign-In （响应式登录）</h4><p>目前为止，只有管理textfield和button的状态使用到了响应式编程的方式，但是按钮的点击事件处理仍旧在使用action的方式，接下来要做的就是用响应式的方式来做替代action的方式。</p><p><code>Sign In</code> Button的点击事件通过<code>storyboard action</code>的方式写在了<code>RWViewController.m</code>的<code>signInButtonTouched</code>中。我们要做的就是取代这种方式，所以第一步就是做的就是断开和storyboard action的关联。</p><p>打开<code>Main.storyboard</code>,找到<code>Sign In</code> Button,点击<code>crtl</code>键打开<code>outlet/action</code>连接，点击X移除连接，下图显示在哪里可以找到删除按钮：<br><img src="./week1907.jpg" alt="Alt text"></p><p>你已经知道ReactiveCocoa 框架如何给UIKit标准控件添加属性和方法。在此之前，你是用的是<code>rac_textSignal</code>，它在text改变的时候提交事件。为了处理事件，你需要另一种方法：    <code>rac_signalForControEvents</code>.</p><p>回到<code>RWViewController.m</code>，在viewDidload方法最后添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;button clicked&quot;);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>上面的代码从Button的<code>UIControlEventTouchUpInside</code>事件创建了一个的信号，并添加订阅，以便每次该事件发生的时候都会打印日志。</p><p>运行程序，当username和password有效的时候，点击该button, 查看控制台输出日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2013-12-28 08:05:10.816 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:11.675 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.605 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.766 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.917 RWReactivePlayground[18203:a0b] button clicked</span><br></pre></td></tr></table></figure><p>现在按钮有了点击事件的信号，下一步是将此与登录过程本身关联起来。这带来一些问题，但是没关系，你并不介意这些问题，对吗？ 打开<code>RWDummySigInService.h</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^RWSignInResponse)(BOOL);</span><br><span class="line"></span><br><span class="line">@interface RWDummySignInService : NSObject</span><br><span class="line"></span><br><span class="line">- (void)signInWithUsername:(NSString *)username</span><br><span class="line">                  password:(NSString *)password </span><br><span class="line">                  complete:(RWSignInResponse)completeBlock;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>该接口将<code>username</code>、<code>password</code>和<code>completeBlock</code>作为参数，当登录成功或者失败的时候执行<code>completeBlock</code>。你可以直接在button的<code>subscribeNext:</code>的block中调用该接口，为什么你能这么做呢？因为这种异步的、基于事件的行为，对ReactiveCocoa来说就是家常便饭。</p><blockquote><p>Note: 为了简单期间，本教程使用的简单的虚拟服务，这样就不依赖任何外部的API。但是现在有一个非常现实的问题，怎么使用未用信号表示的API。</p></blockquote><h4 id="Creating-Signals-创建信号"><a href="#Creating-Signals-创建信号" class="headerlink" title="Creating Signals (创建信号)"></a>Creating Signals (创建信号)</h4><p>幸运的是，将现有的异步API调整为信号相当容易。首先移除<code>signInButtonTouched:</code>方法，该方法将被其他逻辑所取代。<br>在<code>RWViewController.m</code>中添加下面的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signInSignal &#123;</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [self.signInService</span><br><span class="line">     signInWithUsername:self.usernameTextField.text</span><br><span class="line">     password:self.passwordTextField.text</span><br><span class="line">     complete:^(BOOL success) &#123;</span><br><span class="line">       [subscriber sendNext:@(success)];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">     &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法创建了使用当前的username和password登录的信号，现在将其进行拆解：</p><p>上面的代码使用<code>RACSignal</code>中的<code>createSignal:</code>方法创建信号，该方法的参数是一个Block，用来描述该信号，且该Block只有一个参数。当信号有订阅者的时候，该Block中的代码将会执行。</p><p>传递给该Block的是一个<code>subscriber</code>实例，该实例遵守<code>RACSubscriber</code>协议，该协议中有你用来发出事件的方法，你可以发送任意个数的<code>next</code>事件,这些事件会因为<code>error</code>或者<code>complete</code>事件结束。本教程中，将会发送一个<code>next</code>事件来显示是否登录成功或者失败，然后发送    <code>comlete</code>事件结束。</p><p>这个Block的返回值是一个    <code>RACDisposable</code>对象，它允许你执行取消或者取消订阅的时候可能需要的任何清理工作。此信号因为没有任何清理需要，所以直接返回<code>nil</code>;</p><p>正如你所看到的，在信号中包装异步的API非常的简单。</p><p>现在我们来利用这个信号，将下面的代码添加到viewDidload的最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   map:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>上面的代码通过<code>map</code>操作符将登录信号转换为登录信号，订阅者只打印结果。</p><p>直接运行该代码，然后点击<code>Sign In</code>Button，查看XCode的控制台打印，将会看到下面的结果,该结果也许和你想象的不太一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result:</span><br><span class="line">                                   &lt;RACDynamicSignal: 0xa068a00&gt; name: +createSignal:</span><br></pre></td></tr></table></figure><p><code>subscribeNext:</code>block传递的是整个信号，而不是登录信号的结果。</p><p>来看下这张图：<br><img src="./week1908.png" alt="Alt text"></p><p>当你点击button的时候，<code>rac_signallForControlEvents</code>发出一个<code>next</code>事件，然后<code>map</code>将创建并返回登录信号，这意味着下面的管道步骤接收的是RACSignal。这就是你在<code>subscribeNext:</code>中观察到的内容。</p><p>上面中情况称为信号中的信号，换言之是包含内部信号的外部信号。如果你想的话，你可以在外部信号的    <code>subscribeNext:</code>中订阅内部信号。但是这样做会导致嵌套混乱！幸运的是，这是一个常见的问题，ReactiveCocoa已经针对这种情况做好了准备;</p><h4 id="信号中的信号"><a href="#信号中的信号" class="headerlink" title="信号中的信号"></a>信号中的信号</h4><p>此问题的解决步骤非常的简单，只需将<code>map</code>函数改成<code>flattenMap</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>这段代码同样是将按钮的<code>点击信号</code>映射为<code>登录信号</code>,但是<code>flattens</code>可以将事件从内部信号发送到外部信号。</p><p>运行代码，看一下Xcode的控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2013-12-28 18:20:08.156 RWReactivePlayground[22993:a0b] Sign in result: 0</span><br><span class="line">2013-12-28 18:25:50.927 RWReactivePlayground[22993:a0b] Sign in result: 1</span><br></pre></td></tr></table></figure><p>现在这个管道正在做的就是你想要的了，最后一步就是在<code>subscribeNext</code>中添加相关的逻辑，以在登录成功之后执行所需的导航。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">  rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">  flattenMap:^id(id x) &#123;</span><br><span class="line">    return [self signInSignal];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">    BOOL success &#x3D; [signedIn boolValue];</span><br><span class="line">    self.signInFailureText.hidden &#x3D; success;</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>运行程序：<br><img src="./week1909.jpg" alt="Alt text"></p><p>你是否注意到当前的应用程序存在一个小的用户体验的问题？ 当登录服务验证提供的凭据时，应禁用登录按钮。这样可以防止用户重复相同的登录。此外，如果出现登录尝试失败，当用户再次尝试登录时，错误消息应隐藏。</p><p>但是，如何将此逻辑添加到当前管道？更改按钮的<code>enable</code>状态不是<code>transformation</code>、<code>filter</code>或到目前为止遇到的任何其他概念。其实，它被称为<code>副作用</code>或<code>管道中next事件发生时执行的逻辑</code>，它实际上不会更改事件本身。</p><h4 id="Adding-side-effects（添加副作用）"><a href="#Adding-side-effects（添加副作用）" class="headerlink" title="Adding side-effects（添加副作用）"></a>Adding side-effects（添加副作用）</h4><p>用下面的代码取代当前的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   doNext:^(id x) &#123;</span><br><span class="line">     self.signInButton.enabled &#x3D; NO;</span><br><span class="line">     self.signInFailureText.hidden &#x3D; YES;</span><br><span class="line">   &#125;]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">     self.signInButton.enabled &#x3D; YES;</span><br><span class="line">     BOOL success &#x3D; [signedIn boolValue];</span><br><span class="line">     self.signInFailureText.hidden &#x3D; success;</span><br><span class="line">     if (success) &#123;</span><br><span class="line">       [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>你可以看到上面如何添加 <code>doNext：</code>,在按钮触摸事件创建后立即向管道添加该步骤。请注意，    <code>doNext：</code> 块没有返回值，因为它是副作用，它使事件本身保持不变。</p><p>上面的 <code>doNext：</code> 块将按钮的属性设置为 NO，并隐藏失败文本。当订阅<code>Next：</code>块的时候重新启用按钮，并根据登录结果显示或隐藏失败文本。</p><p><img src="./week1910.png" alt="Alt text"></p><p>运行应用程序以确认登录按钮按预期启用和禁用</p><p>现在，你的工作就完成了 – 应用程序现在完全是Reactive状态。</p><blockquote><p>Note: 当异步事件正在进行的时候禁用button是一个常见的问题，如果ReacticeCocoa中遍布这种处理就会显得非常混乱。<code>RACCommand</code> 封装了这个概念，并具有<code>enabled</code>信号，允许您将Button的<code>enable</code>属性连接到信号, 可能你需要尝试该类。</p></blockquote><p>####结论</p><p>希望本教程已经给你一个良好的基础，这将有助于你在自己的应用程序中使用ReactiveCocoa框架。熟悉这些概念可能需要多加练习，但与任何语言或程序一样，一旦你找到它的窍门，它真的很简单。ReactiveCocoa的核心是信号，它们只不过是事件流。还有什么比这更简单的呢？</p><p>对于ReactiveCocoa，我发现的有趣的事情之一是有许多方法可以解决同样的问题。你可以通过这个应用程序练习，通过调整信号和管道，以更改它们拆分和组合的方式。</p><p>ReactiveCocoa的主要目标是使代码更简洁、更易于理解。就个人而言，我发现，如果应用程序的逻辑表示为清晰的管道，使用流畅的语法，则更容易理解应用程序的作用。</p><p>在本教程系列的<a href="https://www.raywenderlich.com/?p=62796" target="_blank" rel="noopener">第二部分中</a>，你将了解更高级的主题，如错误处理以及如何管理在不同线程上执行的代码。</p><h3 id="Part-03-原文"><a href="#Part-03-原文" class="headerlink" title="Part-03 原文"></a>Part-03 原文</h3><p><a href="https://www.raywenderlich.com/2493-reactivecocoa-tutorial-the-definitive-introduction-part-1-2" target="_blank" rel="noopener">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>]]></content>
    
    <summary type="html">
    
      ReactiveCocoa是函数响应式编程框架，为程序中各种类型的事件提供了标准的接口来处理，使代码更加清晰。网上关于ReactiveCocoa资料不少，但是很多都含糊不清，对刚学习的人来说不是非常的实用。本片文章是笔者看到的一篇比较优秀的入门文章，原版是英文且需翻墙访问，所以做了翻译，希望对有刚接触ReactiveCocoa的人有些许帮助
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="翻译" scheme="www.iamlay.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报05#ipa包“瘦身”| 2020-04-26</title>
    <link href="www.iamlay.com/2020/04/26/week17/"/>
    <id>www.iamlay.com/2020/04/26/week17/</id>
    <published>2020-04-26T03:52:04.000Z</published>
    <updated>2020-04-25T07:42:10.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote><p>随着App版本的不断迭代，安装包会越来越大。安装包的大小是非常影响用户体验的。在推广App的时候，如果安装包很大，需要花费很多的时间来下载，会劝退很多用户。所以，我们应当使安装包尽量小。</p></blockquote><h3 id="Part01-瘦身方向"><a href="#Part01-瘦身方向" class="headerlink" title="Part01 - 瘦身方向"></a>Part01 - 瘦身方向</h3><h4 id="安装包组成"><a href="#安装包组成" class="headerlink" title="安装包组成"></a>安装包组成</h4><p>通过将导出的ipa包，用<code>归档工具</code>解压，在解压出的<code>payload</code>文件夹中得到App文件,查看App包含的内容，我们可以发现该文件主要包含以下内容：</p><ol><li>Exectutable-可执行文件</li><li>Resources:资源文件<ul><li>图片资源（Assets.car/bundle/png/jpg）</li><li>音/视频资源（mp/mp4）</li><li>静态网页资源：html/css/js</li><li>其他：文本/字体/证书等</li></ul></li><li>Framework:<ul><li>SwiftSupport: libSwiftxxx 等一系列 Swift 库</li><li>其他依赖库：Embeded Framework</li></ul></li><li>Plugins: Application Extensions<ul><li>appex：其组成大致与 ipa 包组成一致</li></ul></li></ol><h4 id="安装包优化分析"><a href="#安装包优化分析" class="headerlink" title="安装包优化分析"></a>安装包优化分析</h4><p> 在安装包中，可执行文件、图片资源和动态库占比较大，所以我们优化的重点就是这三个方向。</p><p> <img src="week1701.png" alt=""></p><h3 id="Part02-瘦身实施"><a href="#Part02-瘦身实施" class="headerlink" title="Part02 - 瘦身实施"></a>Part02 - 瘦身实施</h3><h4 id="图片资源优化"><a href="#图片资源优化" class="headerlink" title="图片资源优化"></a>图片资源优化</h4><p>对大部分的App来讲，占比最大资源文件应该就是图片资源，所以资源文件优化的重点就是图片资源的优化。图片资源的优化可以从下面几个方向来进行。</p><h5 id="1⃣️️将部分图片资源放到服务器上"><a href="#1⃣️️将部分图片资源放到服务器上" class="headerlink" title="1⃣️️将部分图片资源放到服务器上"></a>1⃣️️将部分图片资源放到服务器上</h5><p>将所有的图片资源都打到安装包中其实是不必要的，反而会造成安装包极速的增大，资源应该是按需加载的。除了一些常用的图片资源和一些如果放在线上非常影响用户体验的图片，其他的图片都应该放在资源服务器上，做好相应的图片缓存策略。</p><h5 id="2⃣️清理没用的图片资源"><a href="#2⃣️清理没用的图片资源" class="headerlink" title="2⃣️清理没用的图片资源"></a>2⃣️清理没用的图片资源</h5><p>随着版本的迭代，之前导入的一些图片资源已经不再使用，要做到及时的清理没用的图片资源。<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources </a>是一款非常不错的无用图片查找工具，<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources </a>的思路是，先获取图片文件(imageset, jpg, png, gif)集合A，然后搜索代码文件中所有字符串名称得到B，然后从A集合中排除集合B就得到未使用的图片资源。</p><h5 id="3⃣️图片资源压缩"><a href="#3⃣️图片资源压缩" class="headerlink" title="3⃣️图片资源压缩"></a>3⃣️图片资源压缩</h5><p>可以使用<a href="https://github.com/ImageOptim/ImageOptim" target="_blank" rel="noopener">ImageOptim</a>，通过优化压缩参数，移除无用的文件元数据和不必要的颜色配置来实现图片的无损压缩。我们UI切图使用的是蓝湖，蓝湖也支持图片压缩，如果没有使用过的同学可以尝试。</p><h5 id="4⃣️iconfont"><a href="#4⃣️iconfont" class="headerlink" title="4⃣️iconfont"></a>4⃣️iconfont</h5><p>即使经过了图片转下载，无用图片删除，但是工程中的图片数量还是极为可观，其中各种各样的icon图标占了不少的数量。为了进一步减少图片数量，可以使用<code>iconfont</code>方案， <code>iconfont</code>优点：</p><ul><li>矢量，缩放不失真</li><li>可以设置颜色</li><li>接入成本低，不需要引入额外的类库</li></ul><p><code>iconfont</code>可以解决因为icon大小，颜色不同而重新切图的窘境。<code>iconfont</code>是一个能减少图片数量的好方案。</p><h4 id="可执行文件-Mach-O-优化"><a href="#可执行文件-Mach-O-优化" class="headerlink" title="可执行文件(Mach-O)优化"></a>可执行文件(Mach-O)优化</h4><h5 id="1⃣️LinkMap文件"><a href="#1⃣️LinkMap文件" class="headerlink" title="1⃣️LinkMap文件"></a>1⃣️LinkMap文件</h5><p>但是通过<code>MachOView</code>，是不可以查看每个静态文件喝每个.o文件的大小，所以我们需要想办法量化文件的大小,我们可以通过分析<code>LinkMap</code>文件做到。</p><p><code>LinkMap</code>文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（<strong>TEXT）和数据段（</strong>DATA）的分布情况，可以根据这些信息进行针对性的优化。</p><ul><li><p>LinkMap文件获取：</p><ol><li>设置<code>Project-&gt;Build Settings-&gt;Write Link Map File</code>为<code>YES</code></li><li>设置<code>Project-&gt;Build Settings-&gt;Path to Link Map File</code>为LinkMap文件的输出路径</li></ol></li><li><p>LinkMap文件分析：</p><p>可以使用<a href="https://github.com/huanxsd/LinkMap" target="_blank" rel="noopener">LinkMap - LinkMap.txt 文件解析工具</a>分析每个类或者静态库的大小。通过查看LinkMap文件，各个静态库和文件的大小一目了然。</p><p><img src="week1702.png" alt="Alt text"></p><p>1、 在选用三方库的时候，尽量使用占用内存比较小的三方库，及时的移除不再使用的三方库。<br>2、分析占用内存比较大的类，删除类中没用的代码，减少冗余，保证用最简代码实现相应的功能，提升代码的复用性。</p></li></ul><p><code>LinkMap</code>可以在宏观上获取需要优化的部分，但是微观上，哪些是无用的类和方法，需要我们在    <code>Mach-O</code>层面进行分析，可以使用<a href="https://github.com/fangshufeng/MachOView" target="_blank" rel="noopener">MachOView </a>对<code>Mach-O</code>文件进行分析。可以通过阅读<a href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/" target="_blank" rel="noopener">这篇文章</a>探秘<code>Mach-O</code>。 下面这张图是<code>MachOView</code>查看<code>Mach-O</code>文件的截图：</p><p><img src="week1703.png" alt="Alt text"></p><p>大家可以阅读<a href="https://juejin.im/post/5d5d1a92e51d45620923886a" target="_blank" rel="noopener">:删除无用的类</a>进行实践</p><h5 id="2⃣️尽量不要使用OC和Swift混编"><a href="#2⃣️尽量不要使用OC和Swift混编" class="headerlink" title="2⃣️尽量不要使用OC和Swift混编"></a>2⃣️尽量不要使用OC和Swift混编</h5><p>OC和Swift混编的时候，因为需要一些静态库的支持，会造成安装包急剧增大。所以，尽量选择一种语言开发，不要采用混编的方式。<br><img src="week1704.png" alt="Alt text"></p><h5 id="3⃣️代码瘦身"><a href="#3⃣️代码瘦身" class="headerlink" title="3⃣️代码瘦身"></a>3⃣️代码瘦身</h5><p>可以使用<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a>进行代码的静态检查。<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a> 提供了非常强大的代码静态检查工具，使用<code>Inspect Code</code>，可以找到很多代码优化的地方:主要包括删除不用的类，不用的函数，重复的代码等。<br><img src="week1705.png" alt="Alt text"></p><h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>Xcode 支持编译器层面的一些优化优化选项，可以让我们介于更快的编译速度、更小的二进制大小和更快的执行速度之间自由选择想要进行的优化粒度。</p><h5 id="1⃣️BitCode"><a href="#1⃣️BitCode" class="headerlink" title="1⃣️BitCode"></a>1⃣️BitCode</h5><p>可以在<code>Xcode Target -&gt; Build Settings -&gt; Enable Bitcode</code> 中打开 bitcode 选项</p><p>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上。</p><p>在打包时，如果一些三方的依赖库没有开启 bitcode，或者开启了但是没有在最终引用的链接库中带有 bitcode，那么整个工程就无法用 bitcode 来编译了。</p><h3 id="Part03-参考"><a href="#Part03-参考" class="headerlink" title="Part03- 参考"></a>Part03- 参考</h3><p><a href="https://juejin.im/post/5cbb3f9151882529e5627ece" target="_blank" rel="noopener">App瘦身小记</a><br><a href="http://www.cocoachina.com/articles/859032" target="_blank" rel="noopener">京东商城iOS App瘦身实践</a><br><a href="https://www.jianshu.com/p/c94dedef90b7" target="_blank" rel="noopener">APP安装包瘦身实践</a><br><a href="https://zhuanlan.zhihu.com/p/86317689" target="_blank" rel="noopener">iOS开发：Archive、ipa 和 App 包瘦身</a><br><a href="https://juejin.im/post/5e969d816fb9a03c60188229?utm_source=gold_browser_extension" target="_blank" rel="noopener">APP体积优化</a></p>]]></content>
    
    <summary type="html">
    
      本文是笔者在对公司的App进行瘦身瘦身时候的一些实践，主要从资源文件、代码瘦身、编译三个方向上进行，希望对有需求的人有所帮助。
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报04#Sign in with Apple 设计原则| 2020-04-19</title>
    <link href="www.iamlay.com/2020/04/19/week16/"/>
    <id>www.iamlay.com/2020/04/19/week16/</id>
    <published>2020-04-19T12:45:27.000Z</published>
    <updated>2020-04-19T12:38:23.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用Apple提供的Button"><a href="#使用Apple提供的Button" class="headerlink" title="使用Apple提供的Button"></a>使用Apple提供的Button</h3><p>当你使用系统提供的API创建Button的时候，能够获得以下优势：</p><ol><li>能够确保Button使用了苹果认可的title、font、color 和 style</li><li>能够确保在你修改Button的Style的时候，Button的Content有一个理想的位置</li><li>Button的title能够跟自动转换成设备手机选择的Language</li><li>支持配置圆角以满足你自己UI的风格（iOS、MacOS、Web）</li></ol><p>对开发者而言，可以看这些使用引导<a href="https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidbutton" target="_blank" rel="noopener">ASAuthorizationAppleIDButton</a> (iOS, macOS, and tvOS), <a href="https://developer.apple.com/documentation/watchkit/wkinterfaceauthorizationappleidbutton" target="_blank" rel="noopener">WKInterfaceAuthorizationAppleIDButton</a> (watchOS), and <a href="https://developer.apple.com/documentation/signinwithapplejs/displaying_and_configuring_sign_in_with_apple_buttons" target="_blank" rel="noopener">Displaying and Configuring Sign in with Apple Buttons</a> (web).</p><p>系统提供的Button 的Title有几种文案。根据你使用的平台，选择最合适的文案。</p><p>下面几种Button Title都可以在iOS、macOS、和tvOS中使用，但是只有Sign in with Apple 和 Continue with Apple 可以在Web中使用</p><p><img src="SignWithApple01.png" alt=""></p><p>对watchOS，系统提供的Title只有一个 <code> Sign in</code></p><p><img src="SignWithApple02.png" alt=""></p><p>依赖于不同的平台，系统提供了三种外观的Button，分别是白色（white）、有边框的白色（white with an outline）、黑色（black）。根据放置Button的背景颜色，选择最合Button样式。</p><h4 id="白色"><a href="#白色" class="headerlink" title="白色"></a>白色</h4><p>白色可以在任何平台使用（包括Web）,当背景是黑色或者其他深色时，选择白色会有更好的表现力</p><p><img src="SignWithApple03.png" alt=""></p><h4 id="白色带边框"><a href="#白色带边框" class="headerlink" title="白色带边框"></a>白色带边框</h4><p>白色带边框的Button可以在iOS、macOS、和Web上面使用，当背景是白色或浅色背景的时候，背景和Button的填充色对比是不够强烈的，通过添加边框可以提升表现力。当背景是深色的时候，不要使用这种风格，深色会使得这种风格变得混乱。</p><p><img src="SignWithApple04.png" alt=""></p><h4 id="黑色"><a href="#黑色" class="headerlink" title="黑色"></a>黑色</h4><p>黑色可以在任何平台使用（包括Web）,当背景是白色或者其他浅色时，选择黑色会有更好的表现力</p><p><img src="SignWithApple05.png" alt=""><br>不像其他平台上的黑色风格的Button，在watchOS上，黑色风格的Button是非全黑的填充色，和watchOS全黑色的背景做对比。watchOS上Button用系统定义的黑灰样式。</p><p><img src="SignWithApple06.png" alt=""></p><h4 id="Button的大小和圆角"><a href="#Button的大小和圆角" class="headerlink" title="Button的大小和圆角"></a>Button的大小和圆角</h4><p>调整Button的圆角以匹配App中其他登录Button的风格。默认情况下， Sign in with Apple的Button是没有圆角的。在iOS、macOS、Web中，可以通过修改圆角的半径，生成直角或者药丸状的Button。</p><p><img src="SignWithApple07.png" alt=""></p><p><strong>iOS、macOS 、Web中使用的Button，必须有一个最小的的Size和外边距</strong>。值得注意的是，依赖于文本的本地化，Button的长度或许很长。下面的值可以做作为设计原则：</p><table><thead><tr><th>Minimum width</th><th>Minimum height</th><th>Minimum margin</th></tr></thead><tbody><tr><td>140pt (140px @1x, 280px @2x)</td><td>30pt (30px @1x, 60px @2x)</td><td>1/10 of the button’s height</td></tr></tbody></table><h3 id="创建一个自定义的-Sign-in-with-Apple-Button"><a href="#创建一个自定义的-Sign-in-with-Apple-Button" class="headerlink" title="创建一个自定义的 Sign in with Apple Button"></a>创建一个自定义的 Sign in with Apple Button</h3><p>如果你有需要的话，可以在iOS、macOS、或者Web平台上自己创建一个自定义的Sign in with Apple Button 。比如：或许你支持多种登录方式，你想展示<code>Left-Aligned Logo</code> Button或者<code>Logo-Only</code> Button。</p><p><img src="SignWithApple08.png" alt=""></p><p><a href="https://developer.apple.com/design/resources/" target="_blank" rel="noopener">Apple Design Resources </a>提供了一些美术资源，你可以使用这些美术资源自定义Sign in with Apple Button。这些资源包括PNG、SVG和PDF三种格式，并且包含黑白两种表现形式。下面是<code>Logo-Only</code> Button的两个例子，每个Logo都添加了富有表现力的背景色</p><p><img src="SignWithApple09.png" alt=""></p><p>所有下载的Logo文件都包含一个内边距，这样在Button中放置logo更加容易</p><ol><li><code>Left-Aligned Logo</code>文件包含一个垂直方向上的内边距，能够确保Logo在Button中有一个合适的占比，水平方向上的内边距也为Logo和Button的左边距、Logo和Button的title之间提供了一个最小边距。</li><li><code>Logo-Only</code>文件包含一个水平和垂直方向上的内边距，确保了Logo在Button中有一个合适的占比</li></ol><p>使用<code>Logo-Only</code>文件的时候,需要遵循以下原则：</p><ol><li>不要仅仅使用 Apple Logo  自己作为一个Button</li><li>Logo文件的高度要和Button的高度保持一致</li><li>不要剪切Logo文件</li><li>不要添加垂直方向的内边距</li><li>Logo文件不要使用自己定义的颜色</li></ol><h4 id="Left-Aligned-Logo-Buttons"><a href="#Left-Aligned-Logo-Buttons" class="headerlink" title="Left-Aligned Logo Buttons"></a>Left-Aligned Logo Buttons</h4><p>根据你的Button的高度选择合适的Logo文件。因为PDF和SVG是矢量图，你可以在任何高度的Button中使用这两种文件。而PNG文件只能在高度为44的Button中使用，这是iOS中Button的默认高度。</p><p>Title要使用系统字体(Sign in with Apple、Sign up with Apple、 Continue with Apple)：为了统一，你自定义的Button的高度和Title应该和系统使用的<code>保持一样的比例</code>。Title应该占据Button高度的43%，换言之Button的高度应该是Title Font大小的233%。下面两个例子展示了这种比例：</p><p><img src="SignWithApple10.png" alt=""></p><p><strong>保持Title的大写的风格</strong>所有Title的首字母都是大写的（Sign or Continue — and Apple），其他的字母是小写的。切不可改变这种风格。</p><p><strong>保持Title和Logo和Button在垂直方向上对齐</strong>：为了做到这一点，Title和Button的中部在垂直方向上对齐，然后添加Logo图片，确保图片的高度和Button的高度一致。因为Logo图片本身具有顶部和底部的内边距，垂直对齐Button的Title能够确保Title和Logo在Button中占据合适的比例。</p><p><strong>如果有需要可以嵌入Logo</strong> 如果你需要将苹果的Logo和其他的认证的logo对齐，可以将Logo左侧嵌入</p><p><strong>Title和Button的右边有一个最小内边距</strong>  边距至少占据Button宽度的8%</p><p><strong>Button有一个最小的size，且Button有一个内边距</strong> ：因为文本的本地化，Button的长度可能很长。参考下面的设计原则：</p><table><thead><tr><th>Minimum width</th><th>Minimum height</th><th>Minimum margin</th></tr></thead><tbody><tr><td>140pt (140px @1x, 280px @2x)</td><td>30pt (30px @1x, 60px @2x)</td><td>1/10 of the button’s height</td></tr></tbody></table><h4 id="Logo-Only-Buttons"><a href="#Logo-Only-Buttons" class="headerlink" title="Logo-Only Buttons"></a>Logo-Only Buttons</h4><p><strong>根据你的Button的高度选择合适的Logo文件</strong>。因为PDF和SVG是矢量图，你可以在任何高度的Button中使用这两种文件。而PNG文件只能在高度为44的Button中使用。</p><p><strong>不要为Logo-Only图片添加水平方向上的内边距</strong>   Logo-only的Button是1:1的比例，下载的Logo-Only文件已经有了合适的内边距</p><p><strong>用mask(遮罩)改变Logo-only图片的形状</strong>  例如 Sign in with Apple使用用圆形或者椭圆矩形的Button。不要为了减小内边距剪切Apple提供的美术资源，也不要只使用Apple Logo。</p><p><img src="SignWithApple11.png" alt=""></p><p><strong>Button有一个最小的内边距</strong>  内边距至少为Button高度的1/10</p>]]></content>
    
    <summary type="html">
    
      根据最新的苹果审核规范，2020年4月之后，凡是可以使用第三方软件登录的App，必须接入Sign in with Apple。最新一段时间，主流的App基本都已经接入此功能。在UI设计阶段，Sign in with Apple必须严格遵守苹果的设计原则，否则审核被拒。本篇周报的主要内容是对Sign in with Apple 设计规范的翻译，希望可以帮助到有需要的人。
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>如何在OC中进行源码分析</title>
    <link href="www.iamlay.com/2020/04/13/OCCodeAnalysis/"/>
    <id>www.iamlay.com/2020/04/13/OCCodeAnalysis/</id>
    <published>2020-04-13T01:55:54.000Z</published>
    <updated>2020-04-13T12:00:27.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Part01-获取objc-runtime的源码"><a href="#Part01-获取objc-runtime的源码" class="headerlink" title="Part01-获取objc-runtime的源码"></a>Part01-获取objc-runtime的源码</h3><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc-runtime的源码地址</a></p><p>注意：⚠️⚠️⚠️，objc-runtime的源码的新旧程度并不是按照时间进行排序，而是按照包的大小进行的排序，一般可以理解为包最大的即为最新的源码</p><p>但是官网的runtime代码是无法直接运行的，如果想直接运行可以下载<a href="https://github.com/RetVal" target="_blank" rel="noopener">RetVal</a>处理过的<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">源代码</a></p><h3 id="Part02-将OC代码编译成C-代码"><a href="#Part02-将OC代码编译成C-代码" class="headerlink" title="Part02-将OC代码编译成C++代码"></a>Part02-将OC代码编译成C++代码</h3><ol><li>找到需要编译成C++代码的OC文件，这里我们拿<code>main.m</code>来举例</li></ol><p><img src="OCCodeAnalysis01.png" alt="image"></p><ol start="2"><li>进入到main.m所在的文件夹，执行：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-fobjc-arc表示编译需要支持ARC特性。</span><br><span class="line">&#x2F;&#x2F;-framework Foundation表示引用Foundation框架，这个框架中定义了很多基本的类，例如字符串、数组、字典等等。</span><br><span class="line">&#x2F;&#x2F;后面的 mian.m 就是待编译的源代码文件名。</span><br><span class="line">&#x2F;&#x2F;-o main 表示输出的可执行文件的文件名是 main。</span><br><span class="line"></span><br><span class="line">clang -fobjc-arc -framework Foundation main.m -o main</span><br></pre></td></tr></table></figure><p>得到执行文件，双击可以看到执行结果</p><p><img src="OCCodeAnalysis02.png" alt="image"></p><ol start="3"><li>生成main.m的cpp文件main.cpp，main.cpp就是编译器对main.m进行转换的结果，执行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>如果在执行<code>执行 clang -rewrite-objc main.m</code>是报错的，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.m:9:9: fatal error: &#39;UIKit&#x2F;UIKit.h&#39; file not found</span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">        ^~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;xxxxx.m</span><br></pre></td></tr></table></figure><h3 id="Part03-根据C-代码，结合objc-runtime源码进行分析"><a href="#Part03-根据C-代码，结合objc-runtime源码进行分析" class="headerlink" title="Part03-根据C++代码，结合objc-runtime源码进行分析"></a>Part03-根据C++代码，结合objc-runtime源码进行分析</h3><p>执行完上面的指令，生成了相关文件的C++ 代码，C++代码用到了objc-runtime源码，所以要进入到objc-runtime源码，探索本质。例如下面是main.m编译成main.cpp文件时，-(void)eat生成的C ++代码。标出来的代码都是objc-runtime中的源代码</p><p><img src="OCCodeAnalysis03.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      本文主要讲述的是如何将OC代码编译成C++代码，以及拿到C++的代码之后，根据C++的代码结合objc-runtime的源码去分析代码
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报03#AOP| 2020-04-12</title>
    <link href="www.iamlay.com/2020/04/12/week15/"/>
    <id>www.iamlay.com/2020/04/12/week15/</id>
    <published>2020-04-12T11:55:37.000Z</published>
    <updated>2020-04-12T12:24:26.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Part01-什么是AOP"><a href="#Part01-什么是AOP" class="headerlink" title="Part01-什么是AOP?"></a>Part01-什么是AOP?</h3><blockquote><p>面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。</p></blockquote><h3 id="Part02-AOP一个使用场景：埋点"><a href="#Part02-AOP一个使用场景：埋点" class="headerlink" title="Part02-AOP一个使用场景：埋点"></a>Part02-AOP一个使用场景：埋点</h3><p>互联网进入到下半场，用户也由增量进入到存量时代。通过统计用户操作行为了解用户的偏好，结合大数据分析，可以方便公司更加合理的作出决策更好的吸引客户、留住客户。对任何一个主流的APP来讲，都会存在大量的埋点来统计用户的行为。埋点功能不属于业务逻辑，埋点代码和业务代码混合在一块会严重污染业务代码，且埋点的代码会分散到整个工程。面向切面编程是解决这种问题一个很好的方案，其原理就是在不更改正常业务处理流程的前提下，动态生成一个代理类，从而实现对目标对象嵌入附加的操作。</p><h3 id="Part03-iOS实现AOP的原理"><a href="#Part03-iOS实现AOP的原理" class="headerlink" title="Part03-iOS实现AOP的原理"></a>Part03-iOS实现AOP的原理</h3><p>利用OC的动态性，通过wizzling method 改变目标函数的 selector 所指向的实现，然后在新的实现中实现附加的操作，完成之后再回到原来的处理逻辑。OC是一门动态语言，在OC中执行一个方法的时候实际上是在发送一条消息给接受对象<code>[receiver message]</code>。完整的过程是根据<code>message</code>生成一个选择子<code>selector</code>，然后根据<code>selector</code>找到指向函数的的具体的实现的指针<code>IMP</code>，然后找到真正的函数执行逻辑。OC的这种处理流程为我们动态修改函数的实现提供了可能，在运行时，只要我们改变selector和IMP的对应关系，我们就可以在执行<code>[receiver message]</code>时进入到新的函数实现。</p><h3 id="Part04-iOS实现AOP的一个成熟的开源框架：Aspects"><a href="#Part04-iOS实现AOP的一个成熟的开源框架：Aspects" class="headerlink" title="Part04- iOS实现AOP的一个成熟的开源框架：Aspects"></a>Part04- iOS实现AOP的一个成熟的开源框架：Aspects</h3><h4 id="Aspects的实现思路"><a href="#Aspects的实现思路" class="headerlink" title="Aspects的实现思路"></a>Aspects的实现思路</h4><p>Aspects是利用 oc 自己的消息转发机制进行转发，在解释这个过程之前，我们先看一下消息是怎么找到对应的IMP的<img src="week1501.jpg" alt="image"></p><p>从上面我们可以发现，在发消息的时候，如果 <code>selector</code> 有对应的 <code>IMP</code> ,则直接执行，如果没有，oc 给我们提供了几个可供补救的机会，依次有 <code>resolveInstanceMethod</code> 、<code>forwardingTargetForSelector</code>、<code>forwardInvocation</code>。Aspects 之所以选择在 <code>forwardInvocation</code>这里处理是因为，这几个阶段特性都不太一样：<code>resolvedInstanceMethod</code>适合给类/对象动态添加一个相应的实现，<code>forwardingTargetForSelector</code>适合将消息转发给其他对象处理,相对而言，<code>forwardInvocation</code> 是里面最灵活，最能符合需求的。因此 Aspects 的方案就是，对于待<code>hook</code> 的 <code>selector</code>，将其指向 <code>objc_msgForward / _objc_msgForward_stret</code>,同时生成一个新的 <code>aliasSelector</code> 指向原来的 <code>IMP</code>，并且 <code>hook</code> 住 <code>forwardInvocation</code> 函数，使他指向自己的实现。按照上面的思路，当被 <code>hook</code>的 <code>selector</code> 被执行的时候，首先根据 <code>selector</code>找到了<code>objc_msgForward / _objc_msgForward_stret</code>,而这个会触发消息转发，从而进入 <code>forwardInvocation</code>。同时由于 <code>forwardInvocation</code> 的指向也被修改了，因此会转入新的<code>forwardInvocation</code> 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的<code>IMP</code>。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>从头文件中可以看到使用aspects有两种使用方式：(1)类方法 ；(2)实例方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Adds a block of code before&#x2F;instead&#x2F;after the current &#96;selector&#96; for a specific instance.</span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br></pre></td></tr></table></figure><p>两者的主要原理基本差不多，这里不做一一介绍，只是以实例方法为例进行说明。在介绍之前，先介绍里面几个重要的数据结构：</p><h5 id="AspectOptions"><a href="#AspectOptions" class="headerlink" title="AspectOptions"></a>AspectOptions</h5><p> block 执行的时机，也就是额外操作的执行时机，它可以在原始函数执行之前，也可以是执行之后，甚至可以完全替换掉原来的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class="line">    AspectPositionAfter   &#x3D; 0,            &#x2F;&#x2F;&#x2F; Called after the original implementation (default)</span><br><span class="line">    AspectPositionInstead &#x3D; 1,            &#x2F;&#x2F;&#x2F; Will replace the original implementation.</span><br><span class="line">    AspectPositionBefore  &#x3D; 2,            &#x2F;&#x2F;&#x2F; Called before the original implementation.</span><br><span class="line">    AspectOptionAutomaticRemoval &#x3D; 1 &lt;&lt; 3 &#x2F;&#x2F;&#x2F; Will remove the hook after the first execution.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h5><p>一个对象或者类的所有的 Aspects 整体情况:一个对象和类可能有多个Aspect，每个Aspect的执行的时机都是不一样的，AspectsContainer存储了这个类或对象全部的Aspect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks all aspects for an object&#x2F;class.</span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h5><p>一个 Aspect 的具体内容，这里主要包含了单个的 aspect 的具体信息，包括执行时机，要执行 block 所需要用到的具体信息：包括方法签名、参数等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h5><p>一个 Aspect 执行环境，主要是 NSInvocation 信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspctInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h4><p>有了上面的了解，我们就能更好的分析整个 apsects 的执行流程。添加一个 aspect 的关键流程如下图所示：</p><p><img src="week1502.jpg" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tatic id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __block AspectIdentifier *identifier &#x3D; nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;&#x2F;&#x2F;1判断能否hook</span><br><span class="line">            ...&#x2F;&#x2F;2 记录数据结构</span><br><span class="line">            aspect_prepareClassAndHookSelector(self, selector, error);&#x2F;&#x2F;3 swizzling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断能否被-hook"><a href="#判断能否被-hook" class="headerlink" title="判断能否被 hook"></a>判断能否被 hook</h5><p>对于对象实例而言，这里主要是根据黑名单，比如 retain forwardInvocation 等这些方法在外部是不能被 hook ,(对于类对象还要确保同一个类继承关系层级中，只能被 hook 一次，因此这里需要判断子类，父类有没有被 hook，之所以做这样的实现，主要是为了避免出现死循环的出现，这里有相关的讨论)。如果能够 hook，则继续下面的步骤。</p><h5 id="swizzling-method"><a href="#swizzling-method" class="headerlink" title="swizzling method"></a>swizzling method</h5><p>这是真正的核心逻辑，<code>swizzling method</code>主要有两部分，一个是对对象的 <code>forwardInvocation</code>进行 <code>swizzling</code>,另一个是对传入的 <code>selector</code> 进行 <code>swizzling</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">    Class klass &#x3D; aspect_hookClass(self, error); &#x2F;&#x2F;1  swizzling forwardInvocation</span><br><span class="line">    Method targetMethod &#x3D; class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP &#x3D; method_getImplementation(targetMethod);</span><br><span class="line">    if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;&#x2F;&#x2F;2  swizzling method</span><br><span class="line">       ...&#x2F;&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="swizzling-forwardInvocation"><a href="#swizzling-forwardInvocation" class="headerlink" title="swizzling forwardInvocation:"></a>swizzling forwardInvocation:</h6><p><code>aspect_hookClass</code> 函数主要 <code>swizzling</code>类/对象的 <code>forwardInvocation</code> 函数，<code>aspects</code>的真正的处理逻辑都是在 <code>forwradInvocation</code> 函数里面进行的。对于对象实例而言，源代码中并没有直接 swizzling 对象的 <code>forwardInvocation</code>方法，而是动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的<code>forwardInvocation</code> 方法(这里具体方法就是调用了 <code>object_setClass(self, subclass)</code>,将当前对象 <code>isa</code>指针指向了<code>subclass</code> ,同时修改了<code>subclass</code>以及其 <code>subclass metaclass</code> 的 <code>class</code> 方法,使他返回当前对象的 <code>class</code>。它的原理有点类似 <code>kvo</code> 的实现，它想要实现的效果就是，将当前对象变成一个 <code>subclass</code> 的实例，同时对于外部使用者而言，又能把它继续当成原对象在使用，而且所有的 <code>swizzling</code>操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，也就是，当你在<code>remove aspects</code>的时候，如果发现当前对象的 <code>aspect</code> 都被移除了，那么，你可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 <code>swizzling</code> ,同时也不会影响到其他该类的不同对象)。对于每一个对象而言，这样的动态对象只会生成一次，这里<code>aspect_swizzlingForwardInvocation</code>将使得 <code>forwardInvocation</code> 方法指向 <code>aspects</code>自己的实现逻辑 ,具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;</span><br><span class="line">     ...</span><br><span class="line">     &#x2F;&#x2F;生成动态子类，并swizzling forwardInvocation方法</span><br><span class="line">     subclass &#x3D; objc_allocateClassPair(baseClass, subclassName, 0); </span><br><span class="line">     aspect_swizzleForwardInvocation(subclass);&#x2F;&#x2F;swizzling forwardinvation方法</span><br><span class="line">     objc_registerClassPair(subclass);</span><br><span class="line">      ...</span><br><span class="line">     object_setClass(self, subclass);&#x2F;&#x2F;将当前self设置为子类，这里其实只是更改了self的isa指针而已</span><br><span class="line">     return subclass;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">     ...</span><br><span class="line">    IMP originalImplementation &#x3D; class_replaceMethod(klass, @selector(forwardInvocation:),     (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">         class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName),        originalImplementation, &quot;v@:@&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子类本身并没有实现 <code>forwardInvocation</code> ，隐藏返回的 <code>originalImplementation</code> 将为空值，所以也不会生成 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName)</code>。</p><h6 id="swizzling-selector"><a href="#swizzling-selector" class="headerlink" title="swizzling selector"></a>swizzling selector</h6><p>当 <code>forwradInvocation</code> 被<code>hook</code>之后，接下来，将对传入的<code>selector</code>进行<code>hook</code> ，这里的做法是，将<code>selector</code> 指向了转发 <code>IMP</code>，同时生成一个 <code>aliasSelector</code> ，指向了原来的<code>IMP</code>,同时为防止重复<code>hook</code> ,做了一个判断，如果发现 <code>selector</code> 已经指向了转发<code>IMP</code> ,那就就不需要进行交换了，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tatic void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">     ...</span><br><span class="line">     Method targetMethod &#x3D; class_getInstanceMethod(klass, selector);</span><br><span class="line">     IMP targetMethodIMP &#x3D; method_getImplementation(targetMethod);</span><br><span class="line">     if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">     ...</span><br><span class="line">     SEL aliasSelector &#x3D; aspect_aliasForSelector(selector);&#x2F;&#x2F;generator aliasSelector</span><br><span class="line">     if (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">          __unused BOOL addedAlias &#x3D; class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); </span><br><span class="line">     &#125;</span><br><span class="line">     class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);&#x2F;&#x2F; point to   _objc_msgForward</span><br><span class="line">   ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="handle-ForwardInvocation"><a href="#handle-ForwardInvocation" class="headerlink" title="handle ForwardInvocation"></a>handle ForwardInvocation</h6><p>基于上面的代码分析知道，转发最终的逻辑代码最终转入 <code>__ASPECTS_ARE_BEING_CALLED__</code> 函数的处理中。这里，需要处理的部分包括额外处理代码（如打点代码）以及最终重新转会原来的<code>selector</code>所指向的函数，其实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123;</span><br><span class="line">...</span><br><span class="line">     &#x2F;&#x2F; Before hooks.  原来逻辑之前执行</span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line">    &#x2F;&#x2F; Instead hooks.</span><br><span class="line">    BOOL respondsToAlias &#x3D; YES;</span><br><span class="line">    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;&#x2F;&#x2F;是否需要替换掉原来的路基</span><br><span class="line">         aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">         aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Class klass &#x3D; object_getClass(invocation.target);</span><br><span class="line">        do &#123;</span><br><span class="line">              if ((respondsToAlias &#x3D; [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                    [invocation invoke];&#x2F;&#x2F;根据aliasSelector找到原来的逻辑并执行</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;while (!respondsToAlias &amp;&amp; (klass &#x3D; class_getSuperclass(klass)));</span><br><span class="line">     &#125;</span><br><span class="line">    &#x2F;&#x2F; After hooks.  原来逻辑之后执行</span><br><span class="line">     aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">     aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line">    &#x2F;&#x2F; If no hooks are installed, call original implementation (usually to throw an exception)</span><br><span class="line">     if (!respondsToAlias) &#123;&#x2F;&#x2F;找不到aliasSelector的IMP实现，没有找到原来的逻辑，进行消息转发</span><br><span class="line">          invocation.selector &#x3D; originalSelector;</span><br><span class="line">          SEL originalForwardInvocationSEL &#x3D; NSSelectorFromString(AspectsForwardInvocationSelectorName);</span><br><span class="line">          if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">               ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              [self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;                     </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次处理 <code>before/instead/after hook</code> 以及真正函数实现。如果没有找到原始的函数实现，还需要进行转发操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">面向切面编程之 Aspects 源码解析及应用</a></p>]]></content>
    
    <summary type="html">
    
      面向切面编程(AOP)是对面向对象编程(OOP)的一种补充.本篇周报介绍了下什么是AOP，以及AOP的应用场景。并对iOS中一个轻量级的AOP三方库ASpects源码进行了简单的分析。
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="转载" scheme="www.iamlay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报02#X86-汇编| 2020-04-05</title>
    <link href="www.iamlay.com/2020/04/02/week14/"/>
    <id>www.iamlay.com/2020/04/02/week14/</id>
    <published>2020-04-02T11:41:49.000Z</published>
    <updated>2020-04-03T05:12:32.723Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Part01-知识准备"><a href="#Part01-知识准备" class="headerlink" title="Part01 - 知识准备"></a>Part01 - 知识准备</h4><p>在介绍汇编之前，我们首先应该搞清楚什么是机器语言？什么是汇编语言？什么是高级语言？</p><p><strong>机器语言：</strong></p><blockquote><p>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合。</p></blockquote><p><strong>汇编语言：</strong></p><blockquote><p>汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。</p></blockquote><p><strong>高级语言:</strong></p><blockquote><p>高级编程语言是高度封装了的编程语言，与低级语言相对。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。比如：C、C++、Swift、Java…</p></blockquote><p>用一张图来解释这三种语言之间的关系：</p><p><img src="Assembly01.png" alt="image"></p><h4 id="Part02-编译器：LLVM"><a href="#Part02-编译器：LLVM" class="headerlink" title="Part02 - 编译器：LLVM"></a>Part02 - 编译器：LLVM</h4><p>汇编严重依赖硬件设备, <code>iOS</code>模拟器使用<code>AT&amp;T</code>格式汇编(因为 <code>Mac</code> 是基于 <code>Unix</code> 开发的), <code>iOS</code> 真机使用ARM汇编<br>。</p><p><code>Xcode</code>内置的编译器是<code>LLVM</code>，<code>LLVM</code> 是一个著名的编译器, 由大神 <code>Chris Lattner</code>开发, 可用于常规编译器, JIT编译器, 汇编器, 调试器, 静态分析工具等一系列跟编程语言相关的工作。</p><h5 id="LLVM-的编译架构分为三个阶段"><a href="#LLVM-的编译架构分为三个阶段" class="headerlink" title="LLVM 的编译架构分为三个阶段"></a>LLVM 的编译架构分为三个阶段</h5><ol><li>前端：进行语法分析, 语义分析, 生成中间代码。实际上在 Xcode 中写代码的时候会实时提示错误就是因为持续在调用 LLVM 的前端部分</li><li>公用优化器：将生成的中间文件进行优化, 去除冗余代码, 进行结构优化。</li><li>后端：将优化后的中间代码再次转换, 变为汇编语言, 再次进行优化. 最后将各个文件代码转换为二进制代码(机器语言)并链接以生成一个可执行文件。</li></ol><h5 id="LLVM-架构的优点"><a href="#LLVM-架构的优点" class="headerlink" title="LLVM 架构的优点"></a>LLVM 架构的优点</h5><ol><li>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</li><li>如果需要支持一种新的编程语言, 那么只需要实现一个新的前端(Swift 就是新增了一个针对于 Swift 的前端)</li><li>如果需要支持一种新的硬件设备, 那么只需要实现一个新的后端</li><li>优化阶段是一个通用的阶段, 它针对的是统一的LLVM IR, 不论是支持新的编程语言, 还是支持新的硬件设备, 都不需要对优化阶段做修改</li><li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族, Java, .NET, Python, Ruby, Scheme, Haskell, D等)</li></ol><p><img src="Assembly02.png" alt="image"></p><h4 id="Part03-汇编语言种类及选择："><a href="#Part03-汇编语言种类及选择：" class="headerlink" title="Part03 - 汇编语言种类及选择："></a>Part03 - 汇编语言种类及选择：</h4><h5 id="汇编语言种类"><a href="#汇编语言种类" class="headerlink" title="汇编语言种类"></a>汇编语言种类</h5><ol><li><code>AT&amp;T</code>格式(<code>UNIX</code>, <code>MAC</code>阵营):<code>8086</code>汇编(16bit 架构)<code>x64</code>汇编(64bit 架构)</li><li><code>Intel</code>格式(WIN阵营): <code>x86</code>汇编(32bit 架构)</li><li><code>ARM</code> 格式 (移动设备阵营): 只用在 <code>arm</code>处理器上</li></ol><h5 id="汇编语言选择"><a href="#汇编语言选择" class="headerlink" title="汇编语言选择"></a>汇编语言选择</h5><p>虽然不同的架构对应着不同的汇编语言，但是原理基本上是一样的，为了调试方便，我们将以X86-64架构来探究Swift中函数调用的本质。</p><h4 id="Part04-AT-amp-T汇编"><a href="#Part04-AT-amp-T汇编" class="headerlink" title="Part04 - AT&amp;T汇编"></a>Part04 - AT&amp;T汇编</h4><h5 id="寄存器和数据类型"><a href="#寄存器和数据类型" class="headerlink" title="寄存器和数据类型"></a>寄存器和数据类型</h5><p>X86-64有16个通用(几乎都是通用的)64位整数寄存器：</p><table><thead><tr><th>%rax</th><th>%rbx</th><th>%rcx</th><th>%rdx</th><th>%rsi</th><th>%rdi</th><th>%rbp</th><th>%rsp</th><th>%r8</th><th>%r9</th><th>%r10</th><th>%r11</th><th>%r12</th><th>%r13</th><th>%r14</th><th>%r15</th></tr></thead></table><p>因为早期处理器的不同寄存器的用途不同，并不是所有的指令都可以应用于每个寄存器。（现在基本上都是通用寄存器了）随着设计的发展，增加了新的指令和寻址模式，使各种寄存器几乎相等。除了几条特殊的指令，比如与字符串处理有关的指令，需要使用％rsi和％rdi，另外，还有两个寄存器保留用作堆栈指针（％rsp）和基址指针（％rbp）。最后的八个被编号的寄存器没有特别的限制。除此之外还有一个特殊的寄存器%rip(instruction pointer)，一般情况下你不需要关注这个寄存器,但是这个寄存器很重要，你需要知道他的功能，后面在说函数调用时会提及。</p><p>多年来X86架构已经从8位扩展到了32位，因此每个寄存器都有一些内部结构如下图：<br><img src="Assembly03.png" alt="image"></p><h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>什么是寻址模式？就是数据在内存寄和寄存器之间进行移动时，取得数据地址的不同表达方式。最常用的寻址的汇编指令是mov。x86-64使用的是复杂指令集(cisc)，因此mov有许多不同的变体，可以在不同单元之间移动不同类型的据。mov与大多数指令一样，具有单字母后缀，用于确定要移动的数据量。下表用于描述各种大小的数据值：</p><table><thead><tr><th>前缀</th><th>全称</th><th>Size</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>1byte(8 bits)</td></tr><tr><td>W</td><td>word</td><td>2byte(16 bits)</td></tr><tr><td>L</td><td>long</td><td>4byte(32 bits)</td></tr><tr><td>Q</td><td>quadword</td><td>8byte(64 bits)</td></tr></tbody></table><p><code>MOVB</code>移动一个字节，<code>MOVW</code>移动一个字，<code>MOVL</code>移动一个长整形，<code>MOVQ</code>移动一个四字。一般来说，<code>MOV</code>指令移动数据的大小必须与后缀匹配。虽然可以忽略后缀，汇编器将尝试根据参数选择合适的<code>MOV</code>指令。但是，不推荐这样做，因为它可能会造成预料之外的结果。</p><p>对于<code>AT&amp;T</code>语法使用<code>MOV</code>寻址时需要两个参数，第一个参数是<code>源地址</code>，第二个参数是<code>目标地址</code>。<code>原地址</code>的表达方式不一样那么寻址的方式也就不一样。比如，访问全局变量使用一个简单变量的名称比如<code>x</code>，我们称之为全局符号寻址。<code>printf</code>一个整数常量，由美元符号+数值表示(例如<code>$ 56</code>)，我们称之为直接寻址。访问寄存器的值直接使用寄存器的名字如  <code>%rbx</code>，我们称之为寄存器寻址。如果寄存器中存放的是一个地址，访问这个地址中的数据时需要在寄存器外面加上括号如<code>(%rbx)</code>，我们称之为间接寻址。如果寄存器中存放的是一个数组的地址，我们需要访问数组中的元素时可能需要操作这个地址进行偏移，如<code>8(％rcx）</code>是指<code>％rcx</code>中存放的的地址加<code>8</code>字节存储单元的值，我们称之为相对基址寻址（此模式对于操作堆栈，局部变量和函数参数非常重要）。在相对基址寻址上有各种复杂的变化，例如<code>-16（％rbx，％rcx，8</code>）是指地址<code>-16 +％rbx +％rcx * 8</code>处的值。此模式对于访问排列在数组中的特殊大小的元素非常有用。</p><p>以下是使用各种寻址模式将64位值加载到％rax的示例：</p><table><thead><tr><th>寻址模式</th><th>示例</th></tr></thead><tbody><tr><td>全局符号寻址(Global Symbol)</td><td>MOVQ x, %rax</td></tr><tr><td>直接寻址(Immediate)</td><td>MOVQ $56, %rax</td></tr><tr><td>寄存器寻址(Register)</td><td>MOVQ %rbx, %rax</td></tr><tr><td>间接寻址(Indirect)</td><td>MOVQ (%rsp), %rax</td></tr><tr><td>相对基址寻址(Base-Relative)</td><td>MOVQ -8(%rbp), %rax</td></tr><tr><td>相对基址偏移缩放寻址(Offset-Scaled-Base-Relative)</td><td>MOVQ -16(%rbx,%rcx,8), %rax</td></tr></tbody></table><p>通常，可以使用相同的寻址模式将数据存储到寄存器和内存。但是，并不是所有模式都支持。比如不能对<code>MOV</code>的两个参数都使用<code>base-relative mode</code>。像<code>MOVQ -8（％rbx</code>），<code>-8（％rbx</code>）这样是不行的。要准确查看支持哪些寻址模式组合，您必须阅读相关指令的手册。</p><h5 id="基础运算指令"><a href="#基础运算指令" class="headerlink" title="基础运算指令"></a>基础运算指令</h5><p>编译器需要四个基本的算术指令： <code>ADD</code>, <code>SUB</code>, <code>IMUL</code>, 和<code>IDIV</code>(加减乘除)。<code>add</code>和<code>sub</code>有两个操作数：一个来源值和一个被操作数。例如，这条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq %rbx, %rax</span><br></pre></td></tr></table></figure><p>将<code>％rbx</code>添加到<code>％rax</code>，并将结果放在<code>％rax</code>中，覆盖之前可能存在的内容。这就要求你在使用寄存器时要小心。 例如，假设你想计算 <code>c = b *（b + a）</code>，其中a和b是全局整数。要做到这一点，你必须小心，在执行加法时不要覆盖b的值。这里有一个实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movq  a, %rax</span><br><span class="line">movq  b, %rbx</span><br><span class="line">addq  %rbx, %rax</span><br><span class="line">imulq %rbx</span><br><span class="line">movq  %rax, c</span><br></pre></td></tr></table></figure><p><code>imul</code>指令有点不太一样：它将其参数乘以<code>％rax</code>的内容，然后将结果的低64位放入<code>％rax</code>，将高64位放入<code>％rdx</code>。（将两个64位数字相乘会产生一个128位数字。）</p><p><code>idiv</code>指令和乘法指令差不多：它以一个128位整数值开始，其低64位位于<code>％rax</code>，高位64位位于<code>％rdx</code>中，并将其除以参数。<code>（CDQO</code>指令用于将<code>％rax</code>符号扩展为<code>％rdx</code>，以便正确处理负值。）商被放在<code>％rax</code>中，余数放在<code>％rdx</code>中。例如，除以5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq a,  %rax    # set the low 64 bits of the dividend</span><br><span class="line">cdqo             # sign-extend %rax into %rdx</span><br><span class="line">idivq $5</span><br></pre></td></tr></table></figure><p>大多数语言中的求模指令只是利用<code>％rdx</code>中剩余的余数,指令<code>INC</code>和<code>DEC</code>分别递增和递减寄存器。例如，语句<code>a = ++ b</code>可以翻译为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq b, %rax</span><br><span class="line">incq %rax</span><br><span class="line">movq %rax, a</span><br></pre></td></tr></table></figure><p>布尔操作的工作方式非常类似：AND，OR，和XOR指令需要两个参数，而NOT指令只需要一个参数。像MOV指令一样，各种算术指令可以在各种寻址模式下工作。但是，您可能会发现使用MOV将值载入和载出寄存器是最方便的，然后仅使用寄存器来执行算术运算。</p><h5 id="比较和跳转指令"><a href="#比较和跳转指令" class="headerlink" title="比较和跳转指令"></a>比较和跳转指令</h5><p>使用<code>JMP</code>指令，我们可以创建一个简单的无限循环，使用<code>％eax</code>寄存器从零开始计数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">    incq %rax</span><br><span class="line">    jmp loop</span><br></pre></td></tr></table></figure><p>为了定义更有用的程序结构，如终止循环和<code>if-then</code>等语句，我们必须有一个可以改变程序流程的机制。在大多数汇编语言中，这些处理由两种不同的指令处理：比较和跳转。<br>所有的比较都是通过<code>CMP</code>指令完成的。<code>CMP</code>比较两个不同的寄存器，然后在内部<code>EFLAGS</code>寄存器中设置几个位，记录这些值是相同，更大还是更小。你不需要直接看<code>EFLAGS</code>寄存器的值。而是根据结果的不同来做适当的跳转：</p><table><thead><tr><th>指令</th><th>意义</th></tr></thead><tbody><tr><td>je</td><td>如果大于则跳转</td></tr><tr><td>jne</td><td>如果不等于则跳转</td></tr><tr><td>jl</td><td>如果小于则跳转</td></tr><tr><td>jle</td><td>如果小于等于则跳转</td></tr><tr><td>jg</td><td>如果大于则跳转</td></tr><tr><td>jge</td><td>如果大于等于则跳转</td></tr></tbody></table><p>举个例子，这里是一个循环来使<code>％rax</code>从0到5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">        incq %rax</span><br><span class="line">        cmpq $5, %rax</span><br><span class="line">        jle  loop</span><br></pre></td></tr></table></figure><p>再举个例子，一个条件赋值：如果全局变量x&gt;=0，那么全局变量y=10，否则 y=20：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        movq x, %rax</span><br><span class="line">        cmpq $0, %rax</span><br><span class="line">        jle  twenty</span><br><span class="line">ten:</span><br><span class="line">        movq $10, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">twenty:</span><br><span class="line">        movq $20, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">done:</span><br><span class="line">        movq %ebx, y</span><br></pre></td></tr></table></figure><p>跳转的参数是目标标签。这些标签在一个汇编文件中必须是唯一且私密的，除了包含在.globl内的标签 ，其他标签不能在文件外部看到，也就是不能在文件外调用。用c语言来说，一个普通的汇编标签是static的，而.globl标签是extern</p><h6 id="其他常用寄存器指令"><a href="#其他常用寄存器指令" class="headerlink" title="其他常用寄存器指令"></a>其他常用寄存器指令</h6><ul><li><code>leaq %rbp,%rax</code>: 内存赋值 <code>lea</code>, 将 <code>rbq</code> 的内存地址值赋给 <code>rax</code></li><li><code>xorl %eax, %eax</code>: 异或<code>xor</code>, 将 <code>eax</code>清 <code>0</code>, 自己异或自己</li><li><code>jmp 0x80001</code>: 跳转 <code>jmp</code>, 跳转到函数地址为 <code>0x80001</code> 的地址</li><li><code>jmp *(%rax)</code>: 间接跳转<code>*()</code>, <code>rax</code> 是个内存地址,<code>*(rax)</code>是拿到<code>rax</code> 地址里的值</li><li><code>callq 0x80001</code>: 函数调用<code>call</code>, 调用地址为<code>0x80001</code> 的函数, 一般配合 <code>retq</code></li></ul><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈是一种辅助数据结构，主要用于记录程序的函数调用历史记录以及不适合寄存器的局部变量。栈从高地址向低地址增长。<code>％rsp</code>寄存器被称为<code>“栈指针”</code>并跟踪堆栈中最底层(也就是最新的)的数据。因此，要将<code>％rax</code>压入堆栈，我们必须从<code>％rsp</code>中减去<code>8（％rax</code>的大小，以字节为单位），然后写入<code>％rsp</code>指向的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8, %rsp</span><br><span class="line">movq %rax, (%rsp)</span><br></pre></td></tr></table></figure><p>从栈中弹出一个值与上面的操作相反：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp), %rax</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure><p>从栈中丢弃最新的值，只需移动堆栈指针即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure><p>当然，压栈(入栈)或出栈是经常使用到的操作，所以都有简化的单条指令，其行为与上面的完全一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rax</span><br><span class="line">popq  %rax</span><br></pre></td></tr></table></figure><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>所有c标准库中可用的函数也可以在汇编语言程序中使用。以一种称为“调用约定”的标准方式调用，以便用多种语言编写的代码都可以链接在一起。<br>在x86 32位机器中。调用约定只是将每个参数入栈，然后调用该函数。被调用函数在栈中查找参数，完成它的工作之后，将结果存储到单个寄存器中。然后调用者弹出栈中的参数。<br>Linux上x86-64使用的调用约定有所不同，称之为System V ABI。完整的约定相当复杂，但以下是对我们来说足够简单的解释：</p><ul><li>整数参数（包括指针）按顺序放在寄存器％rdi，％rsi，％rdx，％rcx，％r8和％r9中。</li><li>浮点参数按顺序放置在寄存器％xmm0-％xmm7中。</li><li>超过可用寄存器的参数被压入栈。</li><li>如果函数使用可变数量的参数（如printf），那么必须将％eax寄存器设置为浮点参数的数量。</li><li>被调用的函数可以使用任何寄存器，但如果它们发生了变化，则必须恢复寄存器％rbx，％rbp，％rsp和％r12-％r15的值。</li><li>函数的返回值存储在％eax中。</li></ul><table><thead><tr><th>寄存器</th><th>用途</th><th>是否需要保存</th></tr></thead><tbody><tr><td>%rax</td><td>保存返回结果</td><td>无需保存</td></tr><tr><td>%rbx</td><td>-</td><td>被调用者保存</td></tr><tr><td>%rcx</td><td>参数4</td><td>无需保存</td></tr><tr><td>%rdx</td><td>参数3</td><td>无需保存</td></tr><tr><td>%rsi</td><td>参数2</td><td>无需保存</td></tr><tr><td>%rdi</td><td>参数1</td><td>无需保存</td></tr><tr><td>%rbp</td><td>栈基址指针</td><td>被调用者保存</td></tr><tr><td>%rsp</td><td>栈指针</td><td>被调用者保存</td></tr><tr><td>%r8</td><td>参数5</td><td>无需保存</td></tr><tr><td>%r9</td><td>参数6</td><td>无需保存</td></tr><tr><td>%r10</td><td>-</td><td>调用者保存</td></tr><tr><td>%r11</td><td>-</td><td>调用者保存</td></tr><tr><td>%r12</td><td>-</td><td>被调用者保存</td></tr><tr><td>%r13</td><td>-</td><td>被调用者保存</td></tr><tr><td>%r14</td><td>-</td><td>被调用者保存</td></tr><tr><td>%r15</td><td>-</td><td>被调用者保存</td></tr></tbody></table><p>每个函数都需要使用一系列寄存器来执行计算。然而，当一个函数被另一个函数调用时会发生什么？我们不希望调用者当前使用的任何寄存器被调用的函数破坏。为了防止这种情况发生，每个函数必须保存并恢复它使用的所有寄存器，方法是先将它们入栈，然后在返回之前将它们从堆栈弹出。在函数调用的过程中，栈基址指针<code>%rbp</code>始终指向当前函数调用开始时栈的位置，栈指针<code>%rsp</code>始终指向栈中最新的元素对应的位置。<code>%rbp</code>和<code>%rsp</code>之间的元素被我们成为<code>&quot;栈帧&quot;</code>，也叫<code>&quot;活动记录&quot;</code>。函数的调用过程其实就是栈帧被创建，扩张然后被销毁的过程。在说明函数调用流程前，我们不得不提到<code>%rip(instruction pointer)</code> 指令指针寄存器。<code>%rip</code>中存放的是CPU需要执行的下一条指令的地址。每当执行完一条指令之后，这个寄存器会自动增加(可以这样理解)以便指向新的指令的地址。有了这些基础，接下来我们以一段完整的程序代码来解释函数的调用流程，有下面一段c代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x &#x3D; sum(1, 2);</span><br><span class="line">    printf(&quot;result is:%d\n&quot;, x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为汇编代码之后，为了方便读代码，我们去除一些不需要的指示段之后得到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;main.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  sum</span><br><span class="line">    .type   sum, @function</span><br><span class="line">sum:</span><br><span class="line">.LFB0:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %edx</span><br><span class="line">    movl    -8(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   sum, .-sum</span><br><span class="line">    .section    .rodata</span><br><span class="line">.LC0:</span><br><span class="line">    .string &quot;result is:%d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $2, %esi</span><br><span class="line">    movl    $1, %edi</span><br><span class="line">    call    sum</span><br><span class="line">    movl    %eax, -4(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>我们知道linux系统中<code>main</code>函数是由glibc中的 <code>exec()</code>簇 函数调用的，比如我们从shell环境中启动程序最终就是由 <code>execvp()</code>调用而来。我们这里不展开说明，你只需要知道<code>main</code>函数其实也是被调用的函数。我们从<code>main</code>函数的第一条指令开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br></pre></td></tr></table></figure><p>首先，将当前的栈基址指针%rbp入栈，函数调用结束后我们就可以从栈中取得函数调用前%rbp指向的位置，进而恢复栈到之前的样子。然后使当前栈指针指向新的位置。然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subq    $16, %rsp</span><br><span class="line">movl    $2, %esi</span><br><span class="line">movl    $1, %edi</span><br></pre></td></tr></table></figure><p>在栈上申请16字节的空间以便存放后面的临时变量x，然后根据System V ABI的调用约定将传递给sum函数的参数放入%esi和%edi中(因为是int类型占用4个字节，所以只需要用寄存器的低4字节即可)。这里你可能会发现编译器没有将需要调用者保存的%r10和%r11入栈，因为编译器知道在main函数中不会使用到%r10和%r11寄存器所以无需保存。然后发出调用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call sum</span><br></pre></td></tr></table></figure><p>需要注意以上的CALL指令等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rip</span><br><span class="line">jmp sum</span><br></pre></td></tr></table></figure><p>我们把<code>%rip</code>当前的内容放入栈中，以便函数<code>sum</code>调用结束我们可以知道接下来该执行哪条指令，我们假设栈从<code>0xC0000000</code>处开始向低处延伸。到这个阶段栈的变化过程如下所示：</p><p><img src="Assembly04.png" alt="image"></p><p>现在程序跳转到sum处执行计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">movl    %edi, -4(%rbp)</span><br><span class="line">movl    %esi, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %edx</span><br><span class="line">movl    -8(%rbp), %eax</span><br><span class="line">addl    %edx, %eax</span><br></pre></td></tr></table></figure><p>和<code>main</code>函数被调用一样，<code>sum</code>函数被调用时，首先也是保存<code>%rbp</code>，然后更新栈指针<code>%rsp</code>，将两个参数拷贝到栈中进行使用。在这里你可能看到了和<code>main</code> 函数不一样的地方，局部变量保存在栈中并没有像main函数中那样引起<code>%rsp</code>的移动(对比<code>main</code>函数中的<code>SUBQ 16</code>)。是因为编译器知道sum中不会再调用其它函数，也就不用保存数据到栈中了，直接使用栈空间即可。所以就无需位移<code>%rsp</code>。计算完成后结果保存在<code>%eax</code>中，现在我们更新一下栈的变化：</p><p><img src="Assembly05.png" alt="image"></p><p>然后返回到main函数时执行了如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq    %rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>先恢复调用前的栈基址指针%rbp，然后此时栈顶的元素就是函数调用之后需要执行的下一条指令的地址，RET指令等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popq    %rip</span><br></pre></td></tr></table></figure><p>这样就可以跳转到函数结束后的下一条指令 “movl %eax, -4(%rbp)”处继续执行,至此我们看一下完整调用过程中栈的变化：</p><p><img src="Assembly06.png" alt="image"></p><p>更多关于寄存器的知识可以看<a href="https://nifengz.com/introduction_x64_assembly/" target="_blank" rel="noopener">这篇博客</a>,讲的更加详细</p><h4 id="Part05-LLDB常用指令"><a href="#Part05-LLDB常用指令" class="headerlink" title="Part05 - LLDB常用指令"></a>Part05 - LLDB常用指令</h4><p>了解了汇编的基本指令时候，我们需要再了解在Xcode中如何使用LLDB指令来调试汇编代码</p><ul><li>读取寄存器的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register read&#x2F; </span><br><span class="line">&#x2F;*例*&#x2F;POPQ  %rax</span><br><span class="line">register read&#x2F;x rax    &#x2F;&#x2F; 读取寄存器 rax 里面的值，&#x2F;后面的参数为进制：x:16 进制,f: 浮点,d:10 进制</span><br></pre></td></tr></table></figure><ul><li>修改寄存器的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register write</span><br><span class="line">&#x2F;*例*&#x2F;</span><br><span class="line">register write rax 4 &#x2F;&#x2F; 将rax修改为 4</span><br></pre></td></tr></table></figure><ul><li>读取内存中的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x&#x2F;数量-格式-字节大小</span><br><span class="line"></span><br><span class="line">&#x2F;*例*&#x2F;</span><br><span class="line"></span><br><span class="line">x&#x2F;4xg 0x1000002</span><br><span class="line">&#x2F;&#x2F; 将 0x1000002 地址的值, 以 8 个字节的格式, 分成 4 份, 16 进制 展示</span><br></pre></td></tr></table></figure><ul><li>修改内存中的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory write 内存地址 数值</span><br><span class="line"></span><br><span class="line">&#x2F;*例*&#x2F;</span><br><span class="line"></span><br><span class="line">memory write  0x1000002 10</span><br></pre></td></tr></table></figure><ul><li>格式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 是十六进制，f是浮点，d是十进制，</span><br></pre></td></tr></table></figure><ul><li>字节大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b - byte 1 字节</span><br><span class="line">h - half word 2 字节</span><br><span class="line">w - word 4 字节</span><br><span class="line">g - giant word 8 字节</span><br></pre></td></tr></table></figure><ul><li>单步运行，把子函数当作一个整体，一步执行（源码级别）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-over、next、n</span><br></pre></td></tr></table></figure><ul><li>单步运行，遇到子函数会进入子函数(源码级别)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-in 、 step、s</span><br></pre></td></tr></table></figure><ul><li>单步运行，把子函数当作一个整体一步执行（汇编级别）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-inst-over 、 nexti、ni</span><br></pre></td></tr></table></figure><ul><li>单步运行，遇到子函数会进入子函数（汇编级别）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-inst 、 stepi、si</span><br></pre></td></tr></table></figure><ul><li>直接执行完当前函数的所有代码，返回上一个函数（遇到断点会卡住）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-out 、finish</span><br></pre></td></tr></table></figure><h4 id="Part06-Swift汇编例子"><a href="#Part06-Swift汇编例子" class="headerlink" title="Part06 - Swift汇编例子"></a>Part06 - Swift汇编例子</h4><ol><li>新建一个<code>Command Line Tool</code>工程，并在<code>main.swift</code>文件中新建一个<code>sum</code>函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sum( a: Int, b: Int) -&gt; Int&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Xcode</code>进入汇编调试模式，并在<code>main</code>函数中调用<code>sum</code>函数</li></ol><p><img src="Assembly07.png" alt="image"></p><p>3.在<code>main</code>函数中，调用<code>sum</code>函数，在调用<code>sum</code>函数地方打断点</p><p><img src="Assembly08.png" alt="image"></p><p>4.通过在控制台执行 <code>n</code>指令，可以定位到第11行,执行<code>si</code>指令可以进入<code>sum</code>函数，在<code>sum</code>函数中，我们可以看到最终通过<code>%rdx</code>和<code>%rcx</code>完成累加，并最终将值放如<code>%rax</code>寄存器，作为函数返回值<br><img src="Assembly09.png" alt="image"></p><h4 id="Part07-参考"><a href="#Part07-参考" class="headerlink" title="Part07 - 参考"></a>Part07 - 参考</h4><p><a href="https://nifengz.com/introduction_x64_assembly/" target="_blank" rel="noopener">x86-64汇编入门</a></p><p><a href="https://hanleylee.com/compile-of-ios-project.html" target="_blank" rel="noopener">iOS 之编译</a></p><p><a href="https://zhuanlan.zhihu.com/p/27339191" target="_blank" rel="noopener">x86-64 下函数调用及栈帧原理</a></p><p><a href="https://juejin.im/post/5ddf66385188256e855b6e0c" target="_blank" rel="noopener">从 简单汇编基础 到 Swift 不简单的 a + 1</a></p>]]></content>
    
    <summary type="html">
    
      学习任何一种语言，都有一个由表及里，由浅入深的过程。汇编是我们探究本质的终极大法，通过汇编，我们能从根本上了解现象背后的实质。本篇内容主要介绍了什么是汇编语言、寄存器及相关知识、汇编语言的一些简单指令、LLBD指令、并给出了一个简单的调试汇编的小例子。希望对iOS开发的同学有所帮助
    
    </summary>
    
    
      <category term="周报" scheme="www.iamlay.com/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>以技术之名周报01#开篇| 2020-03-29</title>
    <link href="www.iamlay.com/2020/03/29/week13/"/>
    <id>www.iamlay.com/2020/03/29/week13/</id>
    <published>2020-03-29T10:44:06.000Z</published>
    <updated>2020-03-29T13:55:48.652Z</updated>
    
    <content type="html"><![CDATA[<h5 id="为什么要写博客？"><a href="#为什么要写博客？" class="headerlink" title="为什么要写博客？"></a>为什么要写博客？</h5><p>写博客是一个输出和分享的过程，将会对博主本人和读者产生积极的影响。为了保证输出对读者存在价值，首先需要确保博客内容的准确性，即不要输出错误的内容误导读者；要保证博客内容的逻辑性，即会使让读者读起来有云里雾里的感觉。为了达到这样的效果，就要求博主对分享的知识有足够深刻的理解，并能够转化为自己的语言分享出来。高质量的博客，对博主和读者而言，是一种双赢的结果。</p><h5 id="为什么没有养成持续以恒的习惯？"><a href="#为什么没有养成持续以恒的习惯？" class="headerlink" title="为什么没有养成持续以恒的习惯？"></a>为什么没有养成持续以恒的习惯？</h5><p>工作四年半的时间，写博客一直以来都处于养鱼的状态，没有养成持之以恒的习惯，非常惭愧。除了开始工作的那段时间有比较高的热情，接下来的几年基本放弃，总结下来，大概有下面几点原因：</p><ul><li><input checked="" disabled="" type="checkbox"> 刚开始工作，出生牛犊不怕虎，不怕嘲笑。工作一段时间，深感技术不足，以后畏首畏尾。</li><li><input checked="" disabled="" type="checkbox"> 博客搭建成本有点高，更换电脑之后，需要重新搭建，怕麻烦，一直拖着没做</li><li><input checked="" disabled="" type="checkbox"> 在不同的公司，工作强度和方向不一样，在比较忙、没有值得分享的技术点的情况下没有分享的精力和动力</li><li><input checked="" disabled="" type="checkbox"> 学习的热情没有持续，没有输入很难保持产出</li><li><input checked="" disabled="" type="checkbox"> 深入思考的时候太少，面向谷歌和百度开发一度程度扼杀人思考的能力</li></ul><h5 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h5><ul><li><input checked="" disabled="" type="checkbox"> 搭建好新的博客，做好博客的版本管理，搭建好博客不要随便改动博客配置，须知博客的本质重在内容而不是花里胡哨的样式，切勿本末倒置</li><li><input checked="" disabled="" type="checkbox"> 强制自己写博客，以至少每周一篇周报的频率写技术分享，倒逼自己在工作中寻找值得分享的知识点</li><li><input checked="" disabled="" type="checkbox"> 保持持续学习的习惯，不断更新自己的知识栈</li><li><input checked="" disabled="" type="checkbox"> 减少面向百度、谷歌开发，多思考，深入思考，探索本质</li></ul><h5 id="写在开篇-题外话"><a href="#写在开篇-题外话" class="headerlink" title="写在开篇-题外话"></a>写在开篇-题外话</h5><p>2020年是不同寻常的一年，战争、蝗灾、粮食危机、新型冠状肺炎…天灾人祸似乎要在这一年集中爆发，极大的考验各个国家面危机的能力。全世界现在一片混乱，人道主义危机轮番上演，西方世界逐渐撕掉文明的面具，暴露出强盗的本性。而在过去的两个多月，全国人民在党的带领下众志成城，付出了极大代价，艰难战胜了新冠肺炎，逐渐复工复产。然而面对动荡的世界，中国无法独善其身，不断向其他国家援助医疗物资、派遣医疗专家，开启支援全世界的模式。在中国逐渐展现出世界领袖气质的同时，大洋彼岸的现任世界领袖在特朗普的带领下，开启了一连串迷之操作，迅速将美国带入新冠肺炎的震中。为了挽救股票市场，美国将基准利率降到0，并开启无限QE，疯狂印钞2万亿美元大放水。这次疫情也许会加速新一轮的经济危机的到来，到时候将会出现大量公司倒闭，无数工薪族面临裁员。我们要做的是：做最坏的打算，抱最大的希望，不断的提升自己技术能力，确保自己在经济大萧条的时候保持足够的竞争力，将危机对自己的影响降到最低。希望各位共勉！</p><h5 id="说点开心的"><a href="#说点开心的" class="headerlink" title="说点开心的"></a>说点开心的</h5><p>从1.29号到北京，到现在整整两个月，除了家和公司两个地方，其他地方都没有去过，像我这样的自认为很能宅的人都快憋坏了。因为之前答应帮同学买药，就趁着这大好春光去了趟北京协和医院，正好放放风、撒撒野。虽然因为上班时间原因药没有买成，但是发现协和医院附近四合院景色不错，和大家分享一下，就放在文章最后了。</p><h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>第一周周报，就是想和大家分享下自己的想法，也没有准备技术文章。和大家分享一些北京的春光，希望大家：面朝大海，春暖花开。</p><img src="week_13_01.jpeg" width=80% height=30% align=center/><img src="week_13_02.jpeg" width=80% height=30% align=center/><img src="week_13_03.jpeg" width=80% height=30% align=center/><img src="week_13_04.jpeg" width=80% height=30% align=center/><img src="week_13_05.jpeg" width=80% height=30% align=center/><img src="week_13_06.jpeg" width=80% height=30% align=center/><img src="week_13_07.jpeg" width=80% height=30% align=center/>]]></content>
    
    <summary type="html">
    
      《以技术之名周报》将成为一个定期更新的博客，频率是一周一次，周末更新。该篇是第一篇，讲述了自己写这个系列的初衷，以及自己最新的一些想法。在文章的最后，分享了几张北京协和医院的风景照，希望大家：面朝大海，春暖花开。
    
    </summary>
    
    
      <category term="周报" scheme="www.iamlay.com/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Next主题-关于添加文章摘要的一点思考</title>
    <link href="www.iamlay.com/2020/03/27/HexoNextReadmore/"/>
    <id>www.iamlay.com/2020/03/27/HexoNextReadmore/</id>
    <published>2020-03-27T04:21:09.000Z</published>
    <updated>2020-03-29T13:00:57.204Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是摘要？"><a href="#什么是摘要？" class="headerlink" title="什么是摘要？"></a>什么是摘要？</h4><blockquote><p> 摘要是简洁、具体的摘要要反映论文的实质性内容，展示论文内容足够的信息，体现论文的创新性，展现论文的重要梗概，一般由具体研究的对象、方法、结果、结论四要素组成。</p></blockquote><h4 id="为什么要添加文章摘要？"><a href="#为什么要添加文章摘要？" class="headerlink" title="为什么要添加文章摘要？"></a>为什么要添加文章摘要？</h4><ol><li>我们写的每一篇技术博客，都应该有文章摘要，用简短的文字来交代该篇博客的写作背景、遇到的问题、是否解决、采取的方法。通过阅读文章摘要，读者就应该大致能够判断该篇文章对自己是否存在价值，避免把宝贵的时间浪费在没有意义的文章上。</li><li>Hexo写作的文章默认的编辑模式是全文模式，如果采用全文模式来写文章，在浏览整个网站的过程中将会把非常多的时间浪费在滑动屏幕这种没有价值的事情上。对读者而言，这是一个相当不友好的体验，而且会分散读者的注意力。</li><li>美观度</li></ol><hr><p><strong>很多关于文章摘要的博客，基本上都是在教给大家如何去截断文章，严格讲这并不是文章摘要，只是为了美观度截取了部分文章。还是建议大家在写完博客之后，可以认真写一下文章的摘要，形成一个好的写作习惯。</strong></p><hr><h4 id="Hexo添加文摘要的三种方式"><a href="#Hexo添加文摘要的三种方式" class="headerlink" title="Hexo添加文摘要的三种方式"></a>Hexo添加文摘要的三种方式</h4><ol><li>在文章中使用<code>&lt;!--more--&gt;</code>进行手动截断,这其实就是上面讲到的文章截断，推荐在使用<code>&lt;!--more--&gt;</code>之前写好文章摘要</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line"> 摘要是简洁、具体的摘要要反映论文的实质性内容，展示论文内容足够的信息，体现论文的创新性，展现论文的重要梗概，一般由具体研究的对象、方法、结果、结论四要素组成。</span><br></pre></td></tr></table></figure><ol start="2"><li>在文章中的<code>front-matter</code>中添加<code>description</code>，并提供文章摘要。<br>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。使用这种方法也可以实现首页文章部分显示的效果。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Next主题生成文章摘要的三种方式</span><br><span class="line">date: 2020-03-27 12:21:09</span><br><span class="line">tags:</span><br><span class="line">- 原创</span><br><span class="line">categories: </span><br><span class="line">- 网站</span><br><span class="line">description: 本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ol start="3"><li>自动生成摘要，主题配置文件中添加以下代码，这种方是更加机械的切割，没有办法控制摘要显示的内容, 而且是对整个网站生效的,不是特别推荐</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。
    
    </summary>
    
    
      <category term="网站" scheme="www.iamlay.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Next主题 - 图片设置</title>
    <link href="www.iamlay.com/2020/03/24/HexoNextTheme/"/>
    <id>www.iamlay.com/2020/03/24/HexoNextTheme/</id>
    <published>2020-03-24T05:32:13.000Z</published>
    <updated>2020-03-27T04:20:26.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><h4 id="Hexo有网络图片和插入本地图片两种方式："><a href="#Hexo有网络图片和插入本地图片两种方式：" class="headerlink" title="Hexo有网络图片和插入本地图片两种方式："></a>Hexo有<code>网络图片</code>和<code>插入本地图片</code>两种方式：</h4><ul><li>插入网络图片可以用常用的Markdown的方式进行插入: <code>![img-title](img-url)</code></li><li>插入本地图片，主要涉及到本地图片资源的管理，相对插入网络图片复杂一些，但是引用方式大同小异，针对插入本地图片我们稍做展开</li></ul><a id="more"></a><h5 id="插入本地图片-01"><a href="#插入本地图片-01" class="headerlink" title="插入本地图片 -01"></a>插入本地图片 -01</h5><ol><li><a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">安装插件</a>: 在博客的根目录下执行：<code>npm install hexo-asset-image --save</code> 或<code>npm install hexo-asset-image --g</code></li><li>修改站点配置文件<code>_config.yml</code>： 找到 <code>post_asset_folder</code>，把值改成 <code>true</code>，这样在执行<code>hexo new page</code> 的时候，会在<code>source/_posts</code>文件夹下生成一个和<code>page</code>同名的文件夹，可以存放该<code>page</code>中用到的图片</li><li>插入本地图片<code>![imageTitle](img.jpg)</code></li></ol><h5 id="插入本地图片-02"><a href="#插入本地图片-02" class="headerlink" title="插入本地图片-02"></a>插入本地图片-02</h5><ol><li>在<code>source</code>下建立一个<code>_posts</code>同级别的文件夹  <code>images</code>，将图片放入其中，此时的图片路径为：<br><code>/hexo/source/images/img.png</code></li><li>插入图片，要使用相对路径，应写为<code>![imageTitle](/images/img.png)</code></li></ol><h4 id="修改图片的大小"><a href="#修改图片的大小" class="headerlink" title="修改图片的大小"></a>修改图片的大小</h4><p>图片默认会显示原本的图片大小并居中显示，如果需要对图片大小进行设置，需要另外写 css 样式进行控制。当使用上面的方式创建和<code>page</code>同名的文件夹的时候，可使用下面的方式更改图片的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;img.jpg&quot; width&#x3D;80% height&#x3D;50% align&#x3D;center&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;img.png&quot; width&#x3D;80% height&#x3D;50% align&#x3D;center&#x2F;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;添加图片&quot;&gt;&lt;a href=&quot;#添加图片&quot; class=&quot;headerlink&quot; title=&quot;添加图片&quot;&gt;&lt;/a&gt;添加图片&lt;/h3&gt;&lt;h4 id=&quot;Hexo有网络图片和插入本地图片两种方式：&quot;&gt;&lt;a href=&quot;#Hexo有网络图片和插入本地图片两种方式：&quot; class=&quot;headerlink&quot; title=&quot;Hexo有网络图片和插入本地图片两种方式：&quot;&gt;&lt;/a&gt;Hexo有&lt;code&gt;网络图片&lt;/code&gt;和&lt;code&gt;插入本地图片&lt;/code&gt;两种方式：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;插入网络图片可以用常用的Markdown的方式进行插入: &lt;code&gt;![img-title](img-url)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入本地图片，主要涉及到本地图片资源的管理，相对插入网络图片复杂一些，但是引用方式大同小异，针对插入本地图片我们稍做展开&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网站" scheme="www.iamlay.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Linux(Centos)安装tomcat并且部署Java Web项目---踩坑</title>
    <link href="www.iamlay.com/2020/03/21/InstallTomcat/"/>
    <id>www.iamlay.com/2020/03/21/InstallTomcat/</id>
    <published>2020-03-21T08:47:08.000Z</published>
    <updated>2020-03-27T04:11:30.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h3><p>我使用的是<a href="https://cloud.tencent.com/login?s_url=https%3A%2F%2Fconsole.cloud.tencent.com%2F" target="_blank" rel="noopener">腾讯云</a>, 配置：1核 1GB 1Mbps系统盘：普通云硬盘，Centos系统</p><a id="more"></a><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>腾讯云提供了好几种<a href="https://cloud.tencent.com/document/product/213/5436" target="_blank" rel="noopener">登录</a>方式</p><ol><li>最简单的登陆方式是登陆控制台，点击下面的【登录】按钮，使用WebShell登录，这里就不过多介绍了</li></ol><p><img src="Linux01.png" alt="linux01.png"></p><h3 id="使用-Linux-Mac-OS-X-系统的电脑（使用密码登录）"><a href="#使用-Linux-Mac-OS-X-系统的电脑（使用密码登录）" class="headerlink" title="使用 Linux/Mac OS X 系统的电脑（使用密码登录）"></a>使用 Linux/Mac OS X 系统的电脑（使用密码登录）</h3><ol><li>打开 SSH 客户端（Mac可使用系统自带的终端）</li><li>输入<code>ssh -q -l root -p ip</code>(公网ip)</li><li>输入 CVM 实例密码进行登录。</li></ol><h3 id="使用-Linux-Mac-OS-X-系统的电脑（使用密钥登录"><a href="#使用-Linux-Mac-OS-X-系统的电脑（使用密钥登录" class="headerlink" title="使用 Linux/Mac OS X 系统的电脑（使用密钥登录)"></a>使用 Linux/Mac OS X 系统的电脑（使用密钥登录)</h3><ol><li>打开 SSH 客户端（Mac可使用系统自带的终端）。</li><li>查找您云服务器关联的 SSH 密钥文件本地存放地址。(现在控制台生成SSH秘钥，并下载到本地)</li><li>您的密钥必须不公开可见，SSH 才能工作。请使用此命令：chmod 400 [密钥文件路径]。</li><li>输入命令：ssh [-i 密钥文件路径] root@ip (解释：root是账户，ip是公网ip地址)</li></ol><h3 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h3><p>首先我们在自己的Linux系统上生成一对SSH Key：SSH密钥和SSH公钥．密钥保存在自己的Linux系统上。<br>然后公钥上传到Linux服务器．之后我们就能无密码SSH登录了．SSH密钥就好比是你的身份证明．</p><ul><li>在自己的Linux系统上生成SSH密钥和公钥<br>打开终端，使用下面的ssh-keygen来生成RSA密钥和公钥．-t表示type，就是说要生成RSA加密的钥匙．</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>RSA也是默认的加密类型．所以你也可以只输入ssh-keygen．默认的RSA长度是2048位．如果你非常注重安全，那么可以指定4096位的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -b 4096 -t rsa</span><br></pre></td></tr></table></figure><p>生成SSH Key的过程中会要求你指定一个文件来保存密钥，按Enter键使用默认的文件就行了．然后需要输入一个密码来加密你的SSH Key．密码至少要20位长度．SSH密钥会保存在home目录下的<code>.ssh/id_rsa</code>文件中．SSH公钥保存在<code>.ssh/id_rsa.pub</code>文件中．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa): 　按Enter键</span><br><span class="line">Enter passphrase (empty for no passphrase): 　　输入一个密码</span><br><span class="line">Enter same passphrase again: 　　再次输入密码</span><br><span class="line">Your identification has been saved in &#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">e1:dc:ab:ae:b6:19:b0:19:74:d5:fe:57:3f:32:b4:d0 matrix@vivid</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 4096]----+</span><br><span class="line">| .. |</span><br><span class="line">| . . |</span><br><span class="line">| . . .. . |</span><br><span class="line">| . . o o.. E .|</span><br><span class="line">| o S ..o ...|</span><br><span class="line">| &#x3D; ..+...|</span><br><span class="line">| o . . .o .|</span><br><span class="line">| .o . |</span><br><span class="line">| .++o |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><ul><li>将SSH公钥上传到Linux服务器,可以使用<code>ssh-copy-id</code>命令来完成</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@ip</span><br></pre></td></tr></table></figure><p><img src="Linux02.png" alt="linux02.png"></p><p>输入远程用户的密码后，SSH公钥就会自动上传了．SSH公钥保存在远程Linux服务器的<code>.ssh/authorized_keys</code>文件中．<br>上传完成后，SSH登录就不需要再次输入密码了．但是首次使用SSH Key登录时需要输入一次SSH密钥的加密密码．（只需要输入一次，将来会自动登录，不再需要输入密钥的密码．）</p><p>使用scp命令来传送文件时也不需要输入密码</p><blockquote><p>如果你是按照腾讯云的步骤来的话，登录成功后可能会继续让你分区与格式化数据盘，虽然我也扩展了数据盘，但是我发现其实没必要做这一步(主要是我按照官方的步骤一直失败，后来发现已经默认分了一个盘，而且一直处于挂载的状态，也无法卸载，就没再捣鼓)，接下来就可以配置部署所需要的环境了</p></blockquote><h3 id="安装JDK-centos默认安装了yum-所以我用yum安装的JDK"><a href="#安装JDK-centos默认安装了yum-所以我用yum安装的JDK" class="headerlink" title="安装JDK(centos默认安装了yum,所以我用yum安装的JDK)"></a>安装JDK(centos默认安装了yum,所以我用yum安装的JDK)</h3><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ul><li><p>下载tomcat linux安装包： <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">安装包下载地址</a></p></li><li><p>在云服务器创建存放tomcat的文件夹,例如创建一个kencery的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">mkdir kencery</span><br><span class="line">cd kencery&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>然后将下载的tomcat安装包复制到kencery文件夹下（可用cp命令或图形化操作）<br>我用cp命令没有成功，最后用的是图形化操作，Mac版本的FileZilla,可以直接将本地的安装包拖到云服务器的kencery文件夹根目录下， 然后进行解压</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxv -f apache-tomcat-8.0.29.tar.gz</span><br><span class="line">mv apache-tomcat-8.0.29 tomcat</span><br><span class="line">cd tomcat</span><br></pre></td></tr></table></figure><p>解析完成后即可以启动tomcat，检查是否安装成功，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure><p><img src="Linux03.png" alt="linux03.png"></p><p>出现如上图所示信息，则表示启动成功。这时候我们可以在浏览器中使用<code>http://ip:8080</code>访问（注：ip为服务器外网ip），如能够显示tomcat的主页，则表示不需要进行任何操作了，如果不能显示，则需要在Linux中开放防火墙的8080端口。</p><p><strong>Tips:</strong> 在进行这一步的时候，好多次，都不成功，可以通过下面的方式来排除问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.请确定tomcat监听的8080端口：</span><br><span class="line">Tomcat安装的目录下： </span><br><span class="line">conf\server.xml,找到： </span><br><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; maxHttpHeaderSize&#x3D;&quot;8192&quot; </span><br><span class="line">maxThreads&#x3D;&quot;150&quot; minSpareThreads&#x3D;&quot;25&quot; maxSpareThreads&#x3D;&quot;75&quot; </span><br><span class="line">enableLookups&#x3D;&quot;false&quot; redirectPort&#x3D;&quot;8443&quot; acceptCount&#x3D;&quot;100&quot; </span><br><span class="line">connectionTimeout&#x3D;&quot;20000&quot; disableUploadTimeout&#x3D;&quot;true&quot; &#x2F;&gt; </span><br><span class="line">看你的PORT是多少。</span><br><span class="line">2.防火墙是否屏蔽：</span><br><span class="line">在开启了防火墙时，做如下设置，开启相关端口， </span><br><span class="line">修改&#x2F;etc&#x2F;sysconfig&#x2F;iptables 文件，添加以下内容： </span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT </span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line">设置完之后可以重启防火墙服务</span><br><span class="line">（1) 重启后生效 </span><br><span class="line">开启： chkconfig iptables on </span><br><span class="line">关闭： chkconfig iptables off </span><br><span class="line">（2) 即时生效，重启后失效 </span><br><span class="line">开启： service iptables start </span><br><span class="line">关闭： service iptables stop </span><br><span class="line">3.安全组是否允许相应的端口(控制台-&gt;云服务器-&gt;安全组)</span><br></pre></td></tr></table></figure><p>如果都设置成功了，访问的时候可能出现一直加载不出来的情况，首次访问的时间特别长，我就在这里遇到了坑，以为没有设置对</p><h3 id="Linux中设置tomcat的服务器启动和关闭"><a href="#Linux中设置tomcat的服务器启动和关闭" class="headerlink" title="Linux中设置tomcat的服务器启动和关闭"></a>Linux中设置tomcat的服务器启动和关闭</h3><ol><li>完成步骤二对tomcat的安装后，接下来就可以部署项目，但是这里存在一个问题，那就是Linux的系统和重启我们每次都需要接路径并且执行命令，比较麻烦，因此我们可以设置成service的形式来实现这个功能。</li><li>执行命令：<code>vim /etc/rc.d/init.d/tomcat</code> ，创建脚本文件，在文件中写入如下代码，保存并且退出：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash  </span><br><span class="line"># &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat  </span><br><span class="line"># init script for tomcat precesses  </span><br><span class="line"># processname: tomcat  </span><br><span class="line"># description: tomcat is a j2se server  </span><br><span class="line"># chkconfig: 2345 86 16  </span><br><span class="line"># description: Start up the Tomcat servlet engine.  </span><br><span class="line"></span><br><span class="line">if [ -f &#x2F;etc&#x2F;init.d&#x2F;functions ]; then  </span><br><span class="line">. &#x2F;etc&#x2F;init.d&#x2F;functions  </span><br><span class="line">elif [ -f &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions ]; then  </span><br><span class="line">. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions  </span><br><span class="line">else  </span><br><span class="line">echo -e &quot;\atomcat: unable to locate functions lib. Cannot continue.&quot;  </span><br><span class="line">exit -1  </span><br><span class="line">fi  </span><br><span class="line">RETVAL&#x3D;$?  </span><br><span class="line">CATALINA_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&quot;   #tomcat安装目录，你安装在什么目录下就复制什么目录  </span><br><span class="line">case &quot;$1&quot; in  </span><br><span class="line">start)  </span><br><span class="line">if [ -f $CATALINA_HOME&#x2F;bin&#x2F;startup.sh ];  </span><br><span class="line">then  </span><br><span class="line">echo $&quot;Starting Tomcat&quot;  </span><br><span class="line">$CATALINA_HOME&#x2F;bin&#x2F;startup.sh  </span><br><span class="line">fi  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">if [ -f $CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh ];  </span><br><span class="line">then  </span><br><span class="line">echo $&quot;Stopping Tomcat&quot;  </span><br><span class="line">$CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh  </span><br><span class="line">fi  </span><br><span class="line">;;  </span><br><span class="line">*)  </span><br><span class="line">echo $&quot;Usage: $0 &#123;start|stop&#125;&quot;  </span><br><span class="line">exit 1  </span><br><span class="line">;;  </span><br><span class="line">esac  </span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure><p>给文件添加权限，使得脚本文件可以执行，命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat</span><br></pre></td></tr></table></figure><p>将其添加到服务中，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat</span><br></pre></td></tr></table></figure><p>然后将下面的配置文件加到tomcat中的catalina.sh文件中的最后面，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh</span><br></pre></td></tr></table></figure><p>添加的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;javajdk   #javajdk的安装路径，使用echo $JAVA_HOME命令可以读取  </span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat  </span><br><span class="line">export CATALINA_BASE&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat  </span><br><span class="line">export CATALINA_TMPDIR&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;temp</span><br></pre></td></tr></table></figure><p>以上所有工作顺利进行并没有报错，则配置完成，输入下面命令进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure><h3 id="Linux中设置tomcat开机自启动"><a href="#Linux中设置tomcat开机自启动" class="headerlink" title="Linux中设置tomcat开机自启动"></a>Linux中设置tomcat开机自启动</h3><p>通过步骤三的设置我们可以很方便的启动和关闭tomcat，但这里存在一个问题，那就是当服务器关机重启的时候，服务不能随计算机的启动而自行启动，下面我们将tomcat服务设置为开机启动。</p><p>打开Linux设置开机启动文件，将下面的配置文件写入rc.local文件的最后，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br></pre></td></tr></table></figure><p>添加的配置内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;javajdk  </span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar  </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin  </span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;  </span><br><span class="line">#tomcat自启动  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure><p>tomcat依赖于java的JDK，所以设置的时候将JDK也同步导入。</p><p>完成上面的设置后我们可以将CentOS关机重启一下，看tomcat是否成功自启动</p><h3 id="给tomcat设置用户和密码登录"><a href="#给tomcat设置用户和密码登录" class="headerlink" title="给tomcat设置用户和密码登录"></a>给tomcat设置用户和密码登录</h3><p>当tomcat安装完成之后，访问<code>http://ip:8080</code>即可以看到tomcat发布的网站，若要管理我们发布的网站，就需要登录tomcat，下面就进行用户名和密码的设置。</p><p>在tomcat安装包下面的conf文件下含有一个tomcat-usrs.xml文件，修改此文件即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim tomcat-users.xml</span><br></pre></td></tr></table></figure><p>在打开的xml配置文件后面写入下面这段配置内容后，【:wq】保存并且退出即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;     </span><br><span class="line">&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;  </span><br><span class="line">&lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,admin-gui&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>在这里会出现一个问题，因为tomcat-users.xml里面有注释的用户设置信息，取消注释，用文件提供的用户名和密码去访问的时候，会出现403错误，什么原因呢？这是因为我们没有指定用户所拥有的权限。如若我们现在想访问tomcat中图形化管理应用的功能，也就是Manager App，就需要指定manager-gui的权限，如果想访问host manager就必须指定admin-gui权限，故而需要上面所示的配置内容。</p><p>配置完用户名和密码之后，需要重新启动tomcat，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure><p>重启服务之后，检测是否登录成功，输入用户名和密码登录进入系统，则说明登录成功</p><h3 id="将Java-Web项目发布到tomcat8-0下面并且访问展示"><a href="#将Java-Web项目发布到tomcat8-0下面并且访问展示" class="headerlink" title="将Java Web项目发布到tomcat8.0下面并且访问展示"></a>将Java Web项目发布到tomcat8.0下面并且访问展示</h3><p>以上所有工作都完成之后，完美就可以将打包的JavaWeb程序发布到tomcat下即可<br>tomcat默认的发布web项目的目录是：webapps<br>将导出的war包拷贝到webapps根目录下，随之tomcat的启动，war包可以自动被解析。<br>然后在浏览器中输入路径链接，查询是否安装成功</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/sqzhao/article/details/71307850" target="_blank" rel="noopener">Linux系统下的ssh使用(依据个人经验总结)</a></p><p><a href="https://www.linuxdashen.com/ssh-key%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0ssh%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">SSH无密码登录：只需两个简单步骤 (Linux)</a></p><p><a href="https://blog.csdn.net/to_baidu/article/details/52823402" target="_blank" rel="noopener">Linux(Centos)安装tomcat并且部署Java Web项目</a></p><p><a href="https://www.kancloud.cn/curder/linux/121073" target="_blank" rel="noopener">Linux学习笔记</a></p><p><a href="https://blog.csdn.net/loongshawn/article/details/50468201" target="_blank" rel="noopener">MacPro 利用SCP上传下载Linux服务器文件</a></p><p><a href="https://www.cnblogs.com/lwhp/p/5789305.html" target="_blank" rel="noopener">腾讯云访问不了80端口，与8080问题</a></p><p><a href="https://os.51cto.com/art/201609/517037.htm" target="_blank" rel="noopener">CentOS下安装JDK的三种方法</a></p><p><a href="https://www.iteye.com/blog/canfly2010-429078" target="_blank" rel="noopener">查看Tomcat配置的端口</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;购买云服务器&quot;&gt;&lt;a href=&quot;#购买云服务器&quot; class=&quot;headerlink&quot; title=&quot;购买云服务器&quot;&gt;&lt;/a&gt;购买云服务器&lt;/h3&gt;&lt;p&gt;我使用的是&lt;a href=&quot;https://cloud.tencent.com/login?s_url=https%3A%2F%2Fconsole.cloud.tencent.com%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯云&lt;/a&gt;, 配置：1核 1GB 1Mbps系统盘：普通云硬盘，Centos系统&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="转载" scheme="www.iamlay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS，一行代码进行RSA、DES 、AES、MD5加密、解密</title>
    <link href="www.iamlay.com/2019/03/21/Encrypt/"/>
    <id>www.iamlay.com/2019/03/21/Encrypt/</id>
    <published>2019-03-21T08:16:20.000Z</published>
    <updated>2020-03-21T09:17:22.348Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/iamlay/Encryptions" target="_blank" rel="noopener">加密的Demo，欢迎下载</a></p><p>java端的加密解密，读者可以看我同事的<a href="https://note.youdao.com/" target="_blank" rel="noopener">这篇文章</a></p><a id="more"></a><p>最近做了一个移动项目，是有服务器和客户端类型的项目，客户端是要登录才行的，服务器也会返回数据，服务器是用Java开发的，客户端要同时支持多平台（Android、iOS），在处理iOS的数据加密的时候遇到了一些问题。起初采取的方案是DES加密，老大说DES加密是对称的，网络抓包加上反编译可能会被破解，故采取RSA方式加密。RSA加密时需要公钥和私钥，客户端保存公钥加密数据，服务器保存私钥解密数据。（iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签）。</p><h3 id="问题1：iOS端公钥加密的数据用Java端私钥解密"><a href="#问题1：iOS端公钥加密的数据用Java端私钥解密" class="headerlink" title="问题1：iOS端公钥加密的数据用Java端私钥解密"></a>问题1：iOS端公钥加密的数据用Java端私钥解密</h3><p>iOS无论使用系统自带的sdk函数，用mac产生的或者使用java的jdk产生的公钥和私钥，进行加密解密自己都可以使用。不过ios加密，java解密，或者反过来就不能用了。要么是无法创建报告个-9809或-50的错误，要么解出来是乱码。ios系统函数种只有用公钥加密，私钥解密的方式。而公钥加密每次结果都不同。</p><h3 id="MAC上生成公钥、私钥的方法，及使用"><a href="#MAC上生成公钥、私钥的方法，及使用" class="headerlink" title="MAC上生成公钥、私钥的方法，及使用"></a>MAC上生成公钥、私钥的方法，及使用</h3><ul><li>打开终端，切换到自己想输出的文件夹下</li><li>输入指令:<code>openssl</code>（openssl是生成各种秘钥的工具，mac已经嵌入</li><li>.输入指令:<code>genrsa -out rsa_private_key.pem 1024</code> (生成私钥，java端使用的)</li><li>输入指令:<code>rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout</code> (生成公钥)</li><li>.输入指令:<code>pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt</code>(私钥转格式，在ios端使用私钥解密时用这个私钥)</li></ul><p>注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端）</p><p><a href="http://blog.sina.com.cn/s/blog_12c8ae0d80102vy21.html" target="_blank" rel="noopener">详细步骤</a></p><h4 id="服务器返回数据也要加密，老大打算用java私钥加密-ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式"><a href="#服务器返回数据也要加密，老大打算用java私钥加密-ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式" class="headerlink" title="服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式"></a>服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式</h4><ul><li>通过简单的URLENCODE ＋ BASE64编码防止数据明文传输</li><li>对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验</li><li>对于重要数据，使用RSA进行数字签名，起到防篡改作</li><li>对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密</li></ul><p>因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；如果使用DES的话，可以通过破解客户端获取密钥，安全性较低。而服务器返回之所以使用DES，是因为不管使用DES还是RSA，密钥（或私钥）都存储在客户端，都存在被破解的风险，因此，需要采用动态密钥，而RSA的密钥生成比较复杂，不太适合动态密钥，并且RSA速度相对较慢，所以选用DES）</p><p>所以此次加密，我们选择了第四种加密方式</p><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><h4 id="iOS端进行DES加密、解密时非常方便"><a href="#iOS端进行DES加密、解密时非常方便" class="headerlink" title="iOS端进行DES加密、解密时非常方便"></a>iOS端进行DES加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、引入头文件 #import &quot;DES3Util.h&quot;</span><br><span class="line">2、加密时调用类方法  +(NSString *) encryptUseDES:(NSString *)plainText key:(NSString *)key;</span><br><span class="line">3、解密时调用类方法  +(NSString *)decryptUseDES:(NSString *)cipherText key:(NSString *)key;</span><br></pre></td></tr></table></figure><h4 id="iOS端进行RSA加密、解密时非常方便"><a href="#iOS端进行RSA加密、解密时非常方便" class="headerlink" title="iOS端进行RSA加密、解密时非常方便"></a>iOS端进行RSA加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、引入头文件 #import &quot;RSAUtil.h&quot;</span><br><span class="line">2、公钥加密时调用类方法：</span><br><span class="line">+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;</span><br><span class="line">+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;</span><br><span class="line">3、私钥解密时调用类方法 </span><br><span class="line">+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;</span><br><span class="line">+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey;</span><br></pre></td></tr></table></figure><h4 id="iOS端进行MD5加密、解密时非常方便"><a href="#iOS端进行MD5加密、解密时非常方便" class="headerlink" title="iOS端进行MD5加密、解密时非常方便"></a>iOS端进行MD5加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、引入头文件 #import &quot;MD5Util&quot;</span><br><span class="line">2、加密时调用方法：- (NSString *)md5:(NSString *)str;</span><br></pre></td></tr></table></figure><h4 id="iOS端进行AES加密、解密时非常方便"><a href="#iOS端进行AES加密、解密时非常方便" class="headerlink" title="iOS端进行AES加密、解密时非常方便"></a>iOS端进行AES加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、引入头文件 #import &quot;AES.h&quot;</span><br><span class="line">2、加密时调用方法</span><br><span class="line">+ (NSString *)encrypt:(NSString *)message password:(NSString *)password;</span><br><span class="line">2、解密时调用的方法</span><br><span class="line">+ (NSString *)decrypt:(NSString *)base64EncodedString password:(NSString *)password;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/2927ca2b3719" target="_blank" rel="noopener">有关RSA、MD5、AES加密的原理介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/iamlay/Encryptions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加密的Demo，欢迎下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;java端的加密解密，读者可以看我同事的&lt;a href=&quot;https://note.youdao.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>cocoapods依赖关系可视化</title>
    <link href="www.iamlay.com/2019/03/21/cocoapodsVisual/"/>
    <id>www.iamlay.com/2019/03/21/cocoapodsVisual/</id>
    <published>2019-03-21T08:16:20.000Z</published>
    <updated>2020-03-21T09:52:44.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.weichao.ren/ios/2018/12/27/cocoapods-graph/" target="_blank" rel="noopener">转载</a></p><blockquote><p>cocoapods管理的三方库之间有时候存在依赖关系，Podfile.lock藏满了各个版本库的版本号信息和彼此的依赖关系。</p></blockquote><h3 id="网页可视化导出-cocoapods-graph"><a href="#网页可视化导出-cocoapods-graph" class="headerlink" title="网页可视化导出-cocoapods-graph"></a>网页可视化导出-cocoapods-graph</h3><p>终端安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install cocoapods-graph</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用方式</p><p>进入到工程的根目录，执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cocoapods-graph -f Podfile.lock --html</span><br></pre></td></tr></table></figure><h3 id="图片可视化导出"><a href="#图片可视化导出" class="headerlink" title="图片可视化导出"></a>图片可视化导出</h3><p>终端安装插件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods-dependencies</span><br><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>使用方式:<br>进入到工程的根目录，执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod dependencies [PODSPEC] [--graphviz] [--image]</span><br></pre></td></tr></table></figure><p>Use the –graphviz option to generate .gv or Podfile.gv containing the dependency graph in graphviz format.</p><p>Use the –image option to generate .png or Podfile.png containing a rendering of the dependency graph.</p><p>[!] Note that for either graphviz or image output, GraphViz must be installed and dot must be accessible via $PATH.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.weichao.ren/ios/2018/12/27/cocoapods-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cocoapods管理的三方库之间有时候存在依赖关系，Podfile.lock藏满了各个版本库的版本号信息和彼此的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;网页可视化导出-cocoapods-graph&quot;&gt;&lt;a href=&quot;#网页可视化导出-cocoapods-graph&quot; class=&quot;headerlink&quot; title=&quot;网页可视化导出-cocoapods-graph&quot;&gt;&lt;/a&gt;网页可视化导出-cocoapods-graph&lt;/h3&gt;&lt;p&gt;终端安装插件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo pip install cocoapods-graph&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="转载" scheme="www.iamlay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>用Cocoapods制作属于自己的仓库</title>
    <link href="www.iamlay.com/2018/12/21/MakeCocoapods/"/>
    <id>www.iamlay.com/2018/12/21/MakeCocoapods/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2020-03-21T09:52:56.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在开发的过程中很多功能模块可能会在同一个App的不同的业务模块出现，也可能在不同的App出现，为了提高我们的开发效率，我们应该将普遍使用的功能模块封装成组件，并通过Cocoapods来管理</p></blockquote><p><a href="https://cyrill.win/articles/2016/12/04/pod-trunk" target="_blank" rel="noopener">利用pod trunk发布程序</a></p><a id="more"></a><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 邮箱 &#39;用户名&#39; --description&#x3D;&#39;电脑描述&#39;</span><br></pre></td></tr></table></figure><h3 id="查收邮件"><a href="#查收邮件" class="headerlink" title="查收邮件"></a>查收邮件</h3><ul><li>如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱”</li><li>点击邮件中的链接： <a href="https://trunk.cocoapods.org/sessions/verify/xxxx" target="_blank" rel="noopener">https://trunk.cocoapods.org/sessions/verify/xxxx</a></li></ul><h3 id="查看个人信息"><a href="#查看个人信息" class="headerlink" title="查看个人信息"></a>查看个人信息</h3><ul><li>pod trunk me</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Name:     &#39;Cyrill&#39;</span><br><span class="line">- Email:    lichunyang@outlook.com</span><br><span class="line">- Since:    December 4th, 2016 21:22</span><br><span class="line">- Pods:     None</span><br><span class="line">- Sessions:</span><br><span class="line">- December 4th, 2016 21:22 - July 13th, 21:00. IP: 103.244.255.84 Description: ‘MacbookProOfCyrill’</span><br></pre></td></tr></table></figure><p>中间可能遇到这种错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoMethodError - undefined method &#39;last&#39; for #&lt;Netrc::Entry:0x007fc59c246378&gt;</span><br></pre></td></tr></table></figure><p>这时候需要尝试更新gem源或者pod</p><ul><li>sudo gem update –system</li><li>sudo gem install cocoapods</li><li>sudo gem install cocospods-trunk</li></ul><h3 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h3><p>接下来需要在项目根路径创建一个podspec文件来描述你的项目信息</p><ul><li>pod spec cretae 文件名 (比如pod spec cretae MJExtension就会生成一个MJExtension.podspec)</li></ul><h3 id="填写podspec内容"><a href="#填写podspec内容" class="headerlink" title="填写podspec内容"></a>填写podspec内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># spec开始  s作为spec的别名</span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">    # 项目名称</span><br><span class="line">    s.name         &#x3D; &quot;CYPhotoLib&quot;  </span><br><span class="line">    # 版本号</span><br><span class="line">    s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">    # 简介</span><br><span class="line">    s.summary      &#x3D; &quot;A photo selection framework used PhotoLib.&quot;</span><br><span class="line">    # 项目地址，主页</span><br><span class="line">    s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;CoderCYLee&#x2F;CYPhotoLib&quot;</span><br><span class="line">    # 开源协议</span><br><span class="line">    s.license      &#x3D; &quot;MIT&quot;</span><br><span class="line">    # 作者</span><br><span class="line">    s.author             &#x3D; &#123; &quot;Cyrill&quot; &#x3D;&gt; &quot;lichunyang@outlook.com&quot; &#125;</span><br><span class="line">    # 作者的社交url</span><br><span class="line">    s.social_media_url   &#x3D; &quot;http:&#x2F;&#x2F;weibo.com&#x2F;exceptions&quot;</span><br><span class="line">    # 支持最低ios版本</span><br><span class="line">    s.platform     &#x3D; :ios, &quot;8.0&quot;</span><br><span class="line">    # 代码的git源地址 这里的tag&#x3D;&gt;&quot;#&#123;s.version&#125;&quot; 引用了上面的s.version  如果，在打tag的时候是用的  git tag &#39;v1.0.0&#39;  那么这里需要使用   tag &#x3D;&gt; &quot;v#&#123;s.version&#125;&quot; </span><br><span class="line">    s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;CoderCYLee&#x2F;CYPhotoLib.git&quot;, :tag &#x3D;&gt; s.version &#125;</span><br><span class="line">    # 项目需要用到的ios framework </span><br><span class="line">    s.frameworks &#x3D; &quot;UIKit&quot;, &quot;Photos&quot;</span><br><span class="line">    # 项目中用到的库</span><br><span class="line">    # s.libraries    &#x3D; &quot;stdc++ </span><br><span class="line">    # 代码文件</span><br><span class="line">    s.source_files  &#x3D; &quot;CYPhotoLib&#x2F;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line">    # 资源文件</span><br><span class="line">    s.resources &#x3D; &quot;CYPhotoLib&#x2F;Resource&#x2F;*.png&quot;</span><br><span class="line">    # 是否ARC</span><br><span class="line">    s.requires_arc &#x3D; true</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag 0.0.1</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><ul><li>删除tag</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 1.0</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;1.0</span><br><span class="line">git tag -a 1.0 -m &quot;Version 1.0&quot;</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h3 id="检测podspec语法"><a href="#检测podspec语法" class="headerlink" title="检测podspec语法"></a>检测podspec语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint CYPhotoLib.podspec</span><br><span class="line"></span><br><span class="line">pod lib lint CYPhotoLib.podspec</span><br><span class="line"></span><br><span class="line">pod spec相对于pod lib会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。</span><br></pre></td></tr></table></figure><h3 id="发布podspec"><a href="#发布podspec" class="headerlink" title="发布podspec"></a>发布podspec</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push CYPhotoLib.podspec</span><br><span class="line">如果是第一次发布pod，需要去 https:&#x2F;&#x2F;trunk.cocoapods.org&#x2F;claims&#x2F;new 认领pod</span><br></pre></td></tr></table></figure><p>有可能出现的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint 的时候是通过了的，没有错误</span><br><span class="line">然后 pod trunk push 的时候报错，如下：</span><br><span class="line">    [iOS] unknown: Encountered an unknown error (Pod::DSLError) during validation.</span><br><span class="line">解决：这种状况有可能是git的tag和podspec的tag不对</span><br></pre></td></tr></table></figure><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod setup : 初始化</span><br><span class="line">pod repo update : 更新仓库</span><br><span class="line">pod search CYPhotoLib</span><br></pre></td></tr></table></figure><h3 id="仓库更新"><a href="#仓库更新" class="headerlink" title="仓库更新"></a>仓库更新</h3><p>如果仓库更新慢，可以考虑更换仓库镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo remove master</span><br><span class="line">pod repo add master http:&#x2F;&#x2F;git.oschina.net&#x2F;akuandev&#x2F;Specs.git</span><br></pre></td></tr></table></figure><h3 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h3><ol><li>每次修改完代码，podspec内容的version字段都要修改，否则一直会读取原来的内容</li><li>podspec的version字段和git提交的tag需要保持相同的</li><li>代码中引入三方库的时候，不要用 <code>#import&quot;xxx.h&quot;</code>,要通过<code>#import&lt;xxx/xxxx.h&gt;</code>来引入，否则的话，会报 <code>include of non-modular header inside framework module “xxx.h”</code>的错误</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在开发的过程中很多功能模块可能会在同一个App的不同的业务模块出现，也可能在不同的App出现，为了提高我们的开发效率，我们应该将普遍使用的功能模块封装成组件，并通过Cocoapods来管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://cyrill.win/articles/2016/12/04/pod-trunk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用pod trunk发布程序&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="转载" scheme="www.iamlay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins自动打包搭建之路</title>
    <link href="www.iamlay.com/2018/04/21/Jenkins/"/>
    <id>www.iamlay.com/2018/04/21/Jenkins/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2020-03-27T04:15:07.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文的大部分步骤参考的是<a href="https://halfrost.com/ios_jenkins/" target="_blank" rel="noopener">一缕殇流化隐半边冰霜的博客</a>，所以截图和很多步骤都是直接拷贝的该博客，然后补充了自己踩的一些坑。最后的脚本问题我没有拷贝过来，如果大家希望有所了解，可以去原博客，本文主要是个人以后回忆所用</p></blockquote><a id="more"></a><h3 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h3><blockquote><p>持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p></blockquote><h3 id="为什么使用持续集成"><a href="#为什么使用持续集成" class="headerlink" title="为什么使用持续集成"></a>为什么使用持续集成</h3><ol><li>减少重复过程</li><li>减少风险</li><li>任何时间、任何地点生成可部署的软件</li><li>增强项目的可见性</li></ol><h3 id="环境准备步骤"><a href="#环境准备步骤" class="headerlink" title="环境准备步骤"></a>环境准备步骤</h3><p>现在我们来开始安装Jenkins。从<a href="https://jenkins.io/zh/" target="_blank" rel="noopener">官网</a> 上下载最新的pkg安装包。但是，这个时候直接安装是装不上的，Jenkins依赖于Java运行环境，因此需要首先安装<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">Java的SDK</a>。</p><p>下载JAVA的SDK，并安装。安装完成后，打开终端，cd进入到jenkins.war包所在目录，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins.war --httpPort&#x3D;8080</span><br></pre></td></tr></table></figure><p>httpPort指的就是Jenkins所使用的http端口，这里指定8080(默认的就是这个)，可根据具体情况来修改。待Jenkins启动后，在浏览器页面输入以下地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure><p>这样就打开Jenkins管理页面了。这个时候Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开<code>http://localhost:8080</code> 会出现下图的重设初始密码的界面。</p><p><img src="jenkins02.png" alt="jenkins02.png"></p><p>按照提示，找到<code>/Users/Shared/Jenkins/Home/</code>这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。<br><img src="jenkins03.png" alt="jenkins03.png"><br><img src="jenkins04.png" alt="jenkins04.png"></p><p>打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图<br><img src="jenkins05.png" alt="jenkins05.png"><br><img src="jenkins06.png" alt="jenkins06.png"></p><p><img src="jenkins07.png" alt="jenkins07.png"><br><img src="jenkins08.png" alt="jenkins08.png"><br><img src="jenkins09.png" alt="jenkins09.png"></p><p>一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。Jenkins安装完成之后，需要安装一些插件。</p><h3 id="安装GitLab插件"><a href="#安装GitLab插件" class="headerlink" title="安装GitLab插件"></a>安装GitLab插件</h3><p>GitLab用来管理源代码，Jenkins本身并没有自带GitLab插件，所以我们需要依次选择 系统管理-&gt;管理插件，在“可选插件”中选中<code>“GitLab Plugin”</code>和<code>“Gitlab Hook Plugin”</code>这两项，然后安装。</p><h3 id="安装Xcode插件"><a href="#安装Xcode插件" class="headerlink" title="安装Xcode插件"></a>安装Xcode插件</h3><p>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中<code>“Xcode integration”</code>安装。</p><h3 id="安装签名证书管理插件"><a href="#安装签名证书管理插件" class="headerlink" title="安装签名证书管理插件"></a>安装签名证书管理插件</h3><p>OS打包内测版时，需要发布证书及相关签名文件，因此这两个插件对于管理iOS证书非常方便。还是在系统管理-&gt;管理插件，在“可选插件”中选中<code>“Credentials Plugin”</code>和<code>“Keychains and Provisioning Profiles Management”</code>安装。</p><h3 id="安装脚本插件"><a href="#安装脚本插件" class="headerlink" title="安装脚本插件"></a>安装脚本插件</h3><p>这个插件的功能主要是用于在build后执行相关脚本。在系统管理-&gt;管理插件，在“可选插件”中选中<code>“Post-Build Script Plug-in”</code>安装。</p><p>安装完了插件，我们就可以配置一个构建项目了。</p><p><img src="jenkins10.png" alt="jenkins10.png"><br><img src="jenkins11.png" alt="jenkins11.png"></p><p>点击新建好的项目，进来配置一下General参数。<br>接着设置源码管理。<br>由于现在我用到的是Github，在Jenkins的证书管理中添加账号、密码。在Jenkins管理页面，选择<code>“Credentials”</code>，然后选择<code>“Global credentials (unrestricted)”</code>，点击<code>“Add Credentials”</code>，如下图所示，我们填写自己的账号密码信息，然后点击<code>“Save”</code>，这样就把账号密码添加到Jenkins的全局域中去了</p><p><img src="jenkins12.png" alt="jenkins12.png"></p><p>如果正常的配置正确的话，是不会出现下图中的那段红色的警告。如果有下图的提示，就说明Jenkins还没有连通Github或者SVN，那就请再检查账号密码是否配置正确。</p><p><img src="jenkins13.png" alt="jenkins13.png"></p><p>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。<br>不过这里有两个配置还是需要是配置的<br><code>Poll SCM (poll source code management)</code>轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br><code>Build periodically</code>(定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p><p>格式是这样的</p><p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p><p><img src="jenkins14.png" alt="jenkins14.png"></p><h3 id="构建环境设置"><a href="#构建环境设置" class="headerlink" title="构建环境设置"></a>构建环境设置</h3><p>iOS打包需要签名文件和证书，所以这部分我们勾选<code>“Keychains and Code Signing Identities”</code>和<code>“Mobile Provisioning Profiles”</code>。<br>这里我们又需要用到Jenkins的插件，在系统管理页面，选择<code>“Keychains and Provisioning Profiles Management”</code>。</p><p><img src="jenkins15.png" alt="jenkins15.png"></p><p><img src="jenkins16.png" alt="jenkins16.png"></p><p>注意：这里可以上传的一种是<code>login.keychain</code>文件一种是<code>ProvisioningProfiles</code>文件。这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名<code>/Library/keychains/login.keychain</code>,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到<code>/Users/Shared/Jenkins/Library/keychains</code>这里，(Library是隐藏文件)。Tips:后面的Code Signing Identity里面的开发者账号是手写的，而不是上传完keychain文件之后，自动识别的，这里坑了我好久</p><p>找到对应的<code>Provisioning Profiles</code>文件(这个文件不是直接在开发者平台下载下来的文件名字，而是安装到本地之后的文件名)上传之后， <code>Provisioning Profiles</code>也直接拷贝到<code>/Users/Shared/Jenkins/Library/MobileDevic</code>e文件目录下。</p><p>Tips: 如图的那个路径也是填写的，而不是上传后直接识别的，同上。</p><p>这样证书和签名文件就在Jenkins中配置好了，接下来我们只需要在item设置中指定相关文件即可。 回到我们新建的item，找到构建环境，按下图选好自己的相关证书和签名文件。Tips：在这里有时候你发现上传完上面的文件并填写完相应的账号和路径之后，点击下拉箭头，啥都没有，这个时候点击保存，然后退出，从新进来配置，多试几次。</p><p><img src="jenkins17.png" alt="jenkins17.png"></p><p>接下来在进行构建的设置，这里没有用Xcode插件，用的是执行脚本。我本地项目Xcode证书和描述文件不是自动配置的，而是手动选择的。本地配置好之后，一定要执行git上传到远程仓库。</p><p>在导出ipa包的时候，注意xcodebuild 命令，里面选项配置是一个plist文件，我在下面贴出来plist内容</p><p><img src="jenkins18.png" alt="jenkins18.png"></p><h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 工程名</span><br><span class="line">APP_NAME&#x3D;&quot;KIFTestDemo&quot;  </span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION&#x3D;&quot;iPhone Distribution: China Mobile Group Guangdong Company Limited&quot;  </span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path&#x3D;&quot;.&#x2F;$&#123;APP_NAME&#125;&#x2F;Info.plist&quot;</span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">#取build值</span><br><span class="line">bundleVersion&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE&#x3D;&quot;$(date +%Y%m%d)&quot;  </span><br><span class="line">IPANAME&#x3D;&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;.ipa&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">IPA_PATH&#x3D;&quot;$HOME&#x2F;$&#123;IPANAME&#125;&quot;  </span><br><span class="line">echo $&#123;IPA_PATH&#125;  </span><br><span class="line">echo &quot;$&#123;IPA_PATH&#125;&quot;&gt;&gt; text.txt</span><br><span class="line">RchivePath&#x3D;&quot;.&#x2F;KIFTestDemo.xcarchive&quot;</span><br><span class="line">IPAPath&#x3D;&quot;.&#x2F;KIFTestDemoipa&quot;</span><br><span class="line">optionsPlist&#x3D;&quot;.&#x2F;EnterpriseExportOptions.plist&quot;  </span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  </span><br><span class="line">xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme &quot;$&#123;APP_NAME&#125;&quot;  -configuration &#39;Release&#39; clean</span><br><span class="line">echo &quot;+++++++++++++++++build+++++++++++++++++&quot;  </span><br><span class="line">xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme &quot;$&#123;APP_NAME&#125;&quot; -sdk iphoneos -configuration &#39;Release&#39; -archivePath $RchivePath</span><br><span class="line">xcodebuild -exportArchive -archivePath $RchivePath -exportPath $IPAPath   -exportOptionsPlist $optionsPlist</span><br><span class="line">plist内容</span><br></pre></td></tr></table></figure><h3 id="plist内容"><a href="#plist内容" class="headerlink" title="plist内容"></a>plist内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;&#x2F;key&gt;</span><br><span class="line">&lt;false&#x2F;&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.gmcc.gdmobileimoa&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ee4c1dc2-cf62-41d5-9871-93f0abbacad5&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;key&gt;method&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure><h3 id="构建后，将ipa包上传到蒲公英"><a href="#构建后，将ipa包上传到蒲公英" class="headerlink" title="构建后，将ipa包上传到蒲公英"></a>构建后，将ipa包上传到蒲公英</h3><p><img src="jenkins19.png" alt="jenkins19.png"></p><h3 id="构建后脚本内容"><a href="#构建后脚本内容" class="headerlink" title="构建后脚本内容"></a>构建后脚本内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">蒲公英上的User Key</span><br><span class="line">uKey&#x3D;&quot;24d26944ee1ffacec4faeb1ac73a0a48&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey&#x3D;&quot;8d418599c52f8bf47f6cd7db1c3116b7&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">IPA_PATH&#x3D;&quot;.&#x2F;KIFTestDemoipa&#x2F;KIFTestDemo.ipa&quot;</span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey&#x3D;$&#123;uKey&#125;&quot; -F &quot;_api_key&#x3D;$&#123;apiKey&#125;&quot; http:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure><p>这里我们选择<code>Execute a set of scripts</code>，这里也是一个脚本，这个脚本用来上传自动打包好的ipa文件。</p><p>至此，我们的Jenkins设置就全部完成了。点击构建，就会开始构建项目了。</p><p>构建一次，各个颜色代表的意义如下：</p><p><img src="jenkins20.png" alt="jenkins20.png"></p><p>如果构建失败了，可以去查看Console Output可以查看log日志。</p><p><img src="jenkins21.png" alt="jenkins21.png"></p><h3 id="Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充"><a href="#Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充" class="headerlink" title="Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充"></a>Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://halfrost.com/ios_jenkins/" target="_blank" rel="noopener">手把手教你利用 Jenkins 持续集成 iOS 项目</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文的大部分步骤参考的是&lt;a href=&quot;https://halfrost.com/ios_jenkins/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一缕殇流化隐半边冰霜的博客&lt;/a&gt;，所以截图和很多步骤都是直接拷贝的该博客，然后补充了自己踩的一些坑。最后的脚本问题我没有拷贝过来，如果大家希望有所了解，可以去原博客，本文主要是个人以后回忆所用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>OCSQLCipher</title>
    <link href="www.iamlay.com/2018/03/21/OCSQLCipher/"/>
    <id>www.iamlay.com/2018/03/21/OCSQLCipher/</id>
    <published>2018-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T09:22:54.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据安全越来越成为生活中非常重要的问题，用户隐私泄露的问题时有发生，如何保护用户数据的安全，越来越成为一个负责公司有限考虑的问题。本篇文章不涉及接口安全、传输安全等方面，只是对App使用的sqlite数据库安全做分析。</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>使用SQLite数据库的时候，有时候对于数据库要求比较高，特别是在iOS8.3之前，未越狱的系统也可以通过工具拿到应用程序沙盒里面的文件，这个时候我们就可以考虑对SQLite数据库进行加密，这样就不用担心sqlite文件泄露了</p><p>通常数据库加密一般有两种方式</p><p>对所有数据进行加密<br>对数据库文件加密<br>第一种方式虽然加密了数据，但是并不完全，还是可以通过数据库查看到表结构等信息，并且对于数据库的数据，数据都是分散的，要对所有数据都进行加解密操作会严重影响性能，通常的做法是采取对文件加密的方式</p><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>LZ接手的项目原来使用cocoapod导入过FMDB,因为项目本身SVN管理的问题，原本不打算使用cocoapod导入SQLCipher,但是尝试过网上的解决方案但是没有加密成功，最后还是使用cocoapod导入的。</p><p><code>pod ‘FMDB/SQLCipher’, ‘~&gt; 2.6.2’</code></p><p>确保自己的cocoapod版本号可以导入该库,LZ的cocoapod库原本是0.0.39版本的，老是报错，最后只得升级,如果原来的版本低于1.0.0，要注意修改podfile文件的格式</p><p>导入成功后，打开<code>FMDatabase.m</code>文件，找到下面的一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)open &#123;</span><br><span class="line">  if (_db) &#123;</span><br><span class="line">  return YES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">int err &#x3D; sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db );</span><br><span class="line">if(err !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">&#x2F;&#x2F; set the handler</span><br><span class="line">[self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F;数据库open后设置加密key</span><br><span class="line">[self setKey:encryptKey_];</span><br><span class="line">&#125;   </span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;</span><br><span class="line"></span><br><span class="line"># if SQLITE_VERSION_NUMBER &gt;&#x3D; 3005000</span><br><span class="line"></span><br><span class="line">if (_db) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int err &#x3D; sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;_db, flags, [vfsName UTF8String]);</span><br><span class="line">if(err !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">return NO;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;数据库open后设置加密key</span><br><span class="line">[self setKey:encryptKey_];</span><br><span class="line">&#125;</span><br><span class="line">if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">&#x2F;&#x2F; set the handler</span><br><span class="line">[self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line"># else</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;openWithFlags requires SQLite 3.5&quot;);</span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步就可以在初始化数据库时对数据库进行加密</p><p>通过客户端验证是否可以读取数据库信息<br>取到app中的数据库<br>真机连接<code>xcode-&gt;window-&gt;Devices</code></p><p>将会得到下面的文件，然后右键显示包含内容，找到自己创建的数据库</p><p>打开数据库的工具,笔者使用的是<a href="https://www.waitsun.com/navicat-premium-11-1-15.html" target="_blank" rel="noopener">Navicat Premium</a></p><p>打开Navicat Premium,链接数据库，选择sqlite</p><p>选中本地保存的数据库文件，点击ok打开</p><p>将会提示</p><p>提醒</p><p>注意:笔者这里修改的是源码，是因为接手的工程FMDB又被封装，更改起来比较困难，为了不修改FMDB的源代码，可以继承自FMDatabase类重写需要setKey的几个方法，具体写法可见demo,到这一步就可以在初始化数据库时对数据库进行加密，不过很多情况下，我们可能会遇到对已经存在的数据库进行加密</p><p>SQLite数据库加解密</p><p>SQLCipher提供了几个命令用于加解密操作</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;sqlcipher plaintext.db  </span><br><span class="line">sqlite&gt; ATTACH DATABASE &#39;encrypted.db&#39; AS encrypted KEY &#39;testkey&#39;;  </span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&#39;encrypted&#39;);  </span><br><span class="line">sqlite&gt; DETACH DATABASE encrypted;</span><br></pre></td></tr></table></figure><ul><li>打开非加密数据库</li><li>创建一个新的加密的数据库附加到原数据库上</li><li>导出数据到新数据库上</li><li>卸载新数据库</li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; PRAGMA key &#x3D; &#39;testkey&#39;;  </span><br><span class="line">sqlite&gt; ATTACH DATABASE &#39;plaintext.db&#39; AS plaintext KEY &#39;&#39;;  -- empty key will disable encryption</span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&#39;plaintext&#39;);  </span><br><span class="line">sqlite&gt; DETACH DATABASE plaintext;</span><br></pre></td></tr></table></figure><ul><li>打开加密数据库</li><li>创建一个新的不加密的数据库附加到原数据库上</li><li>导出数据到新数据库上</li><li>卸载新数据库</li></ul><h3 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** encrypt sqlite database to new file *&#x2F;</span><br><span class="line"></span><br><span class="line">+ (BOOL)encryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey</span><br><span class="line">&#123;</span><br><span class="line">const char* sqlQ &#x3D; [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS encrypted KEY &#39;%@&#39;;&quot;, targetPath, encryptKey] UTF8String];</span><br><span class="line">sqlite3 *unencrypted_DB;</span><br><span class="line">if (sqlite3_open([sourcePath UTF8String], &amp;unencrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">char *errmsg;</span><br><span class="line">&#x2F;&#x2F; Attach empty encrypted database to unencrypted database</span><br><span class="line">sqlite3_exec(unencrypted_DB, sqlQ, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export database</span><br><span class="line">sqlite3_exec(unencrypted_DB, &quot;SELECT sqlcipher_export(&#39;encrypted&#39;);&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Detach encrypted database</span><br><span class="line">sqlite3_exec(unencrypted_DB, &quot;DETACH DATABASE encrypted;&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(unencrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** decrypt sqlite database to new file *&#x2F;</span><br><span class="line">+ (BOOL)unEncryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey</span><br><span class="line">&#123;</span><br><span class="line">const char* sqlQ &#x3D; [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS plaintext KEY &#39;&#39;;&quot;, targetPath] UTF8String];</span><br><span class="line">sqlite3 *encrypted_DB;</span><br><span class="line">if (sqlite3_open([sourcePath UTF8String], &amp;encrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">char* errmsg;</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key &#x3D; &#39;%@&#39;;&quot;, encryptKey] UTF8String], NULL, NULL, &amp;errmsg);</span><br><span class="line">&#x2F;&#x2F; Attach empty unencrypted database to encrypted database</span><br><span class="line">sqlite3_exec(encrypted_DB, sqlQ, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export database</span><br><span class="line">sqlite3_exec(encrypted_DB, &quot;SELECT sqlcipher_export(&#39;plaintext&#39;);&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Detach unencrypted database</span><br><span class="line">sqlite3_exec(encrypted_DB, &quot;DETACH DATABASE plaintext;&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** change secretKey for sqlite database *&#x2F;</span><br><span class="line">+ (BOOL)changeKey:(NSString *)dbPath originKey:(NSString *)originKey newKey:(NSString *)newKey</span><br><span class="line">&#123;</span><br><span class="line">sqlite3 *encrypted_DB;</span><br><span class="line">if (sqlite3_open([dbPath UTF8String], &amp;encrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key &#x3D; &#39;%@&#39;;&quot;, originKey] UTF8String], NULL, NULL, NULL);</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA rekey &#x3D; &#39;%@&#39;;&quot;, newKey] UTF8String], NULL, NULL, NULL);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>SQLCipher使用起来还是很方便的，基本上不需要怎么配置，需要注意的是，尽量不要在操作过程中修改secretKey，否则，可能导致读不了数据，在使用第三方库的时候尽量不去修改源代码，可以通过扩展或继承的方式修改原来的行为，这样第三方库代码可以与官方保持一致，可以跟随官方版本升级，具体代码可以到<a href="https://github.com/zhengbomo/sqlcipherDemo" target="_blank" rel="noopener">github上下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;数据安全越来越成为生活中非常重要的问题，用户隐私泄露的问题时有发生，如何保护用户数据的安全，越来越成为一个负责公司有限考虑的问题。本篇文章不涉及接口安全、传输安全等方面，只是对App使用的sqlite数据库安全做分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="www.iamlay.com/categories/iOS/"/>
    
    
      <category term="原创" scheme="www.iamlay.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
</feed>
