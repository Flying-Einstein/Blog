<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>以技术之名周报05#ipa包“瘦身”| 2020-04-26</title>
    <url>/2020/04/26/week17/</url>
    <content><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote>
<p>随着App版本的不断迭代，安装包会越来越大。安装包的大小是非常影响用户体验的。在推广App的时候，如果安装包很大，需要花费很多的时间来下载，会劝退很多用户。所以，我们应当使安装包尽量小。</p>
</blockquote>
<h3 id="Part01-瘦身方向"><a href="#Part01-瘦身方向" class="headerlink" title="Part01 - 瘦身方向"></a>Part01 - 瘦身方向</h3><h4 id="安装包组成"><a href="#安装包组成" class="headerlink" title="安装包组成"></a>安装包组成</h4><p>通过将导出的ipa包，用<code>归档工具</code>解压，在解压出的<code>payload</code>文件夹中得到App文件,查看App包含的内容，我们可以发现该文件主要包含以下内容：</p>
<ol>
<li>Exectutable-可执行文件</li>
<li>Resources:资源文件<ul>
<li>图片资源（Assets.car/bundle/png/jpg）</li>
<li>音/视频资源（mp/mp4）</li>
<li>静态网页资源：html/css/js</li>
<li>其他：文本/字体/证书等</li>
</ul>
</li>
<li>Framework:<ul>
<li>SwiftSupport: libSwiftxxx 等一系列 Swift 库</li>
<li>其他依赖库：Embeded Framework</li>
</ul>
</li>
<li>Plugins: Application Extensions<ul>
<li>appex：其组成大致与 ipa 包组成一致</li>
</ul>
</li>
</ol>
<h4 id="安装包优化分析"><a href="#安装包优化分析" class="headerlink" title="安装包优化分析"></a>安装包优化分析</h4><p> 在安装包中，可执行文件、图片资源和动态库占比较大，所以我们优化的重点就是这三个方向。</p>
<p> <img src="week1701.png" alt=""></p>
<h3 id="Part02-瘦身实施"><a href="#Part02-瘦身实施" class="headerlink" title="Part02 - 瘦身实施"></a>Part02 - 瘦身实施</h3><h4 id="图片资源优化"><a href="#图片资源优化" class="headerlink" title="图片资源优化"></a>图片资源优化</h4><p>对大部分的App来讲，占比最大资源文件应该就是图片资源，所以资源文件优化的重点就是图片资源的优化。图片资源的优化可以从下面几个方向来进行。</p>
<h5 id="1⃣️️将部分图片资源放到服务器上"><a href="#1⃣️️将部分图片资源放到服务器上" class="headerlink" title="1⃣️️将部分图片资源放到服务器上"></a>1⃣️️将部分图片资源放到服务器上</h5><p>将所有的图片资源都打到安装包中其实是不必要的，反而会造成安装包极速的增大，资源应该是按需加载的。除了一些常用的图片资源和一些如果放在线上非常影响用户体验的图片，其他的图片都应该放在资源服务器上，做好相应的图片缓存策略。</p>
<h5 id="2⃣️清理没用的图片资源"><a href="#2⃣️清理没用的图片资源" class="headerlink" title="2⃣️清理没用的图片资源"></a>2⃣️清理没用的图片资源</h5><p>随着版本的迭代，之前导入的一些图片资源已经不再使用，要做到及时的清理没用的图片资源。<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources </a>是一款非常不错的无用图片查找工具，<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources </a>的思路是，先获取图片文件(imageset, jpg, png, gif)集合A，然后搜索代码文件中所有字符串名称得到B，然后从A集合中排除集合B就得到未使用的图片资源。</p>
<h5 id="3⃣️图片资源压缩"><a href="#3⃣️图片资源压缩" class="headerlink" title="3⃣️图片资源压缩"></a>3⃣️图片资源压缩</h5><p>可以使用<a href="https://github.com/ImageOptim/ImageOptim" target="_blank" rel="noopener">ImageOptim</a>，通过优化压缩参数，移除无用的文件元数据和不必要的颜色配置来实现图片的无损压缩。我们UI切图使用的是蓝湖，蓝湖也支持图片压缩，如果没有使用过的同学可以尝试。</p>
<h5 id="4⃣️iconfont"><a href="#4⃣️iconfont" class="headerlink" title="4⃣️iconfont"></a>4⃣️iconfont</h5><p>即使经过了图片转下载，无用图片删除，但是工程中的图片数量还是极为可观，其中各种各样的icon图标占了不少的数量。为了进一步减少图片数量，可以使用<code>iconfont</code>方案， <code>iconfont</code>优点：</p>
<ul>
<li>矢量，缩放不失真</li>
<li>可以设置颜色</li>
<li>接入成本低，不需要引入额外的类库</li>
</ul>
<p><code>iconfont</code>可以解决因为icon大小，颜色不同而重新切图的窘境。<code>iconfont</code>是一个能减少图片数量的好方案。</p>
<h4 id="可执行文件-Mach-O-优化"><a href="#可执行文件-Mach-O-优化" class="headerlink" title="可执行文件(Mach-O)优化"></a>可执行文件(Mach-O)优化</h4><h5 id="1⃣️LinkMap文件"><a href="#1⃣️LinkMap文件" class="headerlink" title="1⃣️LinkMap文件"></a>1⃣️LinkMap文件</h5><p>但是通过<code>MachOView</code>，是不可以查看每个静态文件喝每个.o文件的大小，所以我们需要想办法量化文件的大小,我们可以通过分析<code>LinkMap</code>文件做到。</p>
<p><code>LinkMap</code>文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（<strong>TEXT）和数据段（</strong>DATA）的分布情况，可以根据这些信息进行针对性的优化。</p>
<ul>
<li><p>LinkMap文件获取：</p>
<ol>
<li>设置<code>Project-&gt;Build Settings-&gt;Write Link Map File</code>为<code>YES</code></li>
<li>设置<code>Project-&gt;Build Settings-&gt;Path to Link Map File</code>为LinkMap文件的输出路径</li>
</ol>
</li>
<li><p>LinkMap文件分析：</p>
<p>可以使用<a href="https://github.com/huanxsd/LinkMap" target="_blank" rel="noopener">LinkMap - LinkMap.txt 文件解析工具</a>分析每个类或者静态库的大小。通过查看LinkMap文件，各个静态库和文件的大小一目了然。</p>
<p><img src="week1702.png" alt="Alt text"></p>
<p>1、 在选用三方库的时候，尽量使用占用内存比较小的三方库，及时的移除不再使用的三方库。<br>2、分析占用内存比较大的类，删除类中没用的代码，减少冗余，保证用最简代码实现相应的功能，提升代码的复用性。</p>
</li>
</ul>
<p><code>LinkMap</code>可以在宏观上获取需要优化的部分，但是微观上，哪些是无用的类和方法，需要我们在    <code>Mach-O</code>层面进行分析，可以使用<a href="https://github.com/fangshufeng/MachOView" target="_blank" rel="noopener">MachOView </a>对<code>Mach-O</code>文件进行分析。可以通过阅读<a href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/" target="_blank" rel="noopener">这篇文章</a>探秘<code>Mach-O</code>。 下面这张图是<code>MachOView</code>查看<code>Mach-O</code>文件的截图：</p>
<p><img src="week1703.png" alt="Alt text"></p>
<p>大家可以阅读<a href="https://juejin.im/post/5d5d1a92e51d45620923886a" target="_blank" rel="noopener">:删除无用的类</a>进行实践</p>
<h5 id="2⃣️尽量不要使用OC和Swift混编"><a href="#2⃣️尽量不要使用OC和Swift混编" class="headerlink" title="2⃣️尽量不要使用OC和Swift混编"></a>2⃣️尽量不要使用OC和Swift混编</h5><p>OC和Swift混编的时候，因为需要一些静态库的支持，会造成安装包急剧增大。所以，尽量选择一种语言开发，不要采用混编的方式。<br><img src="week1704.png" alt="Alt text"></p>
<h5 id="3⃣️代码瘦身"><a href="#3⃣️代码瘦身" class="headerlink" title="3⃣️代码瘦身"></a>3⃣️代码瘦身</h5><p>可以使用<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a>进行代码的静态检查。<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a> 提供了非常强大的代码静态检查工具，使用<code>Inspect Code</code>，可以找到很多代码优化的地方:主要包括删除不用的类，不用的函数，重复的代码等。<br><img src="week1705.png" alt="Alt text"></p>
<h4 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h4><p>Xcode 支持编译器层面的一些优化优化选项，可以让我们介于更快的编译速度、更小的二进制大小和更快的执行速度之间自由选择想要进行的优化粒度。</p>
<h5 id="1⃣️BitCode"><a href="#1⃣️BitCode" class="headerlink" title="1⃣️BitCode"></a>1⃣️BitCode</h5><p>可以在<code>Xcode Target -&gt; Build Settings -&gt; Enable Bitcode</code> 中打开 bitcode 选项</p>
<p>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上。</p>
<p>在打包时，如果一些三方的依赖库没有开启 bitcode，或者开启了但是没有在最终引用的链接库中带有 bitcode，那么整个工程就无法用 bitcode 来编译了。</p>
<h3 id="Part03-参考"><a href="#Part03-参考" class="headerlink" title="Part03- 参考"></a>Part03- 参考</h3><p><a href="https://juejin.im/post/5cbb3f9151882529e5627ece" target="_blank" rel="noopener">App瘦身小记</a><br><a href="http://www.cocoachina.com/articles/859032" target="_blank" rel="noopener">京东商城iOS App瘦身实践</a><br><a href="https://www.jianshu.com/p/c94dedef90b7" target="_blank" rel="noopener">APP安装包瘦身实践</a><br><a href="https://zhuanlan.zhihu.com/p/86317689" target="_blank" rel="noopener">iOS开发：Archive、ipa 和 App 包瘦身</a><br><a href="https://juejin.im/post/5e969d816fb9a03c60188229?utm_source=gold_browser_extension" target="_blank" rel="noopener">APP体积优化</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>以技术之名周报04#Sign in with Apple 设计原则| 2020-04-19</title>
    <url>/2020/04/19/week16/</url>
    <content><![CDATA[<h3 id="使用Apple提供的Button"><a href="#使用Apple提供的Button" class="headerlink" title="使用Apple提供的Button"></a>使用Apple提供的Button</h3><p>当你使用系统提供的API创建Button的时候，能够获得以下优势：</p>
<ol>
<li>能够确保Button使用了苹果认可的title、font、color 和 style</li>
<li>能够确保在你修改Button的Style的时候，Button的Content有一个理想的位置</li>
<li>Button的title能够跟自动转换成设备手机选择的Language</li>
<li>支持配置圆角以满足你自己UI的风格（iOS、MacOS、Web）</li>
</ol>
<p>对开发者而言，可以看这些使用引导<a href="https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidbutton" target="_blank" rel="noopener">ASAuthorizationAppleIDButton</a> (iOS, macOS, and tvOS), <a href="https://developer.apple.com/documentation/watchkit/wkinterfaceauthorizationappleidbutton" target="_blank" rel="noopener">WKInterfaceAuthorizationAppleIDButton</a> (watchOS), and <a href="https://developer.apple.com/documentation/signinwithapplejs/displaying_and_configuring_sign_in_with_apple_buttons" target="_blank" rel="noopener">Displaying and Configuring Sign in with Apple Buttons</a> (web).</p>
<p>系统提供的Button 的Title有几种文案。根据你使用的平台，选择最合适的文案。</p>
<p>下面几种Button Title都可以在iOS、macOS、和tvOS中使用，但是只有Sign in with Apple 和 Continue with Apple 可以在Web中使用</p>
<p><img src="SignWithApple01.png" alt=""></p>
<p>对watchOS，系统提供的Title只有一个 <code> Sign in</code></p>
<p><img src="SignWithApple02.png" alt=""></p>
<p>依赖于不同的平台，系统提供了三种外观的Button，分别是白色（white）、有边框的白色（white with an outline）、黑色（black）。根据放置Button的背景颜色，选择最合Button样式。</p>
<h4 id="白色"><a href="#白色" class="headerlink" title="白色"></a>白色</h4><p>白色可以在任何平台使用（包括Web）,当背景是黑色或者其他深色时，选择白色会有更好的表现力</p>
<p><img src="SignWithApple03.png" alt=""></p>
<h4 id="白色带边框"><a href="#白色带边框" class="headerlink" title="白色带边框"></a>白色带边框</h4><p>白色带边框的Button可以在iOS、macOS、和Web上面使用，当背景是白色或浅色背景的时候，背景和Button的填充色对比是不够强烈的，通过添加边框可以提升表现力。当背景是深色的时候，不要使用这种风格，深色会使得这种风格变得混乱。</p>
<p><img src="SignWithApple04.png" alt=""></p>
<h4 id="黑色"><a href="#黑色" class="headerlink" title="黑色"></a>黑色</h4><p>黑色可以在任何平台使用（包括Web）,当背景是白色或者其他浅色时，选择黑色会有更好的表现力</p>
<p><img src="SignWithApple05.png" alt=""><br>不像其他平台上的黑色风格的Button，在watchOS上，黑色风格的Button是非全黑的填充色，和watchOS全黑色的背景做对比。watchOS上Button用系统定义的黑灰样式。</p>
<p><img src="SignWithApple06.png" alt=""></p>
<h4 id="Button的大小和圆角"><a href="#Button的大小和圆角" class="headerlink" title="Button的大小和圆角"></a>Button的大小和圆角</h4><p>调整Button的圆角以匹配App中其他登录Button的风格。默认情况下， Sign in with Apple的Button是没有圆角的。在iOS、macOS、Web中，可以通过修改圆角的半径，生成直角或者药丸状的Button。</p>
<p><img src="SignWithApple07.png" alt=""></p>
<p><strong>iOS、macOS 、Web中使用的Button，必须有一个最小的的Size和外边距</strong>。值得注意的是，依赖于文本的本地化，Button的长度或许很长。下面的值可以做作为设计原则：</p>
<table>
<thead>
<tr>
<th>Minimum width</th>
<th>Minimum height</th>
<th>Minimum margin</th>
</tr>
</thead>
<tbody><tr>
<td>140pt (140px @1x, 280px @2x)</td>
<td>30pt (30px @1x, 60px @2x)</td>
<td>1/10 of the button’s height</td>
</tr>
</tbody></table>
<h3 id="创建一个自定义的-Sign-in-with-Apple-Button"><a href="#创建一个自定义的-Sign-in-with-Apple-Button" class="headerlink" title="创建一个自定义的 Sign in with Apple Button"></a>创建一个自定义的 Sign in with Apple Button</h3><p>如果你有需要的话，可以在iOS、macOS、或者Web平台上自己创建一个自定义的Sign in with Apple Button 。比如：或许你支持多种登录方式，你想展示<code>Left-Aligned Logo</code> Button或者<code>Logo-Only</code> Button。</p>
<p><img src="SignWithApple08.png" alt=""></p>
<p><a href="https://developer.apple.com/design/resources/" target="_blank" rel="noopener">Apple Design Resources </a>提供了一些美术资源，你可以使用这些美术资源自定义Sign in with Apple Button。这些资源包括PNG、SVG和PDF三种格式，并且包含黑白两种表现形式。下面是<code>Logo-Only</code> Button的两个例子，每个Logo都添加了富有表现力的背景色</p>
<p><img src="SignWithApple09.png" alt=""></p>
<p>所有下载的Logo文件都包含一个内边距，这样在Button中放置logo更加容易</p>
<ol>
<li><code>Left-Aligned Logo</code>文件包含一个垂直方向上的内边距，能够确保Logo在Button中有一个合适的占比，水平方向上的内边距也为Logo和Button的左边距、Logo和Button的title之间提供了一个最小边距。</li>
<li><code>Logo-Only</code>文件包含一个水平和垂直方向上的内边距，确保了Logo在Button中有一个合适的占比</li>
</ol>
<p>使用<code>Logo-Only</code>文件的时候,需要遵循以下原则：</p>
<ol>
<li>不要仅仅使用 Apple Logo  自己作为一个Button</li>
<li>Logo文件的高度要和Button的高度保持一致</li>
<li>不要剪切Logo文件</li>
<li>不要添加垂直方向的内边距</li>
<li>Logo文件不要使用自己定义的颜色</li>
</ol>
<h4 id="Left-Aligned-Logo-Buttons"><a href="#Left-Aligned-Logo-Buttons" class="headerlink" title="Left-Aligned Logo Buttons"></a>Left-Aligned Logo Buttons</h4><p>根据你的Button的高度选择合适的Logo文件。因为PDF和SVG是矢量图，你可以在任何高度的Button中使用这两种文件。而PNG文件只能在高度为44的Button中使用，这是iOS中Button的默认高度。</p>
<p>Title要使用系统字体(Sign in with Apple、Sign up with Apple、 Continue with Apple)：为了统一，你自定义的Button的高度和Title应该和系统使用的<code>保持一样的比例</code>。Title应该占据Button高度的43%，换言之Button的高度应该是Title Font大小的233%。下面两个例子展示了这种比例：</p>
<p><img src="SignWithApple10.png" alt=""></p>
<p><strong>保持Title的大写的风格</strong>所有Title的首字母都是大写的（Sign or Continue — and Apple），其他的字母是小写的。切不可改变这种风格。</p>
<p><strong>保持Title和Logo和Button在垂直方向上对齐</strong>：为了做到这一点，Title和Button的中部在垂直方向上对齐，然后添加Logo图片，确保图片的高度和Button的高度一致。因为Logo图片本身具有顶部和底部的内边距，垂直对齐Button的Title能够确保Title和Logo在Button中占据合适的比例。</p>
<p><strong>如果有需要可以嵌入Logo</strong> 如果你需要将苹果的Logo和其他的认证的logo对齐，可以将Logo左侧嵌入</p>
<p><strong>Title和Button的右边有一个最小内边距</strong>  边距至少占据Button宽度的8%</p>
<p><strong>Button有一个最小的size，且Button有一个内边距</strong> ：因为文本的本地化，Button的长度可能很长。参考下面的设计原则：</p>
<table>
<thead>
<tr>
<th>Minimum width</th>
<th>Minimum height</th>
<th>Minimum margin</th>
</tr>
</thead>
<tbody><tr>
<td>140pt (140px @1x, 280px @2x)</td>
<td>30pt (30px @1x, 60px @2x)</td>
<td>1/10 of the button’s height</td>
</tr>
</tbody></table>
<h4 id="Logo-Only-Buttons"><a href="#Logo-Only-Buttons" class="headerlink" title="Logo-Only Buttons"></a>Logo-Only Buttons</h4><p><strong>根据你的Button的高度选择合适的Logo文件</strong>。因为PDF和SVG是矢量图，你可以在任何高度的Button中使用这两种文件。而PNG文件只能在高度为44的Button中使用。</p>
<p><strong>不要为Logo-Only图片添加水平方向上的内边距</strong>   Logo-only的Button是1:1的比例，下载的Logo-Only文件已经有了合适的内边距</p>
<p><strong>用mask(遮罩)改变Logo-only图片的形状</strong>  例如 Sign in with Apple使用用圆形或者椭圆矩形的Button。不要为了减小内边距剪切Apple提供的美术资源，也不要只使用Apple Logo。</p>
<p><img src="SignWithApple11.png" alt=""></p>
<p><strong>Button有一个最小的内边距</strong>  内边距至少为Button高度的1/10</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在OC中进行源码分析</title>
    <url>/2020/04/13/OCCodeAnalysis/</url>
    <content><![CDATA[<h3 id="Part01-获取objc-runtime的源码"><a href="#Part01-获取objc-runtime的源码" class="headerlink" title="Part01-获取objc-runtime的源码"></a>Part01-获取objc-runtime的源码</h3><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc-runtime的源码地址</a></p>
<p>注意：⚠️⚠️⚠️，objc-runtime的源码的新旧程度并不是按照时间进行排序，而是按照包的大小进行的排序，一般可以理解为包最大的即为最新的源码</p>
<p>但是官网的runtime代码是无法直接运行的，如果想直接运行可以下载<a href="https://github.com/RetVal" target="_blank" rel="noopener">RetVal</a>处理过的<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">源代码</a></p>
<h3 id="Part02-将OC代码编译成C-代码"><a href="#Part02-将OC代码编译成C-代码" class="headerlink" title="Part02-将OC代码编译成C++代码"></a>Part02-将OC代码编译成C++代码</h3><ol>
<li>找到需要编译成C++代码的OC文件，这里我们拿<code>main.m</code>来举例</li>
</ol>
<p><img src="OCCodeAnalysis01.png" alt="image"></p>
<ol start="2">
<li>进入到main.m所在的文件夹，执行：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;-fobjc-arc表示编译需要支持ARC特性。</span><br><span class="line">&#x2F;&#x2F;-framework Foundation表示引用Foundation框架，这个框架中定义了很多基本的类，例如字符串、数组、字典等等。</span><br><span class="line">&#x2F;&#x2F;后面的 mian.m 就是待编译的源代码文件名。</span><br><span class="line">&#x2F;&#x2F;-o main 表示输出的可执行文件的文件名是 main。</span><br><span class="line"></span><br><span class="line">clang -fobjc-arc -framework Foundation main.m -o main</span><br></pre></td></tr></table></figure>
<p>得到执行文件，双击可以看到执行结果</p>
<p><img src="OCCodeAnalysis02.png" alt="image"></p>
<ol start="3">
<li>生成main.m的cpp文件main.cpp，main.cpp就是编译器对main.m进行转换的结果，执行：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
如果在执行<code>执行 clang -rewrite-objc main.m</code>是报错的，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.m:9:9: fatal error: &#39;UIKit&#x2F;UIKit.h&#39; file not found</span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">        ^~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;xxxxx.m</span><br></pre></td></tr></table></figure>
<h3 id="Part03-根据C-代码，结合objc-runtime源码进行分析"><a href="#Part03-根据C-代码，结合objc-runtime源码进行分析" class="headerlink" title="Part03-根据C++代码，结合objc-runtime源码进行分析"></a>Part03-根据C++代码，结合objc-runtime源码进行分析</h3><p>执行完上面的指令，生成了相关文件的C++ 代码，C++代码用到了objc-runtime源码，所以要进入到objc-runtime源码，探索本质。例如下面是main.m编译成main.cpp文件时，-(void)eat生成的C ++代码。标出来的代码都是objc-runtime中的源代码</p>
<p><img src="OCCodeAnalysis03.png" alt="image"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>以技术之名周报03#AOP| 2020-04-12</title>
    <url>/2020/04/12/week15/</url>
    <content><![CDATA[<h3 id="Part01-什么是AOP"><a href="#Part01-什么是AOP" class="headerlink" title="Part01-什么是AOP?"></a>Part01-什么是AOP?</h3><blockquote>
<p>面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。</p>
</blockquote>
<h3 id="Part02-AOP一个使用场景：埋点"><a href="#Part02-AOP一个使用场景：埋点" class="headerlink" title="Part02-AOP一个使用场景：埋点"></a>Part02-AOP一个使用场景：埋点</h3><p>互联网进入到下半场，用户也由增量进入到存量时代。通过统计用户操作行为了解用户的偏好，结合大数据分析，可以方便公司更加合理的作出决策更好的吸引客户、留住客户。对任何一个主流的APP来讲，都会存在大量的埋点来统计用户的行为。埋点功能不属于业务逻辑，埋点代码和业务代码混合在一块会严重污染业务代码，且埋点的代码会分散到整个工程。面向切面编程是解决这种问题一个很好的方案，其原理就是在不更改正常业务处理流程的前提下，动态生成一个代理类，从而实现对目标对象嵌入附加的操作。</p>
<h3 id="Part03-iOS实现AOP的原理"><a href="#Part03-iOS实现AOP的原理" class="headerlink" title="Part03-iOS实现AOP的原理"></a>Part03-iOS实现AOP的原理</h3><p>利用OC的动态性，通过wizzling method 改变目标函数的 selector 所指向的实现，然后在新的实现中实现附加的操作，完成之后再回到原来的处理逻辑。OC是一门动态语言，在OC中执行一个方法的时候实际上是在发送一条消息给接受对象<code>[receiver message]</code>。完整的过程是根据<code>message</code>生成一个选择子<code>selector</code>，然后根据<code>selector</code>找到指向函数的的具体的实现的指针<code>IMP</code>，然后找到真正的函数执行逻辑。OC的这种处理流程为我们动态修改函数的实现提供了可能，在运行时，只要我们改变selector和IMP的对应关系，我们就可以在执行<code>[receiver message]</code>时进入到新的函数实现。</p>
<h3 id="Part04-iOS实现AOP的一个成熟的开源框架：Aspects"><a href="#Part04-iOS实现AOP的一个成熟的开源框架：Aspects" class="headerlink" title="Part04- iOS实现AOP的一个成熟的开源框架：Aspects"></a>Part04- iOS实现AOP的一个成熟的开源框架：Aspects</h3><h4 id="Aspects的实现思路"><a href="#Aspects的实现思路" class="headerlink" title="Aspects的实现思路"></a>Aspects的实现思路</h4><p>Aspects是利用 oc 自己的消息转发机制进行转发，在解释这个过程之前，我们先看一下消息是怎么找到对应的IMP的<img src="week1501.jpg" alt="image"></p>
<p>从上面我们可以发现，在发消息的时候，如果 <code>selector</code> 有对应的 <code>IMP</code> ,则直接执行，如果没有，oc 给我们提供了几个可供补救的机会，依次有 <code>resolveInstanceMethod</code> 、<code>forwardingTargetForSelector</code>、<code>forwardInvocation</code>。Aspects 之所以选择在 <code>forwardInvocation</code>这里处理是因为，这几个阶段特性都不太一样：<code>resolvedInstanceMethod</code>适合给类/对象动态添加一个相应的实现，<code>forwardingTargetForSelector</code>适合将消息转发给其他对象处理,相对而言，<code>forwardInvocation</code> 是里面最灵活，最能符合需求的。因此 Aspects 的方案就是，对于待<code>hook</code> 的 <code>selector</code>，将其指向 <code>objc_msgForward / _objc_msgForward_stret</code>,同时生成一个新的 <code>aliasSelector</code> 指向原来的 <code>IMP</code>，并且 <code>hook</code> 住 <code>forwardInvocation</code> 函数，使他指向自己的实现。按照上面的思路，当被 <code>hook</code>的 <code>selector</code> 被执行的时候，首先根据 <code>selector</code>找到了<code>objc_msgForward / _objc_msgForward_stret</code>,而这个会触发消息转发，从而进入 <code>forwardInvocation</code>。同时由于 <code>forwardInvocation</code> 的指向也被修改了，因此会转入新的<code>forwardInvocation</code> 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的<code>IMP</code>。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>从头文件中可以看到使用aspects有两种使用方式：(1)类方法 ；(2)实例方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Adds a block of code before&#x2F;instead&#x2F;after the current &#96;selector&#96; for a specific instance.</span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(id)block</span><br><span class="line">                                 error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>两者的主要原理基本差不多，这里不做一一介绍，只是以实例方法为例进行说明。在介绍之前，先介绍里面几个重要的数据结构：</p>
<h5 id="AspectOptions"><a href="#AspectOptions" class="headerlink" title="AspectOptions"></a>AspectOptions</h5><p> block 执行的时机，也就是额外操作的执行时机，它可以在原始函数执行之前，也可以是执行之后，甚至可以完全替换掉原来的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class="line">    AspectPositionAfter   &#x3D; 0,            &#x2F;&#x2F;&#x2F; Called after the original implementation (default)</span><br><span class="line">    AspectPositionInstead &#x3D; 1,            &#x2F;&#x2F;&#x2F; Will replace the original implementation.</span><br><span class="line">    AspectPositionBefore  &#x3D; 2,            &#x2F;&#x2F;&#x2F; Called before the original implementation.</span><br><span class="line">    AspectOptionAutomaticRemoval &#x3D; 1 &lt;&lt; 3 &#x2F;&#x2F;&#x2F; Will remove the hook after the first execution.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h5><p>一个对象或者类的所有的 Aspects 整体情况:一个对象和类可能有多个Aspect，每个Aspect的执行的时机都是不一样的，AspectsContainer存储了这个类或对象全部的Aspect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Tracks all aspects for an object&#x2F;class.</span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@property (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@property (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@property (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h5><p>一个 Aspect 的具体内容，这里主要包含了单个的 aspect 的具体信息，包括执行时机，要执行 block 所需要用到的具体信息：包括方法签名、参数等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, strong) id block;</span><br><span class="line">@property (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line">@property (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h5><p>一个 Aspect 执行环境，主要是 NSInvocation 信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspctInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@property (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h4><p>有了上面的了解，我们就能更好的分析整个 apsects 的执行流程。添加一个 aspect 的关键流程如下图所示：</p>
<p><img src="week1502.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tatic id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __block AspectIdentifier *identifier &#x3D; nil;</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;&#x2F;&#x2F;1判断能否hook</span><br><span class="line">            ...&#x2F;&#x2F;2 记录数据结构</span><br><span class="line">            aspect_prepareClassAndHookSelector(self, selector, error);&#x2F;&#x2F;3 swizzling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断能否被-hook"><a href="#判断能否被-hook" class="headerlink" title="判断能否被 hook"></a>判断能否被 hook</h5><p>对于对象实例而言，这里主要是根据黑名单，比如 retain forwardInvocation 等这些方法在外部是不能被 hook ,(对于类对象还要确保同一个类继承关系层级中，只能被 hook 一次，因此这里需要判断子类，父类有没有被 hook，之所以做这样的实现，主要是为了避免出现死循环的出现，这里有相关的讨论)。如果能够 hook，则继续下面的步骤。</p>
<h5 id="swizzling-method"><a href="#swizzling-method" class="headerlink" title="swizzling method"></a>swizzling method</h5><p>这是真正的核心逻辑，<code>swizzling method</code>主要有两部分，一个是对对象的 <code>forwardInvocation</code>进行 <code>swizzling</code>,另一个是对传入的 <code>selector</code> 进行 <code>swizzling</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">    Class klass &#x3D; aspect_hookClass(self, error); &#x2F;&#x2F;1  swizzling forwardInvocation</span><br><span class="line">    Method targetMethod &#x3D; class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP &#x3D; method_getImplementation(targetMethod);</span><br><span class="line">    if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;&#x2F;&#x2F;2  swizzling method</span><br><span class="line">       ...&#x2F;&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="swizzling-forwardInvocation"><a href="#swizzling-forwardInvocation" class="headerlink" title="swizzling forwardInvocation:"></a>swizzling forwardInvocation:</h6><p><code>aspect_hookClass</code> 函数主要 <code>swizzling</code>类/对象的 <code>forwardInvocation</code> 函数，<code>aspects</code>的真正的处理逻辑都是在 <code>forwradInvocation</code> 函数里面进行的。对于对象实例而言，源代码中并没有直接 swizzling 对象的 <code>forwardInvocation</code>方法，而是动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的<code>forwardInvocation</code> 方法(这里具体方法就是调用了 <code>object_setClass(self, subclass)</code>,将当前对象 <code>isa</code>指针指向了<code>subclass</code> ,同时修改了<code>subclass</code>以及其 <code>subclass metaclass</code> 的 <code>class</code> 方法,使他返回当前对象的 <code>class</code>。它的原理有点类似 <code>kvo</code> 的实现，它想要实现的效果就是，将当前对象变成一个 <code>subclass</code> 的实例，同时对于外部使用者而言，又能把它继续当成原对象在使用，而且所有的 <code>swizzling</code>操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，也就是，当你在<code>remove aspects</code>的时候，如果发现当前对象的 <code>aspect</code> 都被移除了，那么，你可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 <code>swizzling</code> ,同时也不会影响到其他该类的不同对象)。对于每一个对象而言，这样的动态对象只会生成一次，这里<code>aspect_swizzlingForwardInvocation</code>将使得 <code>forwardInvocation</code> 方法指向 <code>aspects</code>自己的实现逻辑 ,具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;</span><br><span class="line">     ...</span><br><span class="line">     &#x2F;&#x2F;生成动态子类，并swizzling forwardInvocation方法</span><br><span class="line">     subclass &#x3D; objc_allocateClassPair(baseClass, subclassName, 0); </span><br><span class="line">     aspect_swizzleForwardInvocation(subclass);&#x2F;&#x2F;swizzling forwardinvation方法</span><br><span class="line">     objc_registerClassPair(subclass);</span><br><span class="line">      ...</span><br><span class="line">     object_setClass(self, subclass);&#x2F;&#x2F;将当前self设置为子类，这里其实只是更改了self的isa指针而已</span><br><span class="line">     return subclass;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">     ...</span><br><span class="line">    IMP originalImplementation &#x3D; class_replaceMethod(klass, @selector(forwardInvocation:),     (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">         class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName),        originalImplementation, &quot;v@:@&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于子类本身并没有实现 <code>forwardInvocation</code> ，隐藏返回的 <code>originalImplementation</code> 将为空值，所以也不会生成 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName)</code>。</p>
<h6 id="swizzling-selector"><a href="#swizzling-selector" class="headerlink" title="swizzling selector"></a>swizzling selector</h6><p>当 <code>forwradInvocation</code> 被<code>hook</code>之后，接下来，将对传入的<code>selector</code>进行<code>hook</code> ，这里的做法是，将<code>selector</code> 指向了转发 <code>IMP</code>，同时生成一个 <code>aliasSelector</code> ，指向了原来的<code>IMP</code>,同时为防止重复<code>hook</code> ,做了一个判断，如果发现 <code>selector</code> 已经指向了转发<code>IMP</code> ,那就就不需要进行交换了，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tatic void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;</span><br><span class="line">     ...</span><br><span class="line">     Method targetMethod &#x3D; class_getInstanceMethod(klass, selector);</span><br><span class="line">     IMP targetMethodIMP &#x3D; method_getImplementation(targetMethod);</span><br><span class="line">     if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">     ...</span><br><span class="line">     SEL aliasSelector &#x3D; aspect_aliasForSelector(selector);&#x2F;&#x2F;generator aliasSelector</span><br><span class="line">     if (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">          __unused BOOL addedAlias &#x3D; class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); </span><br><span class="line">     &#125;</span><br><span class="line">     class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);&#x2F;&#x2F; point to   _objc_msgForward</span><br><span class="line">   ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="handle-ForwardInvocation"><a href="#handle-ForwardInvocation" class="headerlink" title="handle ForwardInvocation"></a>handle ForwardInvocation</h6><p>基于上面的代码分析知道，转发最终的逻辑代码最终转入 <code>__ASPECTS_ARE_BEING_CALLED__</code> 函数的处理中。这里，需要处理的部分包括额外处理代码（如打点代码）以及最终重新转会原来的<code>selector</code>所指向的函数，其实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123;</span><br><span class="line">...</span><br><span class="line">     &#x2F;&#x2F; Before hooks.  原来逻辑之前执行</span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line">    &#x2F;&#x2F; Instead hooks.</span><br><span class="line">    BOOL respondsToAlias &#x3D; YES;</span><br><span class="line">    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;&#x2F;&#x2F;是否需要替换掉原来的路基</span><br><span class="line">         aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">         aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Class klass &#x3D; object_getClass(invocation.target);</span><br><span class="line">        do &#123;</span><br><span class="line">              if ((respondsToAlias &#x3D; [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                    [invocation invoke];&#x2F;&#x2F;根据aliasSelector找到原来的逻辑并执行</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;while (!respondsToAlias &amp;&amp; (klass &#x3D; class_getSuperclass(klass)));</span><br><span class="line">     &#125;</span><br><span class="line">    &#x2F;&#x2F; After hooks.  原来逻辑之后执行</span><br><span class="line">     aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">     aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line">    &#x2F;&#x2F; If no hooks are installed, call original implementation (usually to throw an exception)</span><br><span class="line">     if (!respondsToAlias) &#123;&#x2F;&#x2F;找不到aliasSelector的IMP实现，没有找到原来的逻辑，进行消息转发</span><br><span class="line">          invocation.selector &#x3D; originalSelector;</span><br><span class="line">          SEL originalForwardInvocationSEL &#x3D; NSSelectorFromString(AspectsForwardInvocationSelectorName);</span><br><span class="line">          if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">               ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              [self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;                     </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次处理 <code>before/instead/after hook</code> 以及真正函数实现。如果没有找到原始的函数实现，还需要进行转发操作。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">面向切面编程之 Aspects 源码解析及应用</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>以技术之名周报02#X86-汇编| 2020-04-05</title>
    <url>/2020/04/02/week14/</url>
    <content><![CDATA[<h4 id="Part01-知识准备"><a href="#Part01-知识准备" class="headerlink" title="Part01 - 知识准备"></a>Part01 - 知识准备</h4><p>在介绍汇编之前，我们首先应该搞清楚什么是机器语言？什么是汇编语言？什么是高级语言？</p>
<p><strong>机器语言：</strong></p>
<blockquote>
<p>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合。</p>
</blockquote>
<p><strong>汇编语言：</strong></p>
<blockquote>
<p>汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。</p>
</blockquote>
<p><strong>高级语言:</strong></p>
<blockquote>
<p>高级编程语言是高度封装了的编程语言，与低级语言相对。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。比如：C、C++、Swift、Java…</p>
</blockquote>
<p>用一张图来解释这三种语言之间的关系：</p>
<p><img src="Assembly01.png" alt="image"></p>
<h4 id="Part02-编译器：LLVM"><a href="#Part02-编译器：LLVM" class="headerlink" title="Part02 - 编译器：LLVM"></a>Part02 - 编译器：LLVM</h4><p>汇编严重依赖硬件设备, <code>iOS</code>模拟器使用<code>AT&amp;T</code>格式汇编(因为 <code>Mac</code> 是基于 <code>Unix</code> 开发的), <code>iOS</code> 真机使用ARM汇编<br>。</p>
<p><code>Xcode</code>内置的编译器是<code>LLVM</code>，<code>LLVM</code> 是一个著名的编译器, 由大神 <code>Chris Lattner</code>开发, 可用于常规编译器, JIT编译器, 汇编器, 调试器, 静态分析工具等一系列跟编程语言相关的工作。</p>
<h5 id="LLVM-的编译架构分为三个阶段"><a href="#LLVM-的编译架构分为三个阶段" class="headerlink" title="LLVM 的编译架构分为三个阶段"></a>LLVM 的编译架构分为三个阶段</h5><ol>
<li>前端：进行语法分析, 语义分析, 生成中间代码。实际上在 Xcode 中写代码的时候会实时提示错误就是因为持续在调用 LLVM 的前端部分</li>
<li>公用优化器：将生成的中间文件进行优化, 去除冗余代码, 进行结构优化。</li>
<li>后端：将优化后的中间代码再次转换, 变为汇编语言, 再次进行优化. 最后将各个文件代码转换为二进制代码(机器语言)并链接以生成一个可执行文件。</li>
</ol>
<h5 id="LLVM-架构的优点"><a href="#LLVM-架构的优点" class="headerlink" title="LLVM 架构的优点"></a>LLVM 架构的优点</h5><ol>
<li>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</li>
<li>如果需要支持一种新的编程语言, 那么只需要实现一个新的前端(Swift 就是新增了一个针对于 Swift 的前端)</li>
<li>如果需要支持一种新的硬件设备, 那么只需要实现一个新的后端</li>
<li>优化阶段是一个通用的阶段, 它针对的是统一的LLVM IR, 不论是支持新的编程语言, 还是支持新的硬件设备, 都不需要对优化阶段做修改</li>
<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族, Java, .NET, Python, Ruby, Scheme, Haskell, D等)</li>
</ol>
<p><img src="Assembly02.png" alt="image"></p>
<h4 id="Part03-汇编语言种类及选择："><a href="#Part03-汇编语言种类及选择：" class="headerlink" title="Part03 - 汇编语言种类及选择："></a>Part03 - 汇编语言种类及选择：</h4><h5 id="汇编语言种类"><a href="#汇编语言种类" class="headerlink" title="汇编语言种类"></a>汇编语言种类</h5><ol>
<li><code>AT&amp;T</code>格式(<code>UNIX</code>, <code>MAC</code>阵营):<code>8086</code>汇编(16bit 架构)<code>x64</code>汇编(64bit 架构)</li>
<li><code>Intel</code>格式(WIN阵营): <code>x86</code>汇编(32bit 架构)</li>
<li><code>ARM</code> 格式 (移动设备阵营): 只用在 <code>arm</code>处理器上</li>
</ol>
<h5 id="汇编语言选择"><a href="#汇编语言选择" class="headerlink" title="汇编语言选择"></a>汇编语言选择</h5><p>虽然不同的架构对应着不同的汇编语言，但是原理基本上是一样的，为了调试方便，我们将以X86-64架构来探究Swift中函数调用的本质。</p>
<h4 id="Part04-AT-amp-T汇编"><a href="#Part04-AT-amp-T汇编" class="headerlink" title="Part04 - AT&amp;T汇编"></a>Part04 - AT&amp;T汇编</h4><h5 id="寄存器和数据类型"><a href="#寄存器和数据类型" class="headerlink" title="寄存器和数据类型"></a>寄存器和数据类型</h5><p>X86-64有16个通用(几乎都是通用的)64位整数寄存器：</p>
<table>
<thead>
<tr>
<th>%rax</th>
<th>%rbx</th>
<th>%rcx</th>
<th>%rdx</th>
<th>%rsi</th>
<th>%rdi</th>
<th>%rbp</th>
<th>%rsp</th>
<th>%r8</th>
<th>%r9</th>
<th>%r10</th>
<th>%r11</th>
<th>%r12</th>
<th>%r13</th>
<th>%r14</th>
<th>%r15</th>
</tr>
</thead>
</table>
<p>因为早期处理器的不同寄存器的用途不同，并不是所有的指令都可以应用于每个寄存器。（现在基本上都是通用寄存器了）随着设计的发展，增加了新的指令和寻址模式，使各种寄存器几乎相等。除了几条特殊的指令，比如与字符串处理有关的指令，需要使用％rsi和％rdi，另外，还有两个寄存器保留用作堆栈指针（％rsp）和基址指针（％rbp）。最后的八个被编号的寄存器没有特别的限制。除此之外还有一个特殊的寄存器%rip(instruction pointer)，一般情况下你不需要关注这个寄存器,但是这个寄存器很重要，你需要知道他的功能，后面在说函数调用时会提及。</p>
<p>多年来X86架构已经从8位扩展到了32位，因此每个寄存器都有一些内部结构如下图：<br><img src="Assembly03.png" alt="image"></p>
<h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>什么是寻址模式？就是数据在内存寄和寄存器之间进行移动时，取得数据地址的不同表达方式。最常用的寻址的汇编指令是mov。x86-64使用的是复杂指令集(cisc)，因此mov有许多不同的变体，可以在不同单元之间移动不同类型的据。mov与大多数指令一样，具有单字母后缀，用于确定要移动的数据量。下表用于描述各种大小的数据值：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>全称</th>
<th>Size</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>1byte(8 bits)</td>
</tr>
<tr>
<td>W</td>
<td>word</td>
<td>2byte(16 bits)</td>
</tr>
<tr>
<td>L</td>
<td>long</td>
<td>4byte(32 bits)</td>
</tr>
<tr>
<td>Q</td>
<td>quadword</td>
<td>8byte(64 bits)</td>
</tr>
</tbody></table>
<p><code>MOVB</code>移动一个字节，<code>MOVW</code>移动一个字，<code>MOVL</code>移动一个长整形，<code>MOVQ</code>移动一个四字。一般来说，<code>MOV</code>指令移动数据的大小必须与后缀匹配。虽然可以忽略后缀，汇编器将尝试根据参数选择合适的<code>MOV</code>指令。但是，不推荐这样做，因为它可能会造成预料之外的结果。</p>
<p>对于<code>AT&amp;T</code>语法使用<code>MOV</code>寻址时需要两个参数，第一个参数是<code>源地址</code>，第二个参数是<code>目标地址</code>。<code>原地址</code>的表达方式不一样那么寻址的方式也就不一样。比如，访问全局变量使用一个简单变量的名称比如<code>x</code>，我们称之为全局符号寻址。<code>printf</code>一个整数常量，由美元符号+数值表示(例如<code>$ 56</code>)，我们称之为直接寻址。访问寄存器的值直接使用寄存器的名字如  <code>%rbx</code>，我们称之为寄存器寻址。如果寄存器中存放的是一个地址，访问这个地址中的数据时需要在寄存器外面加上括号如<code>(%rbx)</code>，我们称之为间接寻址。如果寄存器中存放的是一个数组的地址，我们需要访问数组中的元素时可能需要操作这个地址进行偏移，如<code>8(％rcx）</code>是指<code>％rcx</code>中存放的的地址加<code>8</code>字节存储单元的值，我们称之为相对基址寻址（此模式对于操作堆栈，局部变量和函数参数非常重要）。在相对基址寻址上有各种复杂的变化，例如<code>-16（％rbx，％rcx，8</code>）是指地址<code>-16 +％rbx +％rcx * 8</code>处的值。此模式对于访问排列在数组中的特殊大小的元素非常有用。</p>
<p>以下是使用各种寻址模式将64位值加载到％rax的示例：</p>
<table>
<thead>
<tr>
<th>寻址模式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>全局符号寻址(Global Symbol)</td>
<td>MOVQ x, %rax</td>
</tr>
<tr>
<td>直接寻址(Immediate)</td>
<td>MOVQ $56, %rax</td>
</tr>
<tr>
<td>寄存器寻址(Register)</td>
<td>MOVQ %rbx, %rax</td>
</tr>
<tr>
<td>间接寻址(Indirect)</td>
<td>MOVQ (%rsp), %rax</td>
</tr>
<tr>
<td>相对基址寻址(Base-Relative)</td>
<td>MOVQ -8(%rbp), %rax</td>
</tr>
<tr>
<td>相对基址偏移缩放寻址(Offset-Scaled-Base-Relative)</td>
<td>MOVQ -16(%rbx,%rcx,8), %rax</td>
</tr>
</tbody></table>
<p>通常，可以使用相同的寻址模式将数据存储到寄存器和内存。但是，并不是所有模式都支持。比如不能对<code>MOV</code>的两个参数都使用<code>base-relative mode</code>。像<code>MOVQ -8（％rbx</code>），<code>-8（％rbx</code>）这样是不行的。要准确查看支持哪些寻址模式组合，您必须阅读相关指令的手册。</p>
<h5 id="基础运算指令"><a href="#基础运算指令" class="headerlink" title="基础运算指令"></a>基础运算指令</h5><p>编译器需要四个基本的算术指令： <code>ADD</code>, <code>SUB</code>, <code>IMUL</code>, 和<code>IDIV</code>(加减乘除)。<code>add</code>和<code>sub</code>有两个操作数：一个来源值和一个被操作数。例如，这条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addq %rbx, %rax</span><br></pre></td></tr></table></figure>

<p>将<code>％rbx</code>添加到<code>％rax</code>，并将结果放在<code>％rax</code>中，覆盖之前可能存在的内容。这就要求你在使用寄存器时要小心。 例如，假设你想计算 <code>c = b *（b + a）</code>，其中a和b是全局整数。要做到这一点，你必须小心，在执行加法时不要覆盖b的值。这里有一个实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq  a, %rax</span><br><span class="line">movq  b, %rbx</span><br><span class="line">addq  %rbx, %rax</span><br><span class="line">imulq %rbx</span><br><span class="line">movq  %rax, c</span><br></pre></td></tr></table></figure>
<p><code>imul</code>指令有点不太一样：它将其参数乘以<code>％rax</code>的内容，然后将结果的低64位放入<code>％rax</code>，将高64位放入<code>％rdx</code>。（将两个64位数字相乘会产生一个128位数字。）</p>
<p><code>idiv</code>指令和乘法指令差不多：它以一个128位整数值开始，其低64位位于<code>％rax</code>，高位64位位于<code>％rdx</code>中，并将其除以参数。<code>（CDQO</code>指令用于将<code>％rax</code>符号扩展为<code>％rdx</code>，以便正确处理负值。）商被放在<code>％rax</code>中，余数放在<code>％rdx</code>中。例如，除以5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq a,  %rax    # set the low 64 bits of the dividend</span><br><span class="line">cdqo             # sign-extend %rax into %rdx</span><br><span class="line">idivq $5</span><br></pre></td></tr></table></figure>

<p>大多数语言中的求模指令只是利用<code>％rdx</code>中剩余的余数,指令<code>INC</code>和<code>DEC</code>分别递增和递减寄存器。例如，语句<code>a = ++ b</code>可以翻译为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq b, %rax</span><br><span class="line">incq %rax</span><br><span class="line">movq %rax, a</span><br></pre></td></tr></table></figure>
<p>布尔操作的工作方式非常类似：AND，OR，和XOR指令需要两个参数，而NOT指令只需要一个参数。像MOV指令一样，各种算术指令可以在各种寻址模式下工作。但是，您可能会发现使用MOV将值载入和载出寄存器是最方便的，然后仅使用寄存器来执行算术运算。</p>
<h5 id="比较和跳转指令"><a href="#比较和跳转指令" class="headerlink" title="比较和跳转指令"></a>比较和跳转指令</h5><p>使用<code>JMP</code>指令，我们可以创建一个简单的无限循环，使用<code>％eax</code>寄存器从零开始计数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">    incq %rax</span><br><span class="line">    jmp loop</span><br></pre></td></tr></table></figure>

<p>为了定义更有用的程序结构，如终止循环和<code>if-then</code>等语句，我们必须有一个可以改变程序流程的机制。在大多数汇编语言中，这些处理由两种不同的指令处理：比较和跳转。<br>所有的比较都是通过<code>CMP</code>指令完成的。<code>CMP</code>比较两个不同的寄存器，然后在内部<code>EFLAGS</code>寄存器中设置几个位，记录这些值是相同，更大还是更小。你不需要直接看<code>EFLAGS</code>寄存器的值。而是根据结果的不同来做适当的跳转：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>如果大于则跳转</td>
</tr>
<tr>
<td>jne</td>
<td>如果不等于则跳转</td>
</tr>
<tr>
<td>jl</td>
<td>如果小于则跳转</td>
</tr>
<tr>
<td>jle</td>
<td>如果小于等于则跳转</td>
</tr>
<tr>
<td>jg</td>
<td>如果大于则跳转</td>
</tr>
<tr>
<td>jge</td>
<td>如果大于等于则跳转</td>
</tr>
</tbody></table>
<p>举个例子，这里是一个循环来使<code>％rax</code>从0到5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">        incq %rax</span><br><span class="line">        cmpq $5, %rax</span><br><span class="line">        jle  loop</span><br></pre></td></tr></table></figure>

<p>再举个例子，一个条件赋值：如果全局变量x&gt;=0，那么全局变量y=10，否则 y=20：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        movq x, %rax</span><br><span class="line">        cmpq $0, %rax</span><br><span class="line">        jle  twenty</span><br><span class="line">ten:</span><br><span class="line">        movq $10, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">twenty:</span><br><span class="line">        movq $20, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">done:</span><br><span class="line">        movq %ebx, y</span><br></pre></td></tr></table></figure>

<p>跳转的参数是目标标签。这些标签在一个汇编文件中必须是唯一且私密的，除了包含在.globl内的标签 ，其他标签不能在文件外部看到，也就是不能在文件外调用。用c语言来说，一个普通的汇编标签是static的，而.globl标签是extern</p>
<h6 id="其他常用寄存器指令"><a href="#其他常用寄存器指令" class="headerlink" title="其他常用寄存器指令"></a>其他常用寄存器指令</h6><ul>
<li><code>leaq %rbp,%rax</code>: 内存赋值 <code>lea</code>, 将 <code>rbq</code> 的内存地址值赋给 <code>rax</code></li>
<li><code>xorl %eax, %eax</code>: 异或<code>xor</code>, 将 <code>eax</code>清 <code>0</code>, 自己异或自己</li>
<li><code>jmp 0x80001</code>: 跳转 <code>jmp</code>, 跳转到函数地址为 <code>0x80001</code> 的地址</li>
<li><code>jmp *(%rax)</code>: 间接跳转<code>*()</code>, <code>rax</code> 是个内存地址,<code>*(rax)</code>是拿到<code>rax</code> 地址里的值</li>
<li><code>callq 0x80001</code>: 函数调用<code>call</code>, 调用地址为<code>0x80001</code> 的函数, 一般配合 <code>retq</code></li>
</ul>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈是一种辅助数据结构，主要用于记录程序的函数调用历史记录以及不适合寄存器的局部变量。栈从高地址向低地址增长。<code>％rsp</code>寄存器被称为<code>“栈指针”</code>并跟踪堆栈中最底层(也就是最新的)的数据。因此，要将<code>％rax</code>压入堆栈，我们必须从<code>％rsp</code>中减去<code>8（％rax</code>的大小，以字节为单位），然后写入<code>％rsp</code>指向的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subq $8, %rsp</span><br><span class="line">movq %rax, (%rsp)</span><br></pre></td></tr></table></figure>

<p>从栈中弹出一个值与上面的操作相反：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq (%rsp), %rax</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>

<p>从栈中丢弃最新的值，只需移动堆栈指针即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>

<p>当然，压栈(入栈)或出栈是经常使用到的操作，所以都有简化的单条指令，其行为与上面的完全一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq %rax</span><br><span class="line">popq  %rax</span><br></pre></td></tr></table></figure>


<h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>所有c标准库中可用的函数也可以在汇编语言程序中使用。以一种称为“调用约定”的标准方式调用，以便用多种语言编写的代码都可以链接在一起。<br>在x86 32位机器中。调用约定只是将每个参数入栈，然后调用该函数。被调用函数在栈中查找参数，完成它的工作之后，将结果存储到单个寄存器中。然后调用者弹出栈中的参数。<br>Linux上x86-64使用的调用约定有所不同，称之为System V ABI。完整的约定相当复杂，但以下是对我们来说足够简单的解释：</p>
<ul>
<li>整数参数（包括指针）按顺序放在寄存器％rdi，％rsi，％rdx，％rcx，％r8和％r9中。</li>
<li>浮点参数按顺序放置在寄存器％xmm0-％xmm7中。</li>
<li>超过可用寄存器的参数被压入栈。</li>
<li>如果函数使用可变数量的参数（如printf），那么必须将％eax寄存器设置为浮点参数的数量。</li>
<li>被调用的函数可以使用任何寄存器，但如果它们发生了变化，则必须恢复寄存器％rbx，％rbp，％rsp和％r12-％r15的值。</li>
<li>函数的返回值存储在％eax中。</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>用途</th>
<th>是否需要保存</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>保存返回结果</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rbx</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>参数4</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rdx</td>
<td>参数3</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rsi</td>
<td>参数2</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rdi</td>
<td>参数1</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rbp</td>
<td>栈基址指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>栈指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r8</td>
<td>参数5</td>
<td>无需保存</td>
</tr>
<tr>
<td>%r9</td>
<td>参数6</td>
<td>无需保存</td>
</tr>
<tr>
<td>%r10</td>
<td>-</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>-</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>每个函数都需要使用一系列寄存器来执行计算。然而，当一个函数被另一个函数调用时会发生什么？我们不希望调用者当前使用的任何寄存器被调用的函数破坏。为了防止这种情况发生，每个函数必须保存并恢复它使用的所有寄存器，方法是先将它们入栈，然后在返回之前将它们从堆栈弹出。在函数调用的过程中，栈基址指针<code>%rbp</code>始终指向当前函数调用开始时栈的位置，栈指针<code>%rsp</code>始终指向栈中最新的元素对应的位置。<code>%rbp</code>和<code>%rsp</code>之间的元素被我们成为<code>&quot;栈帧&quot;</code>，也叫<code>&quot;活动记录&quot;</code>。函数的调用过程其实就是栈帧被创建，扩张然后被销毁的过程。在说明函数调用流程前，我们不得不提到<code>%rip(instruction pointer)</code> 指令指针寄存器。<code>%rip</code>中存放的是CPU需要执行的下一条指令的地址。每当执行完一条指令之后，这个寄存器会自动增加(可以这样理解)以便指向新的指令的地址。有了这些基础，接下来我们以一段完整的程序代码来解释函数的调用流程，有下面一段c代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x &#x3D; sum(1, 2);</span><br><span class="line">    printf(&quot;result is:%d\n&quot;, x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为汇编代码之后，为了方便读代码，我们去除一些不需要的指示段之后得到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.file   &quot;main.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  sum</span><br><span class="line">    .type   sum, @function</span><br><span class="line">sum:</span><br><span class="line">.LFB0:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %edx</span><br><span class="line">    movl    -8(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   sum, .-sum</span><br><span class="line">    .section    .rodata</span><br><span class="line">.LC0:</span><br><span class="line">    .string &quot;result is:%d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $2, %esi</span><br><span class="line">    movl    $1, %edi</span><br><span class="line">    call    sum</span><br><span class="line">    movl    %eax, -4(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>我们知道linux系统中<code>main</code>函数是由glibc中的 <code>exec()</code>簇 函数调用的，比如我们从shell环境中启动程序最终就是由 <code>execvp()</code>调用而来。我们这里不展开说明，你只需要知道<code>main</code>函数其实也是被调用的函数。我们从<code>main</code>函数的第一条指令开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br></pre></td></tr></table></figure>
<p>首先，将当前的栈基址指针%rbp入栈，函数调用结束后我们就可以从栈中取得函数调用前%rbp指向的位置，进而恢复栈到之前的样子。然后使当前栈指针指向新的位置。然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subq    $16, %rsp</span><br><span class="line">movl    $2, %esi</span><br><span class="line">movl    $1, %edi</span><br></pre></td></tr></table></figure>

<p>在栈上申请16字节的空间以便存放后面的临时变量x，然后根据System V ABI的调用约定将传递给sum函数的参数放入%esi和%edi中(因为是int类型占用4个字节，所以只需要用寄存器的低4字节即可)。这里你可能会发现编译器没有将需要调用者保存的%r10和%r11入栈，因为编译器知道在main函数中不会使用到%r10和%r11寄存器所以无需保存。然后发出调用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call sum</span><br></pre></td></tr></table></figure>
<p>需要注意以上的CALL指令等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq %rip</span><br><span class="line">jmp sum</span><br></pre></td></tr></table></figure>
<p>我们把<code>%rip</code>当前的内容放入栈中，以便函数<code>sum</code>调用结束我们可以知道接下来该执行哪条指令，我们假设栈从<code>0xC0000000</code>处开始向低处延伸。到这个阶段栈的变化过程如下所示：</p>
<p><img src="Assembly04.png" alt="image"></p>
<p>现在程序跳转到sum处执行计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">movl    %edi, -4(%rbp)</span><br><span class="line">movl    %esi, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %edx</span><br><span class="line">movl    -8(%rbp), %eax</span><br><span class="line">addl    %edx, %eax</span><br></pre></td></tr></table></figure>

<p>和<code>main</code>函数被调用一样，<code>sum</code>函数被调用时，首先也是保存<code>%rbp</code>，然后更新栈指针<code>%rsp</code>，将两个参数拷贝到栈中进行使用。在这里你可能看到了和<code>main</code> 函数不一样的地方，局部变量保存在栈中并没有像main函数中那样引起<code>%rsp</code>的移动(对比<code>main</code>函数中的<code>SUBQ 16</code>)。是因为编译器知道sum中不会再调用其它函数，也就不用保存数据到栈中了，直接使用栈空间即可。所以就无需位移<code>%rsp</code>。计算完成后结果保存在<code>%eax</code>中，现在我们更新一下栈的变化：</p>
<p><img src="Assembly05.png" alt="image"></p>
<p>然后返回到main函数时执行了如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popq    %rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>先恢复调用前的栈基址指针%rbp，然后此时栈顶的元素就是函数调用之后需要执行的下一条指令的地址，RET指令等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popq    %rip</span><br></pre></td></tr></table></figure>

<p>这样就可以跳转到函数结束后的下一条指令 “movl %eax, -4(%rbp)”处继续执行,至此我们看一下完整调用过程中栈的变化：</p>
<p><img src="Assembly06.png" alt="image"></p>
<p>更多关于寄存器的知识可以看<a href="https://nifengz.com/introduction_x64_assembly/" target="_blank" rel="noopener">这篇博客</a>,讲的更加详细</p>
<h4 id="Part05-LLDB常用指令"><a href="#Part05-LLDB常用指令" class="headerlink" title="Part05 - LLDB常用指令"></a>Part05 - LLDB常用指令</h4><p>了解了汇编的基本指令时候，我们需要再了解在Xcode中如何使用LLDB指令来调试汇编代码</p>
<ul>
<li>读取寄存器的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">register read&#x2F; </span><br><span class="line">&#x2F;*例*&#x2F;POPQ  %rax</span><br><span class="line">register read&#x2F;x rax    &#x2F;&#x2F; 读取寄存器 rax 里面的值，&#x2F;后面的参数为进制：x:16 进制,f: 浮点,d:10 进制</span><br></pre></td></tr></table></figure>
<ul>
<li>修改寄存器的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">register write</span><br><span class="line">&#x2F;*例*&#x2F;</span><br><span class="line">register write rax 4 &#x2F;&#x2F; 将rax修改为 4</span><br></pre></td></tr></table></figure>
<ul>
<li>读取内存中的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x2F;数量-格式-字节大小</span><br><span class="line"></span><br><span class="line">&#x2F;*例*&#x2F;</span><br><span class="line"></span><br><span class="line">x&#x2F;4xg 0x1000002</span><br><span class="line">&#x2F;&#x2F; 将 0x1000002 地址的值, 以 8 个字节的格式, 分成 4 份, 16 进制 展示</span><br></pre></td></tr></table></figure>
<ul>
<li>修改内存中的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory write 内存地址 数值</span><br><span class="line"></span><br><span class="line">&#x2F;*例*&#x2F;</span><br><span class="line"></span><br><span class="line">memory write  0x1000002 10</span><br></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x 是十六进制，f是浮点，d是十进制，</span><br></pre></td></tr></table></figure>

<ul>
<li>字节大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b - byte 1 字节</span><br><span class="line">h - half word 2 字节</span><br><span class="line">w - word 4 字节</span><br><span class="line">g - giant word 8 字节</span><br></pre></td></tr></table></figure>

<ul>
<li>单步运行，把子函数当作一个整体，一步执行（源码级别）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-over、next、n</span><br></pre></td></tr></table></figure>
<ul>
<li>单步运行，遇到子函数会进入子函数(源码级别)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-in 、 step、s</span><br></pre></td></tr></table></figure>
<ul>
<li>单步运行，把子函数当作一个整体一步执行（汇编级别）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-inst-over 、 nexti、ni</span><br></pre></td></tr></table></figure>

<ul>
<li>单步运行，遇到子函数会进入子函数（汇编级别）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-inst 、 stepi、si</span><br></pre></td></tr></table></figure>
<ul>
<li>直接执行完当前函数的所有代码，返回上一个函数（遇到断点会卡住）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-out 、finish</span><br></pre></td></tr></table></figure>

<h4 id="Part06-Swift汇编例子"><a href="#Part06-Swift汇编例子" class="headerlink" title="Part06 - Swift汇编例子"></a>Part06 - Swift汇编例子</h4><ol>
<li>新建一个<code>Command Line Tool</code>工程，并在<code>main.swift</code>文件中新建一个<code>sum</code>函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func sum( a: Int, b: Int) -&gt; Int&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Xcode</code>进入汇编调试模式，并在<code>main</code>函数中调用<code>sum</code>函数</li>
</ol>
<p><img src="Assembly07.png" alt="image"></p>
<p>3.在<code>main</code>函数中，调用<code>sum</code>函数，在调用<code>sum</code>函数地方打断点</p>
<p><img src="Assembly08.png" alt="image"></p>
<p>4.通过在控制台执行 <code>n</code>指令，可以定位到第11行,执行<code>si</code>指令可以进入<code>sum</code>函数，在<code>sum</code>函数中，我们可以看到最终通过<code>%rdx</code>和<code>%rcx</code>完成累加，并最终将值放如<code>%rax</code>寄存器，作为函数返回值<br><img src="Assembly09.png" alt="image"></p>
<h4 id="Part07-参考"><a href="#Part07-参考" class="headerlink" title="Part07 - 参考"></a>Part07 - 参考</h4><p><a href="https://nifengz.com/introduction_x64_assembly/" target="_blank" rel="noopener">x86-64汇编入门
</a></p>
<p><a href="https://hanleylee.com/compile-of-ios-project.html" target="_blank" rel="noopener">iOS 之编译</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27339191" target="_blank" rel="noopener">x86-64 下函数调用及栈帧原理</a></p>
<p><a href="https://juejin.im/post/5ddf66385188256e855b6e0c" target="_blank" rel="noopener">从 简单汇编基础 到 Swift 不简单的 a + 1</a></p>
]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>以技术之名周报01#开篇| 2020-03-29</title>
    <url>/2020/03/29/week13/</url>
    <content><![CDATA[<h5 id="为什么要写博客？"><a href="#为什么要写博客？" class="headerlink" title="为什么要写博客？"></a>为什么要写博客？</h5><p>写博客是一个输出和分享的过程，将会对博主本人和读者产生积极的影响。为了保证输出对读者存在价值，首先需要确保博客内容的准确性，即不要输出错误的内容误导读者；要保证博客内容的逻辑性，即会使让读者读起来有云里雾里的感觉。为了达到这样的效果，就要求博主对分享的知识有足够深刻的理解，并能够转化为自己的语言分享出来。高质量的博客，对博主和读者而言，是一种双赢的结果。</p>
<h5 id="为什么没有养成持续以恒的习惯？"><a href="#为什么没有养成持续以恒的习惯？" class="headerlink" title="为什么没有养成持续以恒的习惯？"></a>为什么没有养成持续以恒的习惯？</h5><p>工作四年半的时间，写博客一直以来都处于养鱼的状态，没有养成持之以恒的习惯，非常惭愧。除了开始工作的那段时间有比较高的热情，接下来的几年基本放弃，总结下来，大概有下面几点原因：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 刚开始工作，出生牛犊不怕虎，不怕嘲笑。工作一段时间，深感技术不足，以后畏首畏尾。</li>
<li><input checked="" disabled="" type="checkbox"> 博客搭建成本有点高，更换电脑之后，需要重新搭建，怕麻烦，一直拖着没做</li>
<li><input checked="" disabled="" type="checkbox"> 在不同的公司，工作强度和方向不一样，在比较忙、没有值得分享的技术点的情况下没有分享的精力和动力</li>
<li><input checked="" disabled="" type="checkbox"> 学习的热情没有持续，没有输入很难保持产出</li>
<li><input checked="" disabled="" type="checkbox"> 深入思考的时候太少，面向谷歌和百度开发一度程度扼杀人思考的能力</li>
</ul>
<h5 id="如何改进？"><a href="#如何改进？" class="headerlink" title="如何改进？"></a>如何改进？</h5><ul>
<li><input checked="" disabled="" type="checkbox"> 搭建好新的博客，做好博客的版本管理，搭建好博客不要随便改动博客配置，须知博客的本质重在内容而不是花里胡哨的样式，切勿本末倒置</li>
<li><input checked="" disabled="" type="checkbox"> 强制自己写博客，以至少每周一篇周报的频率写技术分享，倒逼自己在工作中寻找值得分享的知识点</li>
<li><input checked="" disabled="" type="checkbox"> 保持持续学习的习惯，不断更新自己的知识栈</li>
<li><input checked="" disabled="" type="checkbox"> 减少面向百度、谷歌开发，多思考，深入思考，探索本质</li>
</ul>
<h5 id="写在开篇-题外话"><a href="#写在开篇-题外话" class="headerlink" title="写在开篇-题外话"></a>写在开篇-题外话</h5><p>2020年是不同寻常的一年，战争、蝗灾、粮食危机、新型冠状肺炎…天灾人祸似乎要在这一年集中爆发，极大的考验各个国家面危机的能力。全世界现在一片混乱，人道主义危机轮番上演，西方世界逐渐撕掉文明的面具，暴露出强盗的本性。而在过去的两个多月，全国人民在党的带领下众志成城，付出了极大代价，艰难战胜了新冠肺炎，逐渐复工复产。然而面对动荡的世界，中国无法独善其身，不断向其他国家援助医疗物资、派遣医疗专家，开启支援全世界的模式。在中国逐渐展现出世界领袖气质的同时，大洋彼岸的现任世界领袖在特朗普的带领下，开启了一连串迷之操作，迅速将美国带入新冠肺炎的震中。为了挽救股票市场，美国将基准利率降到0，并开启无限QE，疯狂印钞2万亿美元大放水。这次疫情也许会加速新一轮的经济危机的到来，到时候将会出现大量公司倒闭，无数工薪族面临裁员。我们要做的是：做最坏的打算，抱最大的希望，不断的提升自己技术能力，确保自己在经济大萧条的时候保持足够的竞争力，将危机对自己的影响降到最低。希望各位共勉！</p>
<h5 id="说点开心的"><a href="#说点开心的" class="headerlink" title="说点开心的"></a>说点开心的</h5><p>从1.29号到北京，到现在整整两个月，除了家和公司两个地方，其他地方都没有去过，像我这样的自认为很能宅的人都快憋坏了。因为之前答应帮同学买药，就趁着这大好春光去了趟北京协和医院，正好放放风、撒撒野。虽然因为上班时间原因药没有买成，但是发现协和医院附近四合院景色不错，和大家分享一下，就放在文章最后了。</p>
<h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>第一周周报，就是想和大家分享下自己的想法，也没有准备技术文章。和大家分享一些北京的春光，希望大家：面朝大海，春暖花开。</p>
<img src="week_13_01.jpeg" width=80% height=30% align=center/>

<img src="week_13_02.jpeg" width=80% height=30% align=center/>

<img src="week_13_03.jpeg" width=80% height=30% align=center/>

<img src="week_13_04.jpeg" width=80% height=30% align=center/>

<img src="week_13_05.jpeg" width=80% height=30% align=center/>

<img src="week_13_06.jpeg" width=80% height=30% align=center/>

<img src="week_13_07.jpeg" width=80% height=30% align=center/>


]]></content>
      <categories>
        <category>周报</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题-关于添加文章摘要的一点思考</title>
    <url>/2020/03/27/HexoNextReadmore/</url>
    <content><![CDATA[<h4 id="什么是摘要？"><a href="#什么是摘要？" class="headerlink" title="什么是摘要？"></a>什么是摘要？</h4><blockquote>
<p> 摘要是简洁、具体的摘要要反映论文的实质性内容，展示论文内容足够的信息，体现论文的创新性，展现论文的重要梗概，一般由具体研究的对象、方法、结果、结论四要素组成。</p>
</blockquote>
<h4 id="为什么要添加文章摘要？"><a href="#为什么要添加文章摘要？" class="headerlink" title="为什么要添加文章摘要？"></a>为什么要添加文章摘要？</h4><ol>
<li>我们写的每一篇技术博客，都应该有文章摘要，用简短的文字来交代该篇博客的写作背景、遇到的问题、是否解决、采取的方法。通过阅读文章摘要，读者就应该大致能够判断该篇文章对自己是否存在价值，避免把宝贵的时间浪费在没有意义的文章上。</li>
<li>Hexo写作的文章默认的编辑模式是全文模式，如果采用全文模式来写文章，在浏览整个网站的过程中将会把非常多的时间浪费在滑动屏幕这种没有价值的事情上。对读者而言，这是一个相当不友好的体验，而且会分散读者的注意力。</li>
<li>美观度</li>
</ol>
<hr>
<p><strong>很多关于文章摘要的博客，基本上都是在教给大家如何去截断文章，严格讲这并不是文章摘要，只是为了美观度截取了部分文章。还是建议大家在写完博客之后，可以认真写一下文章的摘要，形成一个好的写作习惯。</strong></p>
<hr>
<h4 id="Hexo添加文摘要的三种方式"><a href="#Hexo添加文摘要的三种方式" class="headerlink" title="Hexo添加文摘要的三种方式"></a>Hexo添加文摘要的三种方式</h4><ol>
<li>在文章中使用<code>&lt;!--more--&gt;</code>进行手动截断,这其实就是上面讲到的文章截断，推荐在使用<code>&lt;!--more--&gt;</code>之前写好文章摘要</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line"> 摘要是简洁、具体的摘要要反映论文的实质性内容，展示论文内容足够的信息，体现论文的创新性，展现论文的重要梗概，一般由具体研究的对象、方法、结果、结论四要素组成。</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>在文章中的<code>front-matter</code>中添加<code>description</code>，并提供文章摘要。<br>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。使用这种方法也可以实现首页文章部分显示的效果。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Next主题生成文章摘要的三种方式</span><br><span class="line">date: 2020-03-27 12:21:09</span><br><span class="line">tags:</span><br><span class="line">- 原创</span><br><span class="line">categories: </span><br><span class="line">- 网站</span><br><span class="line">description: 本文的主要目的是关于写文章摘要的一些思考，以及Hexo的Next主题添加文章摘要的三种方式，希望能给读者提供一些帮助。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自动生成摘要，主题配置文件中添加以下代码，这种方是更加机械的切割，没有办法控制摘要显示的内容, 而且是对整个网站生效的,不是特别推荐</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题 - 图片设置</title>
    <url>/2020/03/24/HexoNextTheme/</url>
    <content><![CDATA[<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><h4 id="Hexo有网络图片和插入本地图片两种方式："><a href="#Hexo有网络图片和插入本地图片两种方式：" class="headerlink" title="Hexo有网络图片和插入本地图片两种方式："></a>Hexo有<code>网络图片</code>和<code>插入本地图片</code>两种方式：</h4><ul>
<li>插入网络图片可以用常用的Markdown的方式进行插入: <code>![img-title](img-url)</code></li>
<li>插入本地图片，主要涉及到本地图片资源的管理，相对插入网络图片复杂一些，但是引用方式大同小异，针对插入本地图片我们稍做展开</li>
</ul>
<a id="more"></a>

<h5 id="插入本地图片-01"><a href="#插入本地图片-01" class="headerlink" title="插入本地图片 -01"></a>插入本地图片 -01</h5><ol>
<li><a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">安装插件</a>: 在博客的根目录下执行：<code>npm install hexo-asset-image --save</code> 或<code>npm install hexo-asset-image --g</code></li>
<li>修改站点配置文件<code>_config.yml</code>： 找到 <code>post_asset_folder</code>，把值改成 <code>true</code>，这样在执行<code>hexo new page</code> 的时候，会在<code>source/_posts</code>文件夹下生成一个和<code>page</code>同名的文件夹，可以存放该<code>page</code>中用到的图片</li>
<li>插入本地图片<code>![imageTitle](img.jpg)</code></li>
</ol>
<h5 id="插入本地图片-02"><a href="#插入本地图片-02" class="headerlink" title="插入本地图片-02"></a>插入本地图片-02</h5><ol>
<li>在<code>source</code>下建立一个<code>_posts</code>同级别的文件夹  <code>images</code>，将图片放入其中，此时的图片路径为：<br><code>/hexo/source/images/img.png</code></li>
<li>插入图片，要使用相对路径，应写为<code>![imageTitle](/images/img.png)</code></li>
</ol>
<h4 id="修改图片的大小"><a href="#修改图片的大小" class="headerlink" title="修改图片的大小"></a>修改图片的大小</h4><p>图片默认会显示原本的图片大小并居中显示，如果需要对图片大小进行设置，需要另外写 css 样式进行控制。当使用上面的方式创建和<code>page</code>同名的文件夹的时候，可使用下面的方式更改图片的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;img.jpg&quot; width&#x3D;80% height&#x3D;50% align&#x3D;center&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;images&#x2F;img.png&quot; width&#x3D;80% height&#x3D;50% align&#x3D;center&#x2F;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(Centos)安装tomcat并且部署Java Web项目---踩坑</title>
    <url>/2020/03/21/InstallTomcat/</url>
    <content><![CDATA[<h3 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h3><p>我使用的是<a href="https://cloud.tencent.com/login?s_url=https%3A%2F%2Fconsole.cloud.tencent.com%2F" target="_blank" rel="noopener">腾讯云</a>, 配置：1核 1GB 1Mbps系统盘：普通云硬盘，Centos系统</p>
<a id="more"></a>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>腾讯云提供了好几种<a href="https://cloud.tencent.com/document/product/213/5436" target="_blank" rel="noopener">登录</a>方式</p>
<ol>
<li>最简单的登陆方式是登陆控制台，点击下面的【登录】按钮，使用WebShell登录，这里就不过多介绍了</li>
</ol>
<p><img src="Linux01.png" alt="linux01.png"></p>
<h3 id="使用-Linux-Mac-OS-X-系统的电脑（使用密码登录）"><a href="#使用-Linux-Mac-OS-X-系统的电脑（使用密码登录）" class="headerlink" title="使用 Linux/Mac OS X 系统的电脑（使用密码登录）"></a>使用 Linux/Mac OS X 系统的电脑（使用密码登录）</h3><ol>
<li>打开 SSH 客户端（Mac可使用系统自带的终端）</li>
<li>输入<code>ssh -q -l root -p ip</code>(公网ip)</li>
<li>输入 CVM 实例密码进行登录。</li>
</ol>
<h3 id="使用-Linux-Mac-OS-X-系统的电脑（使用密钥登录"><a href="#使用-Linux-Mac-OS-X-系统的电脑（使用密钥登录" class="headerlink" title="使用 Linux/Mac OS X 系统的电脑（使用密钥登录)"></a>使用 Linux/Mac OS X 系统的电脑（使用密钥登录)</h3><ol>
<li>打开 SSH 客户端（Mac可使用系统自带的终端）。</li>
<li>查找您云服务器关联的 SSH 密钥文件本地存放地址。(现在控制台生成SSH秘钥，并下载到本地)</li>
<li>您的密钥必须不公开可见，SSH 才能工作。请使用此命令：chmod 400 [密钥文件路径]。</li>
<li>输入命令：ssh [-i 密钥文件路径] root@ip (解释：root是账户，ip是公网ip地址)</li>
</ol>
<h3 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h3><p>首先我们在自己的Linux系统上生成一对SSH Key：SSH密钥和SSH公钥．密钥保存在自己的Linux系统上。<br>然后公钥上传到Linux服务器．之后我们就能无密码SSH登录了．SSH密钥就好比是你的身份证明．</p>
<ul>
<li>在自己的Linux系统上生成SSH密钥和公钥<br>打开终端，使用下面的ssh-keygen来生成RSA密钥和公钥．-t表示type，就是说要生成RSA加密的钥匙．</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>RSA也是默认的加密类型．所以你也可以只输入ssh-keygen．默认的RSA长度是2048位．如果你非常注重安全，那么可以指定4096位的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -b 4096 -t rsa</span><br></pre></td></tr></table></figure>
<p>生成SSH Key的过程中会要求你指定一个文件来保存密钥，按Enter键使用默认的文件就行了．然后需要输入一个密码来加密你的SSH Key．密码至少要20位长度．SSH密钥会保存在home目录下的<code>.ssh/id_rsa</code>文件中．SSH公钥保存在<code>.ssh/id_rsa.pub</code>文件中．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa): 　按Enter键</span><br><span class="line">Enter passphrase (empty for no passphrase): 　　输入一个密码</span><br><span class="line">Enter same passphrase again: 　　再次输入密码</span><br><span class="line">Your identification has been saved in &#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">e1:dc:ab:ae:b6:19:b0:19:74:d5:fe:57:3f:32:b4:d0 matrix@vivid</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 4096]----+</span><br><span class="line">| .. |</span><br><span class="line">| . . |</span><br><span class="line">| . . .. . |</span><br><span class="line">| . . o o.. E .|</span><br><span class="line">| o S ..o ...|</span><br><span class="line">| &#x3D; ..+...|</span><br><span class="line">| o . . .o .|</span><br><span class="line">| .o . |</span><br><span class="line">| .++o |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>将SSH公钥上传到Linux服务器,可以使用<code>ssh-copy-id</code>命令来完成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id root@ip</span><br></pre></td></tr></table></figure>
<p><img src="Linux02.png" alt="linux02.png"></p>
<p>输入远程用户的密码后，SSH公钥就会自动上传了．SSH公钥保存在远程Linux服务器的<code>.ssh/authorized_keys</code>文件中．<br>上传完成后，SSH登录就不需要再次输入密码了．但是首次使用SSH Key登录时需要输入一次SSH密钥的加密密码．（只需要输入一次，将来会自动登录，不再需要输入密钥的密码．）</p>
<p>使用scp命令来传送文件时也不需要输入密码</p>
<blockquote>
<p>如果你是按照腾讯云的步骤来的话，登录成功后可能会继续让你分区与格式化数据盘，虽然我也扩展了数据盘，但是我发现其实没必要做这一步(主要是我按照官方的步骤一直失败，后来发现已经默认分了一个盘，而且一直处于挂载的状态，也无法卸载，就没再捣鼓)，接下来就可以配置部署所需要的环境了</p>
</blockquote>
<h3 id="安装JDK-centos默认安装了yum-所以我用yum安装的JDK"><a href="#安装JDK-centos默认安装了yum-所以我用yum安装的JDK" class="headerlink" title="安装JDK(centos默认安装了yum,所以我用yum安装的JDK)"></a>安装JDK(centos默认安装了yum,所以我用yum安装的JDK)</h3><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ul>
<li><p>下载tomcat linux安装包： <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">安装包下载地址</a></p>
</li>
<li><p>在云服务器创建存放tomcat的文件夹,例如创建一个kencery的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">mkdir kencery</span><br><span class="line">cd kencery&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>然后将下载的tomcat安装包复制到kencery文件夹下（可用cp命令或图形化操作）<br>我用cp命令没有成功，最后用的是图形化操作，Mac版本的FileZilla,可以直接将本地的安装包拖到云服务器的kencery文件夹根目录下， 然后进行解压</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxv -f apache-tomcat-8.0.29.tar.gz</span><br><span class="line">mv apache-tomcat-8.0.29 tomcat</span><br><span class="line">cd tomcat</span><br></pre></td></tr></table></figure>
<p>解析完成后即可以启动tomcat，检查是否安装成功，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p><img src="Linux03.png" alt="linux03.png"></p>
<p>出现如上图所示信息，则表示启动成功。这时候我们可以在浏览器中使用<code>http://ip:8080</code>访问（注：ip为服务器外网ip），如能够显示tomcat的主页，则表示不需要进行任何操作了，如果不能显示，则需要在Linux中开放防火墙的8080端口。</p>
<p><strong>Tips:</strong> 在进行这一步的时候，好多次，都不成功，可以通过下面的方式来排除问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.请确定tomcat监听的8080端口：</span><br><span class="line">Tomcat安装的目录下： </span><br><span class="line">conf\server.xml,找到： </span><br><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; maxHttpHeaderSize&#x3D;&quot;8192&quot; </span><br><span class="line">maxThreads&#x3D;&quot;150&quot; minSpareThreads&#x3D;&quot;25&quot; maxSpareThreads&#x3D;&quot;75&quot; </span><br><span class="line">enableLookups&#x3D;&quot;false&quot; redirectPort&#x3D;&quot;8443&quot; acceptCount&#x3D;&quot;100&quot; </span><br><span class="line">connectionTimeout&#x3D;&quot;20000&quot; disableUploadTimeout&#x3D;&quot;true&quot; &#x2F;&gt; </span><br><span class="line">看你的PORT是多少。</span><br><span class="line">2.防火墙是否屏蔽：</span><br><span class="line">在开启了防火墙时，做如下设置，开启相关端口， </span><br><span class="line">修改&#x2F;etc&#x2F;sysconfig&#x2F;iptables 文件，添加以下内容： </span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT </span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line">设置完之后可以重启防火墙服务</span><br><span class="line">（1) 重启后生效 </span><br><span class="line">开启： chkconfig iptables on </span><br><span class="line">关闭： chkconfig iptables off </span><br><span class="line">（2) 即时生效，重启后失效 </span><br><span class="line">开启： service iptables start </span><br><span class="line">关闭： service iptables stop </span><br><span class="line">3.安全组是否允许相应的端口(控制台-&gt;云服务器-&gt;安全组)</span><br></pre></td></tr></table></figure>
<p>如果都设置成功了，访问的时候可能出现一直加载不出来的情况，首次访问的时间特别长，我就在这里遇到了坑，以为没有设置对</p>
<h3 id="Linux中设置tomcat的服务器启动和关闭"><a href="#Linux中设置tomcat的服务器启动和关闭" class="headerlink" title="Linux中设置tomcat的服务器启动和关闭"></a>Linux中设置tomcat的服务器启动和关闭</h3><ol>
<li>完成步骤二对tomcat的安装后，接下来就可以部署项目，但是这里存在一个问题，那就是Linux的系统和重启我们每次都需要接路径并且执行命令，比较麻烦，因此我们可以设置成service的形式来实现这个功能。</li>
<li>执行命令：<code>vim /etc/rc.d/init.d/tomcat</code> ，创建脚本文件，在文件中写入如下代码，保存并且退出：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash  </span><br><span class="line"># &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat  </span><br><span class="line"># init script for tomcat precesses  </span><br><span class="line"># processname: tomcat  </span><br><span class="line"># description: tomcat is a j2se server  </span><br><span class="line"># chkconfig: 2345 86 16  </span><br><span class="line"># description: Start up the Tomcat servlet engine.  </span><br><span class="line"></span><br><span class="line">if [ -f &#x2F;etc&#x2F;init.d&#x2F;functions ]; then  </span><br><span class="line">. &#x2F;etc&#x2F;init.d&#x2F;functions  </span><br><span class="line">elif [ -f &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions ]; then  </span><br><span class="line">. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions  </span><br><span class="line">else  </span><br><span class="line">echo -e &quot;\atomcat: unable to locate functions lib. Cannot continue.&quot;  </span><br><span class="line">exit -1  </span><br><span class="line">fi  </span><br><span class="line">RETVAL&#x3D;$?  </span><br><span class="line">CATALINA_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&quot;   #tomcat安装目录，你安装在什么目录下就复制什么目录  </span><br><span class="line">case &quot;$1&quot; in  </span><br><span class="line">start)  </span><br><span class="line">if [ -f $CATALINA_HOME&#x2F;bin&#x2F;startup.sh ];  </span><br><span class="line">then  </span><br><span class="line">echo $&quot;Starting Tomcat&quot;  </span><br><span class="line">$CATALINA_HOME&#x2F;bin&#x2F;startup.sh  </span><br><span class="line">fi  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">if [ -f $CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh ];  </span><br><span class="line">then  </span><br><span class="line">echo $&quot;Stopping Tomcat&quot;  </span><br><span class="line">$CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh  </span><br><span class="line">fi  </span><br><span class="line">;;  </span><br><span class="line">*)  </span><br><span class="line">echo $&quot;Usage: $0 &#123;start|stop&#125;&quot;  </span><br><span class="line">exit 1  </span><br><span class="line">;;  </span><br><span class="line">esac  </span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<p>给文件添加权限，使得脚本文件可以执行，命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat</span><br></pre></td></tr></table></figure>
<p>将其添加到服务中，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig --add &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat</span><br></pre></td></tr></table></figure>
<p>然后将下面的配置文件加到tomcat中的catalina.sh文件中的最后面，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh</span><br></pre></td></tr></table></figure>
<p>添加的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;javajdk   #javajdk的安装路径，使用echo $JAVA_HOME命令可以读取  </span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat  </span><br><span class="line">export CATALINA_BASE&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat  </span><br><span class="line">export CATALINA_TMPDIR&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;temp</span><br></pre></td></tr></table></figure>
<p>以上所有工作顺利进行并没有报错，则配置完成，输入下面命令进行验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure>

<h3 id="Linux中设置tomcat开机自启动"><a href="#Linux中设置tomcat开机自启动" class="headerlink" title="Linux中设置tomcat开机自启动"></a>Linux中设置tomcat开机自启动</h3><p>通过步骤三的设置我们可以很方便的启动和关闭tomcat，但这里存在一个问题，那就是当服务器关机重启的时候，服务不能随计算机的启动而自行启动，下面我们将tomcat服务设置为开机启动。</p>
<p>打开Linux设置开机启动文件，将下面的配置文件写入rc.local文件的最后，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br></pre></td></tr></table></figure>
<p>添加的配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;javajdk  </span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar  </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin  </span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;  </span><br><span class="line">#tomcat自启动  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p>tomcat依赖于java的JDK，所以设置的时候将JDK也同步导入。</p>
<p>完成上面的设置后我们可以将CentOS关机重启一下，看tomcat是否成功自启动</p>
<h3 id="给tomcat设置用户和密码登录"><a href="#给tomcat设置用户和密码登录" class="headerlink" title="给tomcat设置用户和密码登录"></a>给tomcat设置用户和密码登录</h3><p>当tomcat安装完成之后，访问<code>http://ip:8080</code>即可以看到tomcat发布的网站，若要管理我们发布的网站，就需要登录tomcat，下面就进行用户名和密码的设置。</p>
<p>在tomcat安装包下面的conf文件下含有一个tomcat-usrs.xml文件，修改此文件即可，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim tomcat-users.xml</span><br></pre></td></tr></table></figure>
<p>在打开的xml配置文件后面写入下面这段配置内容后，【:wq】保存并且退出即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;     </span><br><span class="line">&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;  </span><br><span class="line">&lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,admin-gui&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在这里会出现一个问题，因为tomcat-users.xml里面有注释的用户设置信息，取消注释，用文件提供的用户名和密码去访问的时候，会出现403错误，什么原因呢？这是因为我们没有指定用户所拥有的权限。如若我们现在想访问tomcat中图形化管理应用的功能，也就是Manager App，就需要指定manager-gui的权限，如果想访问host manager就必须指定admin-gui权限，故而需要上面所示的配置内容。</p>
<p>配置完用户名和密码之后，需要重新启动tomcat，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure>
<p>重启服务之后，检测是否登录成功，输入用户名和密码登录进入系统，则说明登录成功</p>
<h3 id="将Java-Web项目发布到tomcat8-0下面并且访问展示"><a href="#将Java-Web项目发布到tomcat8-0下面并且访问展示" class="headerlink" title="将Java Web项目发布到tomcat8.0下面并且访问展示"></a>将Java Web项目发布到tomcat8.0下面并且访问展示</h3><p>以上所有工作都完成之后，完美就可以将打包的JavaWeb程序发布到tomcat下即可<br>tomcat默认的发布web项目的目录是：webapps<br>将导出的war包拷贝到webapps根目录下，随之tomcat的启动，war包可以自动被解析。<br>然后在浏览器中输入路径链接，查询是否安装成功</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/sqzhao/article/details/71307850" target="_blank" rel="noopener">Linux系统下的ssh使用(依据个人经验总结)</a></p>
<p><a href="https://www.linuxdashen.com/ssh-key%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0ssh%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">SSH无密码登录：只需两个简单步骤 (Linux)</a></p>
<p><a href="https://blog.csdn.net/to_baidu/article/details/52823402" target="_blank" rel="noopener">Linux(Centos)安装tomcat并且部署Java Web项目</a></p>
<p><a href="https://www.kancloud.cn/curder/linux/121073" target="_blank" rel="noopener">Linux学习笔记</a></p>
<p><a href="https://blog.csdn.net/loongshawn/article/details/50468201" target="_blank" rel="noopener">MacPro 利用SCP上传下载Linux服务器文件</a></p>
<p><a href="https://www.cnblogs.com/lwhp/p/5789305.html" target="_blank" rel="noopener">腾讯云访问不了80端口，与8080问题</a></p>
<p><a href="https://os.51cto.com/art/201609/517037.htm" target="_blank" rel="noopener">CentOS下安装JDK的三种方法</a></p>
<p><a href="https://www.iteye.com/blog/canfly2010-429078" target="_blank" rel="noopener">查看Tomcat配置的端口</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS，一行代码进行RSA、DES 、AES、MD5加密、解密</title>
    <url>/2019/03/21/Encrypt/</url>
    <content><![CDATA[<p><a href="https://github.com/iamlay/Encryptions" target="_blank" rel="noopener">加密的Demo，欢迎下载</a></p>
<p>java端的加密解密，读者可以看我同事的<a href="https://note.youdao.com/" target="_blank" rel="noopener">这篇文章</a></p>
<a id="more"></a>

<p>最近做了一个移动项目，是有服务器和客户端类型的项目，客户端是要登录才行的，服务器也会返回数据，服务器是用Java开发的，客户端要同时支持多平台（Android、iOS），在处理iOS的数据加密的时候遇到了一些问题。起初采取的方案是DES加密，老大说DES加密是对称的，网络抓包加上反编译可能会被破解，故采取RSA方式加密。RSA加密时需要公钥和私钥，客户端保存公钥加密数据，服务器保存私钥解密数据。（iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签）。</p>
<h3 id="问题1：iOS端公钥加密的数据用Java端私钥解密"><a href="#问题1：iOS端公钥加密的数据用Java端私钥解密" class="headerlink" title="问题1：iOS端公钥加密的数据用Java端私钥解密"></a>问题1：iOS端公钥加密的数据用Java端私钥解密</h3><p>iOS无论使用系统自带的sdk函数，用mac产生的或者使用java的jdk产生的公钥和私钥，进行加密解密自己都可以使用。不过ios加密，java解密，或者反过来就不能用了。要么是无法创建报告个-9809或-50的错误，要么解出来是乱码。ios系统函数种只有用公钥加密，私钥解密的方式。而公钥加密每次结果都不同。</p>
<h3 id="MAC上生成公钥、私钥的方法，及使用"><a href="#MAC上生成公钥、私钥的方法，及使用" class="headerlink" title="MAC上生成公钥、私钥的方法，及使用"></a>MAC上生成公钥、私钥的方法，及使用</h3><ul>
<li>打开终端，切换到自己想输出的文件夹下</li>
<li>输入指令:<code>openssl</code>（openssl是生成各种秘钥的工具，mac已经嵌入</li>
<li>.输入指令:<code>genrsa -out rsa_private_key.pem 1024</code> (生成私钥，java端使用的)</li>
<li>输入指令:<code>rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout</code> (生成公钥)</li>
<li>.输入指令:<code>pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt</code>(私钥转格式，在ios端使用私钥解密时用这个私钥)</li>
</ul>
<p>注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端）</p>
<p><a href="http://blog.sina.com.cn/s/blog_12c8ae0d80102vy21.html" target="_blank" rel="noopener">详细步骤</a></p>
<h4 id="服务器返回数据也要加密，老大打算用java私钥加密-ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式"><a href="#服务器返回数据也要加密，老大打算用java私钥加密-ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式" class="headerlink" title="服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式"></a>服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式</h4><ul>
<li>通过简单的URLENCODE ＋ BASE64编码防止数据明文传输</li>
<li>对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验</li>
<li>对于重要数据，使用RSA进行数字签名，起到防篡改作</li>
<li>对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密</li>
</ul>
<p>因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；如果使用DES的话，可以通过破解客户端获取密钥，安全性较低。而服务器返回之所以使用DES，是因为不管使用DES还是RSA，密钥（或私钥）都存储在客户端，都存在被破解的风险，因此，需要采用动态密钥，而RSA的密钥生成比较复杂，不太适合动态密钥，并且RSA速度相对较慢，所以选用DES）</p>
<p>所以此次加密，我们选择了第四种加密方式</p>
<h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><h4 id="iOS端进行DES加密、解密时非常方便"><a href="#iOS端进行DES加密、解密时非常方便" class="headerlink" title="iOS端进行DES加密、解密时非常方便"></a>iOS端进行DES加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;DES3Util.h&quot;</span><br><span class="line">2、加密时调用类方法  +(NSString *) encryptUseDES:(NSString *)plainText key:(NSString *)key;</span><br><span class="line">3、解密时调用类方法  +(NSString *)decryptUseDES:(NSString *)cipherText key:(NSString *)key;</span><br></pre></td></tr></table></figure>

<h4 id="iOS端进行RSA加密、解密时非常方便"><a href="#iOS端进行RSA加密、解密时非常方便" class="headerlink" title="iOS端进行RSA加密、解密时非常方便"></a>iOS端进行RSA加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;RSAUtil.h&quot;</span><br><span class="line">2、公钥加密时调用类方法：</span><br><span class="line">+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;</span><br><span class="line">+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;</span><br><span class="line">3、私钥解密时调用类方法 </span><br><span class="line">+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;</span><br><span class="line">+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey;</span><br></pre></td></tr></table></figure>

<h4 id="iOS端进行MD5加密、解密时非常方便"><a href="#iOS端进行MD5加密、解密时非常方便" class="headerlink" title="iOS端进行MD5加密、解密时非常方便"></a>iOS端进行MD5加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;MD5Util&quot;</span><br><span class="line">2、加密时调用方法：- (NSString *)md5:(NSString *)str;</span><br></pre></td></tr></table></figure>
<h4 id="iOS端进行AES加密、解密时非常方便"><a href="#iOS端进行AES加密、解密时非常方便" class="headerlink" title="iOS端进行AES加密、解密时非常方便"></a>iOS端进行AES加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;AES.h&quot;</span><br><span class="line">2、加密时调用方法</span><br><span class="line">+ (NSString *)encrypt:(NSString *)message password:(NSString *)password;</span><br><span class="line">2、解密时调用的方法</span><br><span class="line">+ (NSString *)decrypt:(NSString *)base64EncodedString password:(NSString *)password;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/2927ca2b3719" target="_blank" rel="noopener">有关RSA、MD5、AES加密的原理介绍</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>cocoapods依赖关系可视化</title>
    <url>/2019/03/21/cocoapodsVisual/</url>
    <content><![CDATA[<p><a href="https://www.weichao.ren/ios/2018/12/27/cocoapods-graph/" target="_blank" rel="noopener">转载</a></p>
<blockquote>
<p>cocoapods管理的三方库之间有时候存在依赖关系，Podfile.lock藏满了各个版本库的版本号信息和彼此的依赖关系。</p>
</blockquote>
<h3 id="网页可视化导出-cocoapods-graph"><a href="#网页可视化导出-cocoapods-graph" class="headerlink" title="网页可视化导出-cocoapods-graph"></a>网页可视化导出-cocoapods-graph</h3><p>终端安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install cocoapods-graph</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>使用方式</p>
<p>进入到工程的根目录，执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cocoapods-graph -f Podfile.lock --html</span><br></pre></td></tr></table></figure>

<h3 id="图片可视化导出"><a href="#图片可视化导出" class="headerlink" title="图片可视化导出"></a>图片可视化导出</h3><p>终端安装插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods-dependencies</span><br><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure>
<p>使用方式:<br>进入到工程的根目录，执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod dependencies [PODSPEC] [--graphviz] [--image]</span><br></pre></td></tr></table></figure>

<p>Use the –graphviz option to generate .gv or Podfile.gv containing the dependency graph in graphviz format.</p>
<p>Use the –image option to generate .png or Podfile.png containing a rendering of the dependency graph.</p>
<p>[!] Note that for either graphviz or image output, GraphViz must be installed and dot must be accessible via $PATH.</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>用Cocoapods制作属于自己的仓库</title>
    <url>/2018/12/21/MakeCocoapods/</url>
    <content><![CDATA[<blockquote>
<p>在开发的过程中很多功能模块可能会在同一个App的不同的业务模块出现，也可能在不同的App出现，为了提高我们的开发效率，我们应该将普遍使用的功能模块封装成组件，并通过Cocoapods来管理</p>
</blockquote>
<p><a href="https://cyrill.win/articles/2016/12/04/pod-trunk" target="_blank" rel="noopener">利用pod trunk发布程序</a></p>
<a id="more"></a>

<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk register 邮箱 &#39;用户名&#39; --description&#x3D;&#39;电脑描述&#39;</span><br></pre></td></tr></table></figure>
<h3 id="查收邮件"><a href="#查收邮件" class="headerlink" title="查收邮件"></a>查收邮件</h3><ul>
<li>如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱”</li>
<li>点击邮件中的链接： <a href="https://trunk.cocoapods.org/sessions/verify/xxxx" target="_blank" rel="noopener">https://trunk.cocoapods.org/sessions/verify/xxxx</a></li>
</ul>
<h3 id="查看个人信息"><a href="#查看个人信息" class="headerlink" title="查看个人信息"></a>查看个人信息</h3><ul>
<li>pod trunk me</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Name:     &#39;Cyrill&#39;</span><br><span class="line">- Email:    lichunyang@outlook.com</span><br><span class="line">- Since:    December 4th, 2016 21:22</span><br><span class="line">- Pods:     None</span><br><span class="line">- Sessions:</span><br><span class="line">- December 4th, 2016 21:22 - July 13th, 21:00. IP: 103.244.255.84 Description: ‘MacbookProOfCyrill’</span><br></pre></td></tr></table></figure>
<p>中间可能遇到这种错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NoMethodError - undefined method &#39;last&#39; for #&lt;Netrc::Entry:0x007fc59c246378&gt;</span><br></pre></td></tr></table></figure>
<p>这时候需要尝试更新gem源或者pod</p>
<ul>
<li>sudo gem update –system</li>
<li>sudo gem install cocoapods</li>
<li>sudo gem install cocospods-trunk</li>
</ul>
<h3 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h3><p>接下来需要在项目根路径创建一个podspec文件来描述你的项目信息</p>
<ul>
<li>pod spec cretae 文件名 (比如pod spec cretae MJExtension就会生成一个MJExtension.podspec)</li>
</ul>
<h3 id="填写podspec内容"><a href="#填写podspec内容" class="headerlink" title="填写podspec内容"></a>填写podspec内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># spec开始  s作为spec的别名</span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">    # 项目名称</span><br><span class="line">    s.name         &#x3D; &quot;CYPhotoLib&quot;  </span><br><span class="line">    # 版本号</span><br><span class="line">    s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">    # 简介</span><br><span class="line">    s.summary      &#x3D; &quot;A photo selection framework used PhotoLib.&quot;</span><br><span class="line">    # 项目地址，主页</span><br><span class="line">    s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;CoderCYLee&#x2F;CYPhotoLib&quot;</span><br><span class="line">    # 开源协议</span><br><span class="line">    s.license      &#x3D; &quot;MIT&quot;</span><br><span class="line">    # 作者</span><br><span class="line">    s.author             &#x3D; &#123; &quot;Cyrill&quot; &#x3D;&gt; &quot;lichunyang@outlook.com&quot; &#125;</span><br><span class="line">    # 作者的社交url</span><br><span class="line">    s.social_media_url   &#x3D; &quot;http:&#x2F;&#x2F;weibo.com&#x2F;exceptions&quot;</span><br><span class="line">    # 支持最低ios版本</span><br><span class="line">    s.platform     &#x3D; :ios, &quot;8.0&quot;</span><br><span class="line">    # 代码的git源地址 这里的tag&#x3D;&gt;&quot;#&#123;s.version&#125;&quot; 引用了上面的s.version  如果，在打tag的时候是用的  git tag &#39;v1.0.0&#39;  那么这里需要使用   tag &#x3D;&gt; &quot;v#&#123;s.version&#125;&quot; </span><br><span class="line">    s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;CoderCYLee&#x2F;CYPhotoLib.git&quot;, :tag &#x3D;&gt; s.version &#125;</span><br><span class="line">    # 项目需要用到的ios framework </span><br><span class="line">    s.frameworks &#x3D; &quot;UIKit&quot;, &quot;Photos&quot;</span><br><span class="line">    # 项目中用到的库</span><br><span class="line">    # s.libraries    &#x3D; &quot;stdc++ </span><br><span class="line">    # 代码文件</span><br><span class="line">    s.source_files  &#x3D; &quot;CYPhotoLib&#x2F;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line">    # 资源文件</span><br><span class="line">    s.resources &#x3D; &quot;CYPhotoLib&#x2F;Resource&#x2F;*.png&quot;</span><br><span class="line">    # 是否ARC</span><br><span class="line">    s.requires_arc &#x3D; true</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag 0.0.1</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<ul>
<li>删除tag</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d 1.0</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;1.0</span><br><span class="line">git tag -a 1.0 -m &quot;Version 1.0&quot;</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<h3 id="检测podspec语法"><a href="#检测podspec语法" class="headerlink" title="检测podspec语法"></a>检测podspec语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint CYPhotoLib.podspec</span><br><span class="line"></span><br><span class="line">pod lib lint CYPhotoLib.podspec</span><br><span class="line"></span><br><span class="line">pod spec相对于pod lib会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。</span><br></pre></td></tr></table></figure>
<h3 id="发布podspec"><a href="#发布podspec" class="headerlink" title="发布podspec"></a>发布podspec</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push CYPhotoLib.podspec</span><br><span class="line">如果是第一次发布pod，需要去 https:&#x2F;&#x2F;trunk.cocoapods.org&#x2F;claims&#x2F;new 认领pod</span><br></pre></td></tr></table></figure>
<p>有可能出现的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod lib lint 的时候是通过了的，没有错误</span><br><span class="line">然后 pod trunk push 的时候报错，如下：</span><br><span class="line">    [iOS] unknown: Encountered an unknown error (Pod::DSLError) during validation.</span><br><span class="line">解决：这种状况有可能是git的tag和podspec的tag不对</span><br></pre></td></tr></table></figure>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod setup : 初始化</span><br><span class="line">pod repo update : 更新仓库</span><br><span class="line">pod search CYPhotoLib</span><br></pre></td></tr></table></figure>

<h3 id="仓库更新"><a href="#仓库更新" class="headerlink" title="仓库更新"></a>仓库更新</h3><p>如果仓库更新慢，可以考虑更换仓库镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo remove master</span><br><span class="line">pod repo add master http:&#x2F;&#x2F;git.oschina.net&#x2F;akuandev&#x2F;Specs.git</span><br></pre></td></tr></table></figure>

<h3 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h3><ol>
<li>每次修改完代码，podspec内容的version字段都要修改，否则一直会读取原来的内容</li>
<li>podspec的version字段和git提交的tag需要保持相同的</li>
<li>代码中引入三方库的时候，不要用 <code>#import&quot;xxx.h&quot;</code>,要通过<code>#import&lt;xxx/xxxx.h&gt;</code>来引入，否则的话，会报 <code>include of non-modular header inside framework module “xxx.h”</code>的错误</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins自动打包搭建之路</title>
    <url>/2018/04/21/Jenkins/</url>
    <content><![CDATA[<blockquote>
<p>本文的大部分步骤参考的是<a href="https://halfrost.com/ios_jenkins/" target="_blank" rel="noopener">一缕殇流化隐半边冰霜的博客</a>，所以截图和很多步骤都是直接拷贝的该博客，然后补充了自己踩的一些坑。最后的脚本问题我没有拷贝过来，如果大家希望有所了解，可以去原博客，本文主要是个人以后回忆所用</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h3><blockquote>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
</blockquote>
<h3 id="为什么使用持续集成"><a href="#为什么使用持续集成" class="headerlink" title="为什么使用持续集成"></a>为什么使用持续集成</h3><ol>
<li>减少重复过程</li>
<li>减少风险</li>
<li>任何时间、任何地点生成可部署的软件</li>
<li>增强项目的可见性</li>
</ol>
<h3 id="环境准备步骤"><a href="#环境准备步骤" class="headerlink" title="环境准备步骤"></a>环境准备步骤</h3><p>现在我们来开始安装Jenkins。从<a href="https://jenkins.io/zh/" target="_blank" rel="noopener">官网</a> 上下载最新的pkg安装包。但是，这个时候直接安装是装不上的，Jenkins依赖于Java运行环境，因此需要首先安装<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">Java的SDK</a>。</p>
<p>下载JAVA的SDK，并安装。安装完成后，打开终端，cd进入到jenkins.war包所在目录，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war --httpPort&#x3D;8080</span><br></pre></td></tr></table></figure>

<p>httpPort指的就是Jenkins所使用的http端口，这里指定8080(默认的就是这个)，可根据具体情况来修改。待Jenkins启动后，在浏览器页面输入以下地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

<p>这样就打开Jenkins管理页面了。这个时候Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开<code>http://localhost:8080</code> 会出现下图的重设初始密码的界面。</p>
<p><img src="jenkins02.png" alt="jenkins02.png"></p>
<p>按照提示，找到<code>/Users/Shared/Jenkins/Home/</code>这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。<br><img src="jenkins03.png" alt="jenkins03.png"><br><img src="jenkins04.png" alt="jenkins04.png"></p>
<p>打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图<br><img src="jenkins05.png" alt="jenkins05.png"><br><img src="jenkins06.png" alt="jenkins06.png"></p>
<p><img src="jenkins07.png" alt="jenkins07.png"><br><img src="jenkins08.png" alt="jenkins08.png"><br><img src="jenkins09.png" alt="jenkins09.png"></p>
<p>一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。Jenkins安装完成之后，需要安装一些插件。</p>
<h3 id="安装GitLab插件"><a href="#安装GitLab插件" class="headerlink" title="安装GitLab插件"></a>安装GitLab插件</h3><p>GitLab用来管理源代码，Jenkins本身并没有自带GitLab插件，所以我们需要依次选择 系统管理-&gt;管理插件，在“可选插件”中选中<code>“GitLab Plugin”</code>和<code>“Gitlab Hook Plugin”</code>这两项，然后安装。</p>
<h3 id="安装Xcode插件"><a href="#安装Xcode插件" class="headerlink" title="安装Xcode插件"></a>安装Xcode插件</h3><p>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中<code>“Xcode integration”</code>安装。</p>
<h3 id="安装签名证书管理插件"><a href="#安装签名证书管理插件" class="headerlink" title="安装签名证书管理插件"></a>安装签名证书管理插件</h3><p>OS打包内测版时，需要发布证书及相关签名文件，因此这两个插件对于管理iOS证书非常方便。还是在系统管理-&gt;管理插件，在“可选插件”中选中<code>“Credentials Plugin”</code>和<code>“Keychains and Provisioning Profiles Management”</code>安装。</p>
<h3 id="安装脚本插件"><a href="#安装脚本插件" class="headerlink" title="安装脚本插件"></a>安装脚本插件</h3><p>这个插件的功能主要是用于在build后执行相关脚本。在系统管理-&gt;管理插件，在“可选插件”中选中<code>“Post-Build Script Plug-in”</code>安装。</p>
<p>安装完了插件，我们就可以配置一个构建项目了。</p>
<p><img src="jenkins10.png" alt="jenkins10.png"><br><img src="jenkins11.png" alt="jenkins11.png"></p>
<p>点击新建好的项目，进来配置一下General参数。<br>接着设置源码管理。<br>由于现在我用到的是Github，在Jenkins的证书管理中添加账号、密码。在Jenkins管理页面，选择<code>“Credentials”</code>，然后选择<code>“Global credentials (unrestricted)”</code>，点击<code>“Add Credentials”</code>，如下图所示，我们填写自己的账号密码信息，然后点击<code>“Save”</code>，这样就把账号密码添加到Jenkins的全局域中去了</p>
<p><img src="jenkins12.png" alt="jenkins12.png"></p>
<p>如果正常的配置正确的话，是不会出现下图中的那段红色的警告。如果有下图的提示，就说明Jenkins还没有连通Github或者SVN，那就请再检查账号密码是否配置正确。</p>
<p><img src="jenkins13.png" alt="jenkins13.png"></p>
<p>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。<br>不过这里有两个配置还是需要是配置的<br><code>Poll SCM (poll source code management)</code>轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br><code>Build periodically</code>(定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>
<p>格式是这样的</p>
<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>
<p><img src="jenkins14.png" alt="jenkins14.png"></p>
<h3 id="构建环境设置"><a href="#构建环境设置" class="headerlink" title="构建环境设置"></a>构建环境设置</h3><p>iOS打包需要签名文件和证书，所以这部分我们勾选<code>“Keychains and Code Signing Identities”</code>和<code>“Mobile Provisioning Profiles”</code>。<br>这里我们又需要用到Jenkins的插件，在系统管理页面，选择<code>“Keychains and Provisioning Profiles Management”</code>。</p>
<p><img src="jenkins15.png" alt="jenkins15.png"></p>
<p><img src="jenkins16.png" alt="jenkins16.png"></p>
<p>注意：这里可以上传的一种是<code>login.keychain</code>文件一种是<code>ProvisioningProfiles</code>文件。这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名<code>/Library/keychains/login.keychain</code>,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到<code>/Users/Shared/Jenkins/Library/keychains</code>这里，(Library是隐藏文件)。Tips:后面的Code Signing Identity里面的开发者账号是手写的，而不是上传完keychain文件之后，自动识别的，这里坑了我好久</p>
<p>找到对应的<code>Provisioning Profiles</code>文件(这个文件不是直接在开发者平台下载下来的文件名字，而是安装到本地之后的文件名)上传之后， <code>Provisioning Profiles</code>也直接拷贝到<code>/Users/Shared/Jenkins/Library/MobileDevic</code>e文件目录下。</p>
<p>Tips: 如图的那个路径也是填写的，而不是上传后直接识别的，同上。</p>
<p>这样证书和签名文件就在Jenkins中配置好了，接下来我们只需要在item设置中指定相关文件即可。 回到我们新建的item，找到构建环境，按下图选好自己的相关证书和签名文件。Tips：在这里有时候你发现上传完上面的文件并填写完相应的账号和路径之后，点击下拉箭头，啥都没有，这个时候点击保存，然后退出，从新进来配置，多试几次。</p>
<p><img src="jenkins17.png" alt="jenkins17.png"></p>
<p>接下来在进行构建的设置，这里没有用Xcode插件，用的是执行脚本。我本地项目Xcode证书和描述文件不是自动配置的，而是手动选择的。本地配置好之后，一定要执行git上传到远程仓库。</p>
<p>在导出ipa包的时候，注意xcodebuild 命令，里面选项配置是一个plist文件，我在下面贴出来plist内容</p>
<p><img src="jenkins18.png" alt="jenkins18.png"></p>
<h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 工程名</span><br><span class="line">APP_NAME&#x3D;&quot;KIFTestDemo&quot;  </span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION&#x3D;&quot;iPhone Distribution: China Mobile Group Guangdong Company Limited&quot;  </span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path&#x3D;&quot;.&#x2F;$&#123;APP_NAME&#125;&#x2F;Info.plist&quot;</span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">#取build值</span><br><span class="line">bundleVersion&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE&#x3D;&quot;$(date +%Y%m%d)&quot;  </span><br><span class="line">IPANAME&#x3D;&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;.ipa&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">IPA_PATH&#x3D;&quot;$HOME&#x2F;$&#123;IPANAME&#125;&quot;  </span><br><span class="line">echo $&#123;IPA_PATH&#125;  </span><br><span class="line">echo &quot;$&#123;IPA_PATH&#125;&quot;&gt;&gt; text.txt</span><br><span class="line">RchivePath&#x3D;&quot;.&#x2F;KIFTestDemo.xcarchive&quot;</span><br><span class="line">IPAPath&#x3D;&quot;.&#x2F;KIFTestDemoipa&quot;</span><br><span class="line">optionsPlist&#x3D;&quot;.&#x2F;EnterpriseExportOptions.plist&quot;  </span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  </span><br><span class="line">xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme &quot;$&#123;APP_NAME&#125;&quot;  -configuration &#39;Release&#39; clean</span><br><span class="line">echo &quot;+++++++++++++++++build+++++++++++++++++&quot;  </span><br><span class="line">xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme &quot;$&#123;APP_NAME&#125;&quot; -sdk iphoneos -configuration &#39;Release&#39; -archivePath $RchivePath</span><br><span class="line">xcodebuild -exportArchive -archivePath $RchivePath -exportPath $IPAPath   -exportOptionsPlist $optionsPlist</span><br><span class="line">plist内容</span><br></pre></td></tr></table></figure>

<h3 id="plist内容"><a href="#plist内容" class="headerlink" title="plist内容"></a>plist内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;&#x2F;key&gt;</span><br><span class="line">&lt;false&#x2F;&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.gmcc.gdmobileimoa&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ee4c1dc2-cf62-41d5-9871-93f0abbacad5&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;key&gt;method&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>
<h3 id="构建后，将ipa包上传到蒲公英"><a href="#构建后，将ipa包上传到蒲公英" class="headerlink" title="构建后，将ipa包上传到蒲公英"></a>构建后，将ipa包上传到蒲公英</h3><p><img src="jenkins19.png" alt="jenkins19.png"></p>
<h3 id="构建后脚本内容"><a href="#构建后脚本内容" class="headerlink" title="构建后脚本内容"></a>构建后脚本内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">蒲公英上的User Key</span><br><span class="line">uKey&#x3D;&quot;24d26944ee1ffacec4faeb1ac73a0a48&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey&#x3D;&quot;8d418599c52f8bf47f6cd7db1c3116b7&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">IPA_PATH&#x3D;&quot;.&#x2F;KIFTestDemoipa&#x2F;KIFTestDemo.ipa&quot;</span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey&#x3D;$&#123;uKey&#125;&quot; -F &quot;_api_key&#x3D;$&#123;apiKey&#125;&quot; http:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>
<p>这里我们选择<code>Execute a set of scripts</code>，这里也是一个脚本，这个脚本用来上传自动打包好的ipa文件。</p>
<p>至此，我们的Jenkins设置就全部完成了。点击构建，就会开始构建项目了。</p>
<p>构建一次，各个颜色代表的意义如下：</p>
<p><img src="jenkins20.png" alt="jenkins20.png"></p>
<p>如果构建失败了，可以去查看Console Output可以查看log日志。</p>
<p><img src="jenkins21.png" alt="jenkins21.png"></p>
<h3 id="Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充"><a href="#Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充" class="headerlink" title="Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充"></a>Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://halfrost.com/ios_jenkins/" target="_blank" rel="noopener">手把手教你利用 Jenkins 持续集成 iOS 项目</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>OCSQLCipher</title>
    <url>/2018/03/21/OCSQLCipher/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据安全越来越成为生活中非常重要的问题，用户隐私泄露的问题时有发生，如何保护用户数据的安全，越来越成为一个负责公司有限考虑的问题。本篇文章不涉及接口安全、传输安全等方面，只是对App使用的sqlite数据库安全做分析。</p>
<a id="more"></a>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>使用SQLite数据库的时候，有时候对于数据库要求比较高，特别是在iOS8.3之前，未越狱的系统也可以通过工具拿到应用程序沙盒里面的文件，这个时候我们就可以考虑对SQLite数据库进行加密，这样就不用担心sqlite文件泄露了</p>
<p>通常数据库加密一般有两种方式</p>
<p>对所有数据进行加密<br>对数据库文件加密<br>第一种方式虽然加密了数据，但是并不完全，还是可以通过数据库查看到表结构等信息，并且对于数据库的数据，数据都是分散的，要对所有数据都进行加解密操作会严重影响性能，通常的做法是采取对文件加密的方式</p>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>LZ接手的项目原来使用cocoapod导入过FMDB,因为项目本身SVN管理的问题，原本不打算使用cocoapod导入SQLCipher,但是尝试过网上的解决方案但是没有加密成功，最后还是使用cocoapod导入的。</p>
<p><code>pod ‘FMDB/SQLCipher’, ‘~&gt; 2.6.2’</code></p>
<p>确保自己的cocoapod版本号可以导入该库,LZ的cocoapod库原本是0.0.39版本的，老是报错，最后只得升级,如果原来的版本低于1.0.0，要注意修改podfile文件的格式</p>
<p>导入成功后，打开<code>FMDatabase.m</code>文件，找到下面的一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)open &#123;</span><br><span class="line">  if (_db) &#123;</span><br><span class="line">  return YES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">int err &#x3D; sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db );</span><br><span class="line">if(err !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">&#x2F;&#x2F; set the handler</span><br><span class="line">[self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F;数据库open后设置加密key</span><br><span class="line">[self setKey:encryptKey_];</span><br><span class="line">&#125;   </span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;</span><br><span class="line"></span><br><span class="line"># if SQLITE_VERSION_NUMBER &gt;&#x3D; 3005000</span><br><span class="line"></span><br><span class="line">if (_db) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int err &#x3D; sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;_db, flags, [vfsName UTF8String]);</span><br><span class="line">if(err !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">return NO;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;数据库open后设置加密key</span><br><span class="line">[self setKey:encryptKey_];</span><br><span class="line">&#125;</span><br><span class="line">if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">&#x2F;&#x2F; set the handler</span><br><span class="line">[self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line"># else</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;openWithFlags requires SQLite 3.5&quot;);</span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步就可以在初始化数据库时对数据库进行加密</p>
<p>通过客户端验证是否可以读取数据库信息<br>取到app中的数据库<br>真机连接<code>xcode-&gt;window-&gt;Devices</code></p>
<p>将会得到下面的文件，然后右键显示包含内容，找到自己创建的数据库</p>
<p>打开数据库的工具,笔者使用的是<a href="https://www.waitsun.com/navicat-premium-11-1-15.html" target="_blank" rel="noopener">Navicat Premium</a></p>
<p>打开Navicat Premium,链接数据库，选择sqlite</p>
<p>选中本地保存的数据库文件，点击ok打开</p>
<p>将会提示</p>
<p>提醒</p>
<p>注意:笔者这里修改的是源码，是因为接手的工程FMDB又被封装，更改起来比较困难，为了不修改FMDB的源代码，可以继承自FMDatabase类重写需要setKey的几个方法，具体写法可见demo,到这一步就可以在初始化数据库时对数据库进行加密，不过很多情况下，我们可能会遇到对已经存在的数据库进行加密</p>
<p>SQLite数据库加解密</p>
<p>SQLCipher提供了几个命令用于加解密操作</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;sqlcipher plaintext.db  </span><br><span class="line">sqlite&gt; ATTACH DATABASE &#39;encrypted.db&#39; AS encrypted KEY &#39;testkey&#39;;  </span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&#39;encrypted&#39;);  </span><br><span class="line">sqlite&gt; DETACH DATABASE encrypted;</span><br></pre></td></tr></table></figure>
<ul>
<li>打开非加密数据库</li>
<li>创建一个新的加密的数据库附加到原数据库上</li>
<li>导出数据到新数据库上</li>
<li>卸载新数据库</li>
</ul>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; PRAGMA key &#x3D; &#39;testkey&#39;;  </span><br><span class="line">sqlite&gt; ATTACH DATABASE &#39;plaintext.db&#39; AS plaintext KEY &#39;&#39;;  -- empty key will disable encryption</span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&#39;plaintext&#39;);  </span><br><span class="line">sqlite&gt; DETACH DATABASE plaintext;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开加密数据库</li>
<li>创建一个新的不加密的数据库附加到原数据库上</li>
<li>导出数据到新数据库上</li>
<li>卸载新数据库</li>
</ul>
<h3 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** encrypt sqlite database to new file *&#x2F;</span><br><span class="line"></span><br><span class="line">+ (BOOL)encryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey</span><br><span class="line">&#123;</span><br><span class="line">const char* sqlQ &#x3D; [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS encrypted KEY &#39;%@&#39;;&quot;, targetPath, encryptKey] UTF8String];</span><br><span class="line">sqlite3 *unencrypted_DB;</span><br><span class="line">if (sqlite3_open([sourcePath UTF8String], &amp;unencrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">char *errmsg;</span><br><span class="line">&#x2F;&#x2F; Attach empty encrypted database to unencrypted database</span><br><span class="line">sqlite3_exec(unencrypted_DB, sqlQ, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export database</span><br><span class="line">sqlite3_exec(unencrypted_DB, &quot;SELECT sqlcipher_export(&#39;encrypted&#39;);&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Detach encrypted database</span><br><span class="line">sqlite3_exec(unencrypted_DB, &quot;DETACH DATABASE encrypted;&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(unencrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** decrypt sqlite database to new file *&#x2F;</span><br><span class="line">+ (BOOL)unEncryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey</span><br><span class="line">&#123;</span><br><span class="line">const char* sqlQ &#x3D; [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS plaintext KEY &#39;&#39;;&quot;, targetPath] UTF8String];</span><br><span class="line">sqlite3 *encrypted_DB;</span><br><span class="line">if (sqlite3_open([sourcePath UTF8String], &amp;encrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">char* errmsg;</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key &#x3D; &#39;%@&#39;;&quot;, encryptKey] UTF8String], NULL, NULL, &amp;errmsg);</span><br><span class="line">&#x2F;&#x2F; Attach empty unencrypted database to encrypted database</span><br><span class="line">sqlite3_exec(encrypted_DB, sqlQ, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export database</span><br><span class="line">sqlite3_exec(encrypted_DB, &quot;SELECT sqlcipher_export(&#39;plaintext&#39;);&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Detach unencrypted database</span><br><span class="line">sqlite3_exec(encrypted_DB, &quot;DETACH DATABASE plaintext;&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** change secretKey for sqlite database *&#x2F;</span><br><span class="line">+ (BOOL)changeKey:(NSString *)dbPath originKey:(NSString *)originKey newKey:(NSString *)newKey</span><br><span class="line">&#123;</span><br><span class="line">sqlite3 *encrypted_DB;</span><br><span class="line">if (sqlite3_open([dbPath UTF8String], &amp;encrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key &#x3D; &#39;%@&#39;;&quot;, originKey] UTF8String], NULL, NULL, NULL);</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA rekey &#x3D; &#39;%@&#39;;&quot;, newKey] UTF8String], NULL, NULL, NULL);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>SQLCipher使用起来还是很方便的，基本上不需要怎么配置，需要注意的是，尽量不要在操作过程中修改secretKey，否则，可能导致读不了数据，在使用第三方库的时候尽量不去修改源代码，可以通过扩展或继承的方式修改原来的行为，这样第三方库代码可以与官方保持一致，可以跟随官方版本升级，具体代码可以到<a href="https://github.com/zhengbomo/sqlcipherDemo" target="_blank" rel="noopener">github上下载</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>嗨，26岁！</title>
    <url>/2017/03/21/26Birthday/</url>
    <content><![CDATA[<p>今天是2017-12-18号，农历11月1日。下班之后，一头扎进火锅店，我很想知道，在生日这天，一个人吃火锅到底是一种怎样的体验~</p>
<p>我不爱拉几个人一起过生日，不喜欢热闹，不喜欢标准流程:聚餐、蛋糕、K歌,一如我内心对于循规蹈矩和仪式感的不适。所以，我宁愿一个人听歌，一个人吃饭，一个人看电影,一个人散步，也不愿意几个人坐在一起说一些漫无边际的话，一个人其实还不错~</p>
<a id="more"></a>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>11月份，狠了狠心，放弃了年终奖和涨薪，离开彩讯。这一年，同事休假，一个人扛两个安卓差不多持续一年。在永远都在变动的需求下，写着毫无价值的业务代码，Crl+C、Crl+V成了开发常态。成长，学习，放松成为非常奢侈的东西。在一个没有互联网基因，一个以业务为导向的公司，作为一个开发根本没有价值和存在感，成为了实实在在的码农。根深蒂固的上下级关系，一言堂的领导氛围，让一个天生热爱自由的射手座深感压力。在这里，第一次连续通宵一个星期;第一次累到双眼迷离的坐着地铁回去;第一次回到家什么都不想干，只想睡觉;第一次牙疼到夜里两点睡不着觉;第一次因为正常下班，被领导说工作不饱和，忍不住骂傻X…在这里工作一年多，我觉得考虑到自己的身体、情绪、未来、人际关系，都无法继续在这里工作了。当有了一个新的机会，为什么不离开呢~</p>
<p>换了一份新工作，回到了SOHO,一切都是熟悉的感觉。到目前为止，一切都还不错，轻松的工作氛围，有趣的伙伴，和谐的公司文化，最重要的是周围优秀的人很多，促使自己不断进步。终于有时间，学一些自己想学的东西，做一些自己喜欢的事情，非常nice！</p>
<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>作为一个重度的网易云用户，我想，下面一段话代表了我目前的状态~</p>
<p>我总嚷嚷着要找对象，可是从来没有主动想要去勾搭谁，我害怕快餐爱情，害怕分开，害怕最后我认真了别人却只是敷衍。所以我等，等一个到最后还在我身边的人，我坚持或者偏执的相信有一个人会看穿我假装的冷漠，真正的靠近我留在我身边爱着我也给我一个机会去爱她 如果最后能在一起，那么晚点也没关系《Fine乐团《配不上你》》</p>
<p>所以，我对爱情还有期待吗—有的~</p>
<h3 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h3><p>Python不错，好好学一下Python;计算机基础：TCP/IP、数据库、算法不用多说了吧；虽然没钱，理财知识需要恶补一下额；文学类书籍，也该看一看<del>~</del></p>
<p>这一段时间疯狂想购物，所以哦，不太喜欢买贵重物品的自己，买了一台Canon 800D单反相机作为礼物送给自己，完成了很久以来一个小小的心愿。未来的一年，希望有时间，多出去走一走，看一看，拍一拍，单身旅行？</p>
<img src="birth.jpg" width=80% height=50% align=center/>


]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>致---25岁的自己,路过的都是风景，留下的都是青春</title>
    <url>/2016/03/21/25Birthday/</url>
    <content><![CDATA[<p>今天重感冒，鼻子不通气，喉咙巨疼，不停地咳嗽。推算着大概快到25岁了，翻了一下日历，没想到就是今天，差一点错过。像极了自己的人生的前25年，好像很有目标，其实就是浑浑噩噩的过来了，没有大悲大喜，平庸的一无是处。</p>
<a id="more"></a>
<p>其实，早就奔三了，二十五岁显得尤其特别，像一个关键的节点，我想，是时候回顾一下平凡的过去，给这平凡的二十五年画上一个句号。</p>
<h3 id="青春"><a href="#青春" class="headerlink" title="青春"></a>青春</h3><p>其实，我应该没有资格说了吧，25岁，从法律上讲已经到了一个男孩晚婚的年纪，只不过还想矫情的最后再说一次，以后再也不会了</p>
<p>把自己定位成心智比较早熟的人，15、6岁的时候考虑很多很多事情，现在去翻那时候的日记，我才发现，那些看起来老练的文字只是一个孩子的理想主义。那些建立在旁听来的社会经验、书本和幻想上的人生态度是一个象牙塔的孩子在青春期对青春期的反抗。回想起来，我以一种不可思议的平静度过了整个青春期，没有叛逆，没有歇斯底里。那些幼稚的文字，成为最初的人生观，压制住了青春期的愤怒，也压制住了青春期的荷尔蒙。</p>
<p>从上学到大学毕业，那么那么多课，我缺席的只有两节，一节是初一重感冒，英语课上到一半，烧到不行，打了个点滴；另一节是大学为了体验一次逃课而逃课，而且是不那么重要的马哲，根本没有惊心动魄可言。接近二十年的求学生涯，竟然没有几个印象深刻的瞬间，我太听话了，太守规矩了。我想，未来的某天，不管是和哪个阶段的同学一起回忆的时候，我都不会成为回忆的主角，甚至配角也不是。如果可以，我愿回到当初，打一场假，逃一次课，冒犯一次老师，搞乱一次课堂</p>
<p>之所以做一个规矩的模范生，不敢任性,除了老师引诱，片刻的虚荣，还是因为出生在农村这样一个父母不懂得孩子性格引导、正确的表达情感，价值观确立的环境，一切都要靠自己的野蛮生长，自我调整。需要花费更多的努力获取别人的认同，没有犯错的资本，没有任性的本钱。如果犯错、逃课，除了担负逆子的骂名，我想不到还有什么好的结果，而这确实不是我愿意触碰的底线，实在不想为生活奔波的父母因为我还要到学校跑来跑去，在老师面前毫无尊严可言。</p>
<p>我的每个小小的成绩可能都让父母感到了骄傲，可是对自己而言，确实失去了很多本来可以去回忆的青春，更为遗憾的是，失去了青春成长必须付出的代价，而这一直是我觉得自己性格不够完整的原因。</p>
<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>年轻哪有资格谈恋爱，花的都是父母的钱<br>15岁左右，也是情窦初开的时候，第一次接触到这句话，加上本身自己就是个有强烈自我约束倾向的人，觉得拒绝早恋是自己的使命，有着对爱情最原始的拒绝。所以，每次前排的女生回过头来温柔的看着我的同桌时，我都在想，又成不了，真浪费时间。尽管我承认那个女生很好看，我也很喜欢。</p>
<p>二十岁的时候，也就是刚上大学的时候，要交学费，加上生活费，每次就要六七千，第一次体会到生活的压力，开学的前一天都不好意思管父母张口要钱。这个时候，确实有了恋爱的时间，也有了恋爱的心里需求，不过这次是真正的觉得恋爱是一场烧钱的游戏，是恋爱不起了。我很想花费心思追一个女生，可是，有资格那么做吗？</p>
<p>二十五岁，工作一年，也攒了一些钱，虽然不多，好歹自足。再去看这句话，完全有了不同的心态：这是哪个圣母说出来的言论！<br>15、6岁在该恋爱的年纪，在该学习处理两性关系的年纪，对早恋的鄙视换来的是未来面对女生的时候的局促，换来的单身，换来的是一个人吃饭时来自老板娘异样的目光。把克制当做骄傲，把懂事当做骄傲，把月考的成绩当做骄傲，把理想当做骄傲，这些所谓的骄傲并没有在后来的人生轨道上起到什么作用，早恋的依然优秀，早恋过程中养成的高情商反而成为进入社会后单身狗并不具备的优势。单身却成为长大以后一个无法辩驳的槽点，被不停地挖苦挖苦。</p>
<p>前几天，老郭发了条微博：这个年龄再谈爱情，会被别人笑话的。我干净利落的回了句：傻逼。毕业之后，似乎真的没有人再谈爱情了，所有人都急着结婚，好像这个世界就要快没有女人了。其实，我真的想再等一等，作为一个满口情怀的伪文艺青年，我真的想用一次心跳加速来结束青春，走进人生的下一个节点。</p>
<p>我想过好多好多浪漫的场景，我想，我遇到一个，大概就会义无反顾的去爱。有时候，我想，妈的，我这么好，没有不良嗜好，不嫖不偷，凭什么做一个接盘侠。可是，这个年纪，，谁还有时间陪你来一场恋爱呢？</p>
<p>前段时间，有几个人给介对象，自己都拒绝了。寻找爱情很难，慢慢的发现，寻找一个合适的也很难很难。</p>
<p>我渴望一场恋爱，然后走进婚姻，仅此而已</p>
<h3 id="友情"><a href="#友情" class="headerlink" title="友情"></a>友情</h3><p>我温和善良的对待认识的每个人，也希望每个人温和善良的对待我，我总在自己的承受能力之内，尽全力做到最好。我总是把自己最好的生活状态呈现给别人，不让别人担心，也不会为别人添加累赘，这并不意味着我的生活没有负担，我没有困难。越来越不想解释，为什么我没有在你困难的时候伸出手来，可能你并不知道，那也是我最困难的时候，只是我没有呈现在你的面前，也没有说出来而已 。</p>
<p>有几个特别好的朋友，从初三到现在接近十年的时间了，初三的时候关系特别好，我一直以为我们会一直是最好的。有一段时间，我发现一个朋友的空间晒了大量的和发小的照片，并配上了大量的兄弟之类的文字，我特别难过，就像一个孩子失去了心爱的玩具。随着长大，有我就慢慢释怀了，每个人都有自己的生活态度，都有自己选择的生活方式，谁都不是谁的必需品。所以，有的时候，要接受朋友最亲近的朋友换成别人的落差。成为朋友那段时间是因为我们刚好遇到，恰好脾气相投，所以我们一起走了一段时间，能一起走下去那当然最好，倘若有一天你发现曾经的某些人消失了，默默地祝福就好，不要怪别人为什么不辞而别，也不要气急败坏的绝交。</p>
<p>某一天，你来了，call我，我会欢喜的请你吃饭，没有call我，即便我知道了自己该干嘛还是干嘛，你没有联系我，可能我不是你最好的朋友了，我没联系你可能因为我也很忙，也可能我不想让已经约了别人的你尴尬，但是你要记住，我对你的感情没有少，依然维持在我们分别的时候，我长大了，不在浮夸的表达自己而已。</p>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>在北京呆了一年半，也不知道还能待多久，还是没有摆脱蜗居的状态，生活并没有明显的改善。</p>
<p>应该读读书了吧，看看自己写的这些没有文采和逻辑的文字<br>应该动一动了吧，周末别老睡觉，找个朋友打场球，吃个饭<br>应该换个房子了吧，住在这里能找到女朋友吗<br>技术上，应该开始稳步前进了吧，既然选择这一行，就好好干，技术上欠缺的还是太多太多。前端，后台，数据结构，算法，swift，都应该涉猎，学会高效和稳定的团队开发，尽然没有敏捷开发就尝试着自己搭建敏捷开发平台，没有单元测试，就自己引入单元测试，没有高效的打包工具，就自己使用jenkins自动化打包，没有用户体验的优化就用产品的心态做好优化。<br>2017年，雷传营，加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>NSScanner,一个陌生的条件判断利器!</title>
    <url>/2016/03/21/NSScanner/</url>
    <content><![CDATA[<p><a href="https://developer.apple.com/documentation/foundation/scanner#//apple_ref/occ/instm/NSScanner/scanInteger:" target="_blank" rel="noopener">NSScanner官方文档</a></p>
<p>NSScanner类是一个<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%B0%87?fr=aladdin" target="_blank" rel="noopener">类簇</a>的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。</p>
<a id="more"></a>

<p>NSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。</p>
<p>由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和<a href="https://developer.apple.com/documentation/foundation/scanner#//apple_ref/doc/uid/20000159-SW1" target="_blank" rel="noopener">Configuring a Scanner</a>方法下面列举的所有的方法。</p>
<p>在 NSScanner 对象扫描字符串的时候，你可以通过设置属性<code>charactersToBeSkipped</code>忽略某些字符。在扫描字符串之前，那些位于<code>忽略字符集</code>中的字符将会被跳过。默认的忽略字符是空格和回车字符。</p>
<p>可以通过<code>[[scanner string] substringFromIndex:[scanner scanLocation]]</code>获取未扫描的字符串。</p>
<h3 id="创建-Scanner对象"><a href="#创建-Scanner对象" class="headerlink" title="创建 Scanner对象"></a>创建 Scanner对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)scannerWithString:(NSString *)aString</span><br><span class="line"></span><br><span class="line">+ (id)localizedScannerWithString:(NSString *)aString</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithString:(NSString *)aString</span><br></pre></td></tr></table></figure>

<ul>
<li>scannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;</li>
<li>localizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;</li>
<li>initWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化</li>
</ul>
<h3 id="获取Scanner的字符串"><a href="#获取Scanner的字符串" class="headerlink" title="获取Scanner的字符串"></a>获取Scanner的字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property(readonly, copy) NSString *string</span><br></pre></td></tr></table></figure>
<h3 id="配置Scanner"><a href="#配置Scanner" class="headerlink" title="配置Scanner"></a>配置Scanner</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property NSUInteger scanLocation</span><br><span class="line">@property BOOL caseSensitive</span><br><span class="line">@property(copy) NSCharacterSet *charactersToBeSkipped</span><br><span class="line">@property(retain) id locale</span><br></pre></td></tr></table></figure>
<ul>
<li>scanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起NSRangeException,该属性在发生错误后重新扫描时非常有用。</li>
<li>caseSensitive，是否区分字符串中大小写的标志。默认为NO，注意：该设置不会应用到<code>被跳过的字符集</code>。</li>
<li>charactersToBeSkipped,在扫描时<code>被跳过的字符集</code>，默认是空白格和回车键。<code>被跳过的字符集</code>优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”};</li>
<li>locale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。</li>
</ul>
<h3 id="扫描字符串"><a href="#扫描字符串" class="headerlink" title="扫描字符串"></a>扫描字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)scanCharactersFromSet:(NSCharacterSet *)scanSet   intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanUpToCharactersFromSet:(NSCharacterSet *)stopSet    intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanString:(NSString *)string  intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanUpToString:(NSString *)stopString   intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanDecimal:(NSDecimal *)decimalValue;</span><br><span class="line">- (BOOL)scanDouble:(double *)doubleValue;</span><br><span class="line">- (BOOL)scanFloat:(float *)floatValue;</span><br><span class="line">- (BOOL)scanHexDouble:(double *)result;</span><br><span class="line">- (BOOL)scanHexFloat:(float *)result;</span><br><span class="line">- (BOOL)scanHexInt:(unsigned int *)intValue;</span><br><span class="line">- (BOOL)scanHexLongLong:(unsigned long long *)result;</span><br><span class="line">- (BOOL)scanInt:(int *)intValue;</span><br><span class="line">- (BOOL)scanInteger:(NSInteger *)value;</span><br><span class="line">- (BOOL)scanUnsignedLongLong:(unsigned long long *)unsignedLongLongValue;</span><br><span class="line">@property(getter&#x3D;isAtEnd, readonly) BOOL atEnd;</span><br></pre></td></tr></table></figure>

<ul>
<li>scanCharactersFromSet:intoString:扫描字符串中和NSCharacterSet字符集中匹配的字符，是按字符单个匹配的，例如，NSCharacterSet字符集为@”test123Dmo”，scanner字符串为 @” 123test12Demotest”，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为”123test12Demotest”</li>
<li>scanUpToCharactersFromSet:intoString：扫描字符串直到遇到NSCharacterSet字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容</li>
<li>scanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回YES,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，如果当前的扫描位置为0，那么扫描不到，但是如果将扫描位置设置成3，就可以扫描到了。</li>
<li>scanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，存储的内容为123</li>
<li>scanDecimal:扫描NSDecimal类型的值，有关NSDecimal类型的值更多的信息可以查看<a href="ttps://developer.apple.com/documentation/foundation/nsdecimalnumber#//apple_ref/occ/cl/NSDecimalNumber">NSDecimalNumber</a></li>
<li>scanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。</li>
<li>scanFloat：扫描单精度浮点型字符，具体内容同scanDouble</li>
<li>scanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加 0x或者 0X。</li>
<li>scanHexInt 扫描十六进制无符整型，unsigned int指针指向的地址值为 扫描到的值，包含溢出时的UINT_MAX。</li>
<li>scanHexLongLong 同scanHexDouble</li>
<li>scanInt 扫描整型，溢出也被认为是有效的整型，int 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。</li>
<li>scanInteger 同scanInt</li>
<li>scanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ConditionJudgmentController : NSObject</span><br><span class="line">&#x2F;&#x2F;输入框中只能输入数字和小数点，且小数点只能输入一位，参数number 可以设置小数的位数，该函数在-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string调用；</span><br><span class="line">+(BOOL)isValidAboutInputText:(UITextField *)textfield shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string  decimalNumber: (NSInteger) number;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;ConditionJudgmentController.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ConditionJudgmentController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+(BOOL)isValidAboutInputText:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string decimalNumber:(NSInteger)number&#123;</span><br><span class="line"></span><br><span class="line">    NSScanner      *scanner    &#x3D; [NSScanner scannerWithString:string];</span><br><span class="line">    NSCharacterSet *numbers;</span><br><span class="line">    NSRange         pointRange &#x3D; [textField.text rangeOfString:@&quot;.&quot;];</span><br><span class="line">    if ( (pointRange.length &gt; 0) &amp;&amp; (pointRange.location &lt; range.location  || pointRange.location &gt; range.location + range.length) )&#123;</span><br><span class="line">    numbers &#x3D; [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    numbers &#x3D; [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789.&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    if ( [textField.text isEqualToString:@&quot;&quot;] &amp;&amp; [string isEqualToString:@&quot;.&quot;] )&#123;</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    short remain &#x3D; number; &#x2F;&#x2F;保留 number位小数</span><br><span class="line">    NSString *tempStr &#x3D; [textField.text stringByAppendingString:string];</span><br><span class="line">    NSUInteger strlen &#x3D; [tempStr length];</span><br><span class="line">    if(pointRange.length &gt; 0 &amp;&amp; pointRange.location &gt; 0)&#123; &#x2F;&#x2F;判断输入框内是否含有“.”。</span><br><span class="line">    if([string isEqualToString:@&quot;.&quot;])&#123; &#x2F;&#x2F;当输入框内已经含有“.”时，如果再输入“.”则被视为无效。</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    if(strlen &gt; 0 &amp;&amp; (strlen - pointRange.location) &gt; remain+1)&#123; &#x2F;&#x2F;当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSRange zeroRange &#x3D; [textField.text rangeOfString:@&quot;0&quot;];</span><br><span class="line">    if(zeroRange.length &#x3D;&#x3D; 1 &amp;&amp; zeroRange.location &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;判断输入框第一个字符是否为“0”</span><br><span class="line">    if(![string isEqualToString:@&quot;0&quot;] &amp;&amp; ![string isEqualToString:@&quot;.&quot;] &amp;&amp; [textField.text length] &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。</span><br><span class="line">    textField.text &#x3D; string;</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    if(pointRange.length &#x3D;&#x3D; 0 &amp;&amp; pointRange.location &gt; 0)&#123; &#x2F;&#x2F;当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。</span><br><span class="line">    if([string isEqualToString:@&quot;0&quot;])&#123;</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *buffer;</span><br><span class="line">if ( ![scanner scanCharactersFromSet:numbers intoString:&amp;buffer] &amp;&amp; ([string length] !&#x3D; 0) )&#123;</span><br><span class="line">    return NO;</span><br><span class="line">    </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:上面的方法要结合UITextField的代理方法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">return [ConditionJudgmentController isValidAboutInputText:textField shouldChangeCharactersInRange:range replacementString:string decimalNumber:3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h3><p>平时读者在进行条件判断时，可能使用正则表达式或者用if语句比较多一点，其实NSScanner类为我们提供了一个非常好的方式进行判断。把它们结合起来使用，可以获得更好的效果。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS：关于iPhone连接Xcode时，RSA加密失败的一点总结</title>
    <url>/2015/12/21/RSAEncryptFail/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>前段时间做RSA加密的时候，在调试的过程中，经常失败，后台接收到的加密参数为空，但是这种不是经常发生，而是随机的。经过测试，发现，这种情况在单独使用真机、模拟器的时候都不发生，只有在真机连接xcode进行调试的时候才会发生。</p>
<a id="more"></a>
<h3 id="追踪："><a href="#追踪：" class="headerlink" title="追踪："></a>追踪：</h3><p>在笔者打了N多断点之后，终于找到了问题发生的根源。在RSA加密的类中，有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFTypeRef persistKey &#x3D; nil;</span><br><span class="line">OSStatus status &#x3D; SecItemAdd((__bridge CFDictionaryRef)publicKey, &amp;persistKey);</span><br><span class="line">if (persistKey !&#x3D; nil)&#123;</span><br><span class="line">CFRelease(persistKey);</span><br><span class="line">&#125;</span><br><span class="line">if ((status !&#x3D; noErr) &amp;&amp; (status !&#x3D; errSecDuplicateItem)) &#123;</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [publicKey removeObjectForKey:(__bridge id)kSecValueData];</span><br><span class="line">       [publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];</span><br><span class="line">       [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];</span><br><span class="line">       [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; Now fetch the SecKeyRef version of the key</span><br><span class="line">       SecKeyRef keyRef &#x3D; nil;</span><br><span class="line">       status &#x3D; SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&amp;keyRef);</span><br><span class="line">           </span><br><span class="line">           if(status !&#x3D; noErr)&#123;</span><br><span class="line">           return nil;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">return keyRef;</span><br></pre></td></tr></table></figure>
<p>在模拟器上测试的时候：<br><img src="RSAFail01.png" alt="rsafail01.png"></p>
<p>真机连接Xcode的时候：<br><img src="RSAFail02.png" alt="rsafail02.png"></p>
<p>问题就出在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OSStatus status &#x3D; SecItemAdd((__bridge CFDictionaryRef)publicKey, &amp;persistKey);</span><br></pre></td></tr></table></figure>

<p>在<a href="https://stackoverflow.com/questions/20344255/secitemadd-and-secitemcopymatching-returns-error-code-34018-errsecmissingentit" target="_blank" rel="noopener">stack overflow</a>发现有的人也遇到了类似的问题，现总问题结如下：</p>
<blockquote>
<p>1.当我在连接着Xcode的真机设备上运行app的时候,我试图获取钥匙串，却由于-34018的错误导致运行失败。缺乏钥匙串错误代码开发文档，而且也很难重现此错误(发生的概率大概30%，我也不知道为什么发生)。由于缺乏相关的文档，所以调试这种错误就变得非常困难。为什么会出现此错误，如何解决？xcode5、ios7</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h5><p>你不得不通过在你的test target中添加下面的代码作为运行脚本来签名你的 .xcttest文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codesign --verify --force --sign &quot;$CODE_SIGN_IDENTITY&quot; &quot;$CODESIGNING_FOLDER_PATH&quot;</span><br></pre></td></tr></table></figure>
<h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>在查看<a href="https://opensource.apple.com/source/Security/Security-55471/sec/Security/" target="_blank" rel="noopener">源码</a> 之后，我注意到钥匙串通过一种安全进程(区别于app的进程)获取。<br>app和<code>安全进程</code>通过一项称之为<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html" target="_blank" rel="noopener">XPC</a>的技术进行<code>对话</code>。<code>安全进程</code>经由<code>XPC</code>的启动命令启动。你可以发现真机（模拟器也是如此）app的<code>安全进程</code>正在运行，它的父进程也已经启动。<br>我猜测，有可能某些未知的原因导致<code>安全进程</code>启动失败或者启动太慢，使得你使用它的时候还没有准备好。<br>或许，你可以考虑如何重启<code>安全进程</code>。</p>
<h5 id="来自苹果官方回复："><a href="#来自苹果官方回复：" class="headerlink" title="来自苹果官方回复："></a>来自苹果官方回复：</h5><p>1.我们终于能够在ios8.3里重现-34018错误，这是我们查找问题根源和修复问题的第一步。<br>可是，我们并不能给出确切的解决时间，但是由于已经影响了很多的开发者，我们也非常希望尽快解决。<br>作为变通方案，我建议在在didFinishLaunchingWithOptions 和applicationDidBecomeActive: 两个方法之前添加一个小的延时给获取字符串争取一点时间。然而，好像并没有明显的作用，这就意味着除了重启app确实没有更好的解决方法。<br>这个问题似乎和内存压力也有一定的关系，在解决这个问题的时候，要积极处理内存警告的问题</p>
<h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><ul>
<li>一些情况下是由于不正确的app签名造成的，你可以很清楚的辨别这种原因，因为它100%可以重现。</li>
<li>有些情况下这种问题的造成是由于iOS支持app开发环境中的一个bug<br>造成的。由于os中的另一个bug掩盖了它的影响，排查这个问题非常困难，这就意味着这个问题在内存面临巨大压力的时候会突然出现，我们相信这个问题在ios9.3中已经解决。</li>
<li>我们猜测可能有其他的原因造成了这个问题</li>
</ul>
<p>所以，如果你在运行ios9.3及以后系统的用户设备上（<code>未和Xcode链接</code>）遇到此问题，请记录此bug并报告给我们。）</p>
<h5 id="方案四："><a href="#方案四：" class="headerlink" title="方案四："></a>方案四：</h5><p>我的app（iOS8.4）现在极少遇到 -34018的错误，在做过一些调查之后，我发现当app频繁的从钥匙串请求数据的时候就会造成这种问题。例如，在同一时间，在不同的加载模块，两次读同一个specific key 的值。为了解决这个问题，我在内存中缓存了这个值。</p>
<h5 id="方案五："><a href="#方案五：" class="headerlink" title="方案五："></a>方案五：</h5><p>其他的方式对我都没有用，我清空了我设备上所有的配置文件，以及一些通配符配置文件（这些文件似乎是重点），为了这么做，去window的Devices，然后右击你的（连接）的iphone:<br><img src="RSAFail03.png" alt="rsafail03.png"></p>
<p>点击”Show provisioning profiles”删除相关的文件，尤其是team相关的配置文件包括带*号的文件，然后重新导入。</p>
<h5 id="方案五：-1"><a href="#方案五：-1" class="headerlink" title="方案五："></a>方案五：</h5><p>点击”Show provisioning profiles”删除相关的文件，尤其是team相关的配置文件包括带*号的文件，然后重新导入。<br><img src="RSAFail04.png" alt="rsafail04.png"></p>
<h5 id="方案六："><a href="#方案六：" class="headerlink" title="方案六："></a>方案六：</h5><p>我在Xcode6.2 、iphone6、ios8.3环境下，在测试设备上也出现这种问题。更清楚的说，在运行Xcode tests的时候这种情况没有发生，在我的真机，模拟器上都是正常的。</p>
<p>以上的方式都对我无效。</p>
<p>我临时的改变了获取的方式从<br>kSecAttrAccessibleAfterFirstUnlock 到kSecAttrAccessibleAlwaysThisDeviceOnly，运行app,完美运行，且可以写到钥匙串，然后我再改回到kSecAttrAccessibleAfterFirstUnlock,问题似乎永久性的解决了。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>非常遗憾，笔者这个问题仍旧没有解决，希望笔者摘录的几种解决方式给大家一点思路。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>四胞胎之----nil 、 Nil 、 NULL 、NSNull</title>
    <url>/2015/10/21/Nill/</url>
    <content><![CDATA[<p><a href="https://nshipster.cn/nil/" target="_blank" rel="noopener">转自：nil / Nil / NULL / NSNull</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在OC开发过程中，我们会遇到nil 、 Nil 、 NULL 、NSNull这个四个长得极为相似的字符，nill应该是使用最频繁的，在创建对象之初我们往往会把对象的指针指向nill，但是它们之间的区别到底是什么，我们可能不太清楚。</p>
<a id="more"></a>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>在Objective－C中，有几个不同种类的不存在。</p>
<p>C用0来作为不存在的原始值，而NULL作为指针(这在指针环境中相当于0)。</p>
<p>Objective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。虽然它在语义上与NULL不同，但它们在技术上是相等的。</p>
<p>在框架层面，Foundation定义了NSNull，即一个类方法+null，它返回一个单独的NSNull对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。</p>
<p>另外，在Foundation/NSObjCRuntime.h中，Nil被定义为指向零的类指针。这个nil的鲜为人知的大写的表兄并不常常出现，但它至少值得注意。</p>
<h3 id="关于-nil-的一些事"><a href="#关于-nil-的一些事" class="headerlink" title="关于 nil 的一些事"></a>关于 nil 的一些事</h3><p>刚被分配的NSObject的内容被设置为0。也就是说那个对象所有的指向其他对象的指针都从nil开始，所以在init方法中设置self.(association) = nil之类的表达是没有必要的。</p>
<p>也许nil最显著的行为是，它虽然为零，仍然可以有消息发送给它。</p>
<p>在其他的语言中，比如C++，这样做会使你的程序崩溃，但在Objective-C中，在nil上调用方法返回一个零值。这大大的简化了表达，因为它避免了在使用nil之前对它的检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 举个例子，这个表达...</span><br><span class="line">if (name !&#x3D; nil &amp;&amp; [name isEqualToString:@&quot;Steve&quot;]) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; …可以被简化为：</span><br><span class="line">if ([name isEqualToString:@&quot;steve&quot;]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>了解nil如何在Objective-C中工作可以让你将这个便利变成一个功能，而不是潜伏在你的应用中的bug。要确保避免当nil值不需要的情况，要么通过检查或者提前返回来安静的失败，或者通过增加一个NSParameterAssert来抛出异常。</p>
<h3 id="NSNull：有作没有"><a href="#NSNull：有作没有" class="headerlink" title="NSNull：有作没有"></a>NSNull：有作没有</h3><p>SNull在Foundation和其它框架中被广泛的使用，以解决如NSArray和NSDictionary之类的集合不能有nil值的缺陷。你可以将NSNull理解为有效的将NULL或者nil值封装boxing，以达到在集合中使用它们的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *mutableDictionary &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">mutableDictionary[@&quot;someKey&quot;] &#x3D; [NSNull null]; &#x2F;&#x2F; Sets value of NSNull singleton for &#96;someKey&#96;</span><br><span class="line">NSLog(@&quot;Keys: %@&quot;, [mutableDictionary allKeys]); &#x2F;&#x2F; @[@&quot;someKey&quot;]</span><br></pre></td></tr></table></figure>
<p>总的来说，这里的四个表达没有的值是每个Objective-C程序员都应该知道的：</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
