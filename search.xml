<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux(Centos)安装tomcat并且部署Java Web项目---踩坑</title>
    <url>/2020/03/21/InstallTomcat/</url>
    <content><![CDATA[<h3 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h3><p>我使用的是<a href="https://cloud.tencent.com/login?s_url=https%3A%2F%2Fconsole.cloud.tencent.com%2F" target="_blank" rel="noopener">腾讯云</a>, 配置：1核 1GB 1Mbps系统盘：普通云硬盘，Centos系统</p>
<a id="more"></a>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>腾讯云提供了好几种<a href="https://cloud.tencent.com/document/product/213/5436" target="_blank" rel="noopener">登录</a>方式</p>
<ol>
<li>最简单的登陆方式是登陆控制台，点击下面的【登录】按钮，使用WebShell登录，这里就不过多介绍了</li>
</ol>
<p><img src="http://note.youdao.com/yws/res/1073/WEBRESOURCE09175fb46cd9fdc38535cde18522b526" alt="linux01.png"></p>
<h3 id="使用-Linux-Mac-OS-X-系统的电脑（使用密码登录）"><a href="#使用-Linux-Mac-OS-X-系统的电脑（使用密码登录）" class="headerlink" title="使用 Linux/Mac OS X 系统的电脑（使用密码登录）"></a>使用 Linux/Mac OS X 系统的电脑（使用密码登录）</h3><ol>
<li>打开 SSH 客户端（Mac可使用系统自带的终端）</li>
<li>输入<code>ssh -q -l root -p ip</code>(公网ip)</li>
<li>输入 CVM 实例密码进行登录。</li>
</ol>
<h3 id="使用-Linux-Mac-OS-X-系统的电脑（使用密钥登录"><a href="#使用-Linux-Mac-OS-X-系统的电脑（使用密钥登录" class="headerlink" title="使用 Linux/Mac OS X 系统的电脑（使用密钥登录)"></a>使用 Linux/Mac OS X 系统的电脑（使用密钥登录)</h3><ol>
<li>打开 SSH 客户端（Mac可使用系统自带的终端）。</li>
<li>查找您云服务器关联的 SSH 密钥文件本地存放地址。(现在控制台生成SSH秘钥，并下载到本地)</li>
<li>您的密钥必须不公开可见，SSH 才能工作。请使用此命令：chmod 400 [密钥文件路径]。</li>
<li>输入命令：ssh [-i 密钥文件路径] root@ip (解释：root是账户，ip是公网ip地址)</li>
</ol>
<h3 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h3><p>首先我们在自己的Linux系统上生成一对SSH Key：SSH密钥和SSH公钥．密钥保存在自己的Linux系统上。<br>然后公钥上传到Linux服务器．之后我们就能无密码SSH登录了．SSH密钥就好比是你的身份证明．</p>
<ul>
<li>在自己的Linux系统上生成SSH密钥和公钥<br>打开终端，使用下面的ssh-keygen来生成RSA密钥和公钥．-t表示type，就是说要生成RSA加密的钥匙．</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>RSA也是默认的加密类型．所以你也可以只输入ssh-keygen．默认的RSA长度是2048位．如果你非常注重安全，那么可以指定4096位的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -b 4096 -t rsa</span><br></pre></td></tr></table></figure>
<p>生成SSH Key的过程中会要求你指定一个文件来保存密钥，按Enter键使用默认的文件就行了．然后需要输入一个密码来加密你的SSH Key．密码至少要20位长度．SSH密钥会保存在home目录下的<code>.ssh/id_rsa</code>文件中．SSH公钥保存在<code>.ssh/id_rsa.pub</code>文件中．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa): 　按Enter键</span><br><span class="line">Enter passphrase (empty for no passphrase): 　　输入一个密码</span><br><span class="line">Enter same passphrase again: 　　再次输入密码</span><br><span class="line">Your identification has been saved in &#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;home&#x2F;matrix&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">e1:dc:ab:ae:b6:19:b0:19:74:d5:fe:57:3f:32:b4:d0 matrix@vivid</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 4096]----+</span><br><span class="line">| .. |</span><br><span class="line">| . . |</span><br><span class="line">| . . .. . |</span><br><span class="line">| . . o o.. E .|</span><br><span class="line">| o S ..o ...|</span><br><span class="line">| &#x3D; ..+...|</span><br><span class="line">| o . . .o .|</span><br><span class="line">| .o . |</span><br><span class="line">| .++o |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>将SSH公钥上传到Linux服务器,可以使用<code>ssh-copy-id</code>命令来完成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id root@ip</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/1117/WEBRESOURCE89ed8ddb1806682f813db374a7cf315f" alt="linux02.png"></p>
<p>输入远程用户的密码后，SSH公钥就会自动上传了．SSH公钥保存在远程Linux服务器的<code>.ssh/authorized_keys</code>文件中．<br>上传完成后，SSH登录就不需要再次输入密码了．但是首次使用SSH Key登录时需要输入一次SSH密钥的加密密码．（只需要输入一次，将来会自动登录，不再需要输入密钥的密码．）</p>
<p>使用scp命令来传送文件时也不需要输入密码</p>
<blockquote>
<p>如果你是按照腾讯云的步骤来的话，登录成功后可能会继续让你分区与格式化数据盘，虽然我也扩展了数据盘，但是我发现其实没必要做这一步(主要是我按照官方的步骤一直失败，后来发现已经默认分了一个盘，而且一直处于挂载的状态，也无法卸载，就没再捣鼓)，接下来就可以配置部署所需要的环境了</p>
</blockquote>
<h3 id="安装JDK-centos默认安装了yum-所以我用yum安装的JDK"><a href="#安装JDK-centos默认安装了yum-所以我用yum安装的JDK" class="headerlink" title="安装JDK(centos默认安装了yum,所以我用yum安装的JDK)"></a>安装JDK(centos默认安装了yum,所以我用yum安装的JDK)</h3><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ul>
<li><p>下载tomcat linux安装包： <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">安装包下载地址</a></p>
</li>
<li><p>在云服务器创建存放tomcat的文件夹,例如创建一个kencery的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">mkdir kencery</span><br><span class="line">cd kencery&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>然后将下载的tomcat安装包复制到kencery文件夹下（可用cp命令或图形化操作）<br>我用cp命令没有成功，最后用的是图形化操作，Mac版本的FileZilla,可以直接将本地的安装包拖到云服务器的kencery文件夹根目录下， 然后进行解压</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxv -f apache-tomcat-8.0.29.tar.gz</span><br><span class="line">mv apache-tomcat-8.0.29 tomcat</span><br><span class="line">cd tomcat</span><br></pre></td></tr></table></figure>
<p>解析完成后即可以启动tomcat，检查是否安装成功，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/1154/WEBRESOURCEf409f4010bc2fdc2f0809890f9f67fb8" alt="linux03.png"></p>
<p>出现如上图所示信息，则表示启动成功。这时候我们可以在浏览器中使用<code>http://ip:8080</code>访问（注：ip为服务器外网ip），如能够显示tomcat的主页，则表示不需要进行任何操作了，如果不能显示，则需要在Linux中开放防火墙的8080端口。</p>
<p><strong>Tips:</strong> 在进行这一步的时候，好多次，都不成功，可以通过下面的方式来排除问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.请确定tomcat监听的8080端口：</span><br><span class="line">Tomcat安装的目录下： </span><br><span class="line">conf\server.xml,找到： </span><br><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; maxHttpHeaderSize&#x3D;&quot;8192&quot; </span><br><span class="line">maxThreads&#x3D;&quot;150&quot; minSpareThreads&#x3D;&quot;25&quot; maxSpareThreads&#x3D;&quot;75&quot; </span><br><span class="line">enableLookups&#x3D;&quot;false&quot; redirectPort&#x3D;&quot;8443&quot; acceptCount&#x3D;&quot;100&quot; </span><br><span class="line">connectionTimeout&#x3D;&quot;20000&quot; disableUploadTimeout&#x3D;&quot;true&quot; &#x2F;&gt; </span><br><span class="line">看你的PORT是多少。</span><br><span class="line">2.防火墙是否屏蔽：</span><br><span class="line">在开启了防火墙时，做如下设置，开启相关端口， </span><br><span class="line">修改&#x2F;etc&#x2F;sysconfig&#x2F;iptables 文件，添加以下内容： </span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT </span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line">设置完之后可以重启防火墙服务</span><br><span class="line">（1) 重启后生效 </span><br><span class="line">开启： chkconfig iptables on </span><br><span class="line">关闭： chkconfig iptables off </span><br><span class="line">（2) 即时生效，重启后失效 </span><br><span class="line">开启： service iptables start </span><br><span class="line">关闭： service iptables stop </span><br><span class="line">3.安全组是否允许相应的端口(控制台-&gt;云服务器-&gt;安全组)</span><br></pre></td></tr></table></figure>
<p>如果都设置成功了，访问的时候可能出现一直加载不出来的情况，首次访问的时间特别长，我就在这里遇到了坑，以为没有设置对</p>
<h3 id="Linux中设置tomcat的服务器启动和关闭"><a href="#Linux中设置tomcat的服务器启动和关闭" class="headerlink" title="Linux中设置tomcat的服务器启动和关闭"></a>Linux中设置tomcat的服务器启动和关闭</h3><ol>
<li>完成步骤二对tomcat的安装后，接下来就可以部署项目，但是这里存在一个问题，那就是Linux的系统和重启我们每次都需要接路径并且执行命令，比较麻烦，因此我们可以设置成service的形式来实现这个功能。</li>
<li>执行命令：<code>vim /etc/rc.d/init.d/tomcat</code> ，创建脚本文件，在文件中写入如下代码，保存并且退出：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash  </span><br><span class="line"># &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat  </span><br><span class="line"># init script for tomcat precesses  </span><br><span class="line"># processname: tomcat  </span><br><span class="line"># description: tomcat is a j2se server  </span><br><span class="line"># chkconfig: 2345 86 16  </span><br><span class="line"># description: Start up the Tomcat servlet engine.  </span><br><span class="line"></span><br><span class="line">if [ -f &#x2F;etc&#x2F;init.d&#x2F;functions ]; then  </span><br><span class="line">. &#x2F;etc&#x2F;init.d&#x2F;functions  </span><br><span class="line">elif [ -f &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions ]; then  </span><br><span class="line">. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions  </span><br><span class="line">else  </span><br><span class="line">echo -e &quot;\atomcat: unable to locate functions lib. Cannot continue.&quot;  </span><br><span class="line">exit -1  </span><br><span class="line">fi  </span><br><span class="line">RETVAL&#x3D;$?  </span><br><span class="line">CATALINA_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&quot;   #tomcat安装目录，你安装在什么目录下就复制什么目录  </span><br><span class="line">case &quot;$1&quot; in  </span><br><span class="line">start)  </span><br><span class="line">if [ -f $CATALINA_HOME&#x2F;bin&#x2F;startup.sh ];  </span><br><span class="line">then  </span><br><span class="line">echo $&quot;Starting Tomcat&quot;  </span><br><span class="line">$CATALINA_HOME&#x2F;bin&#x2F;startup.sh  </span><br><span class="line">fi  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">if [ -f $CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh ];  </span><br><span class="line">then  </span><br><span class="line">echo $&quot;Stopping Tomcat&quot;  </span><br><span class="line">$CATALINA_HOME&#x2F;bin&#x2F;shutdown.sh  </span><br><span class="line">fi  </span><br><span class="line">;;  </span><br><span class="line">*)  </span><br><span class="line">echo $&quot;Usage: $0 &#123;start|stop&#125;&quot;  </span><br><span class="line">exit 1  </span><br><span class="line">;;  </span><br><span class="line">esac  </span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<p>给文件添加权限，使得脚本文件可以执行，命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat</span><br></pre></td></tr></table></figure>
<p>将其添加到服务中，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig --add &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat</span><br></pre></td></tr></table></figure>
<p>然后将下面的配置文件加到tomcat中的catalina.sh文件中的最后面，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh</span><br></pre></td></tr></table></figure>
<p>添加的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;javajdk   #javajdk的安装路径，使用echo $JAVA_HOME命令可以读取  </span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat  </span><br><span class="line">export CATALINA_BASE&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat  </span><br><span class="line">export CATALINA_TMPDIR&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;temp</span><br></pre></td></tr></table></figure>
<p>以上所有工作顺利进行并没有报错，则配置完成，输入下面命令进行验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure>

<h3 id="Linux中设置tomcat开机自启动"><a href="#Linux中设置tomcat开机自启动" class="headerlink" title="Linux中设置tomcat开机自启动"></a>Linux中设置tomcat开机自启动</h3><p>通过步骤三的设置我们可以很方便的启动和关闭tomcat，但这里存在一个问题，那就是当服务器关机重启的时候，服务不能随计算机的启动而自行启动，下面我们将tomcat服务设置为开机启动。</p>
<p>打开Linux设置开机启动文件，将下面的配置文件写入rc.local文件的最后，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br></pre></td></tr></table></figure>
<p>添加的配置内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;javajdk  </span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar  </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin  </span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;  </span><br><span class="line">#tomcat自启动  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;kencery&#x2F;tomcat&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>
<p>tomcat依赖于java的JDK，所以设置的时候将JDK也同步导入。</p>
<p>完成上面的设置后我们可以将CentOS关机重启一下，看tomcat是否成功自启动</p>
<h3 id="给tomcat设置用户和密码登录"><a href="#给tomcat设置用户和密码登录" class="headerlink" title="给tomcat设置用户和密码登录"></a>给tomcat设置用户和密码登录</h3><p>当tomcat安装完成之后，访问<code>http://ip:8080</code>即可以看到tomcat发布的网站，若要管理我们发布的网站，就需要登录tomcat，下面就进行用户名和密码的设置。</p>
<p>在tomcat安装包下面的conf文件下含有一个tomcat-usrs.xml文件，修改此文件即可，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim tomcat-users.xml</span><br></pre></td></tr></table></figure>
<p>在打开的xml配置文件后面写入下面这段配置内容后，【:wq】保存并且退出即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;     </span><br><span class="line">&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;  </span><br><span class="line">&lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,admin-gui&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在这里会出现一个问题，因为tomcat-users.xml里面有注释的用户设置信息，取消注释，用文件提供的用户名和密码去访问的时候，会出现403错误，什么原因呢？这是因为我们没有指定用户所拥有的权限。如若我们现在想访问tomcat中图形化管理应用的功能，也就是Manager App，就需要指定manager-gui的权限，如果想访问host manager就必须指定admin-gui权限，故而需要上面所示的配置内容。</p>
<p>配置完用户名和密码之后，需要重新启动tomcat，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat stop</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service tomcat start</span><br></pre></td></tr></table></figure>
<p>重启服务之后，检测是否登录成功，输入用户名和密码登录进入系统，则说明登录成功</p>
<h3 id="将Java-Web项目发布到tomcat8-0下面并且访问展示"><a href="#将Java-Web项目发布到tomcat8-0下面并且访问展示" class="headerlink" title="将Java Web项目发布到tomcat8.0下面并且访问展示"></a>将Java Web项目发布到tomcat8.0下面并且访问展示</h3><p>以上所有工作都完成之后，完美就可以将打包的JavaWeb程序发布到tomcat下即可<br>tomcat默认的发布web项目的目录是：webapps<br>将导出的war包拷贝到webapps根目录下，随之tomcat的启动，war包可以自动被解析。<br>然后在浏览器中输入路径链接，查询是否安装成功</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/sqzhao/article/details/71307850" target="_blank" rel="noopener">Linux系统下的ssh使用(依据个人经验总结)</a></p>
<p><a href="https://www.linuxdashen.com/ssh-key%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0ssh%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">SSH无密码登录：只需两个简单步骤 (Linux)</a></p>
<p><a href="https://blog.csdn.net/to_baidu/article/details/52823402" target="_blank" rel="noopener">Linux(Centos)安装tomcat并且部署Java Web项目</a></p>
<p><a href="https://www.kancloud.cn/curder/linux/121073" target="_blank" rel="noopener">Linux学习笔记</a></p>
<p><a href="https://blog.csdn.net/loongshawn/article/details/50468201" target="_blank" rel="noopener">MacPro 利用SCP上传下载Linux服务器文件</a></p>
<p><a href="https://www.cnblogs.com/lwhp/p/5789305.html" target="_blank" rel="noopener">腾讯云访问不了80端口，与8080问题</a></p>
<p><a href="https://os.51cto.com/art/201609/517037.htm" target="_blank" rel="noopener">CentOS下安装JDK的三种方法</a></p>
<p><a href="https://www.iteye.com/blog/canfly2010-429078" target="_blank" rel="noopener">查看Tomcat配置的端口</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>嗨，26岁！</title>
    <url>/2020/03/21/26Birthday/</url>
    <content><![CDATA[<p>今天是2017-12-18号，农历11月1日。下班之后，一头扎进火锅店，我很想知道，在生日这天，一个人吃火锅到底是一种怎样的体验~</p>
<p>我不爱拉几个人一起过生日，不喜欢热闹，不喜欢标准流程:聚餐、蛋糕、K歌,一如我内心对于循规蹈矩和仪式感的不适。所以，我宁愿一个人听歌，一个人吃饭，一个人看电影,一个人散步，也不愿意几个人坐在一起说一些漫无边际的话，一个人其实还不错~</p>
<a id="more"></a>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>11月份，狠了狠心，放弃了年终奖和涨薪，离开彩讯。这一年，同事休假，一个人扛两个安卓差不多持续一年。在永远都在变动的需求下，写着毫无价值的业务代码，Crl+C、Crl+V成了开发常态。成长，学习，放松成为非常奢侈的东西。在一个没有互联网基因，一个以业务为导向的公司，作为一个开发根本没有价值和存在感，成为了实实在在的码农。根深蒂固的上下级关系，一言堂的领导氛围，让一个天生热爱自由的射手座深感压力。在这里，第一次连续通宵一个星期;第一次累到双眼迷离的坐着地铁回去;第一次回到家什么都不想干，只想睡觉;第一次牙疼到夜里两点睡不着觉;第一次因为正常下班，被领导说工作不饱和，忍不住骂傻X…在这里工作一年多，我觉得考虑到自己的身体、情绪、未来、人际关系，都无法继续在这里工作了。当有了一个新的机会，为什么不离开呢~</p>
<p>换了一份新工作，回到了SOHO,一切都是熟悉的感觉。到目前为止，一切都还不错，轻松的工作氛围，有趣的伙伴，和谐的公司文化，最重要的是周围优秀的人很多，促使自己不断进步。终于有时间，学一些自己想学的东西，做一些自己喜欢的事情，非常nice！</p>
<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>作为一个重度的网易云用户，我想，下面一段话代表了我目前的状态~</p>
<p>我总嚷嚷着要找对象，可是从来没有主动想要去勾搭谁，我害怕快餐爱情，害怕分开，害怕最后我认真了别人却只是敷衍。所以我等，等一个到最后还在我身边的人，我坚持或者偏执的相信有一个人会看穿我假装的冷漠，真正的靠近我留在我身边爱着我也给我一个机会去爱她 如果最后能在一起，那么晚点也没关系《Fine乐团《配不上你》》</p>
<p>所以，我对爱情还有期待吗—有的~</p>
<h3 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h3><p>Python不错，好好学一下Python;计算机基础：TCP/IP、数据库、算法不用多说了吧；虽然没钱，理财知识需要恶补一下额；文学类书籍，也该看一看<del>~</del></p>
<p>这一段时间疯狂想购物，所以哦，不太喜欢买贵重物品的自己，买了一台Canon 800D单反相机作为礼物送给自己，完成了很久以来一个小小的心愿。未来的一年，希望有时间，多出去走一走，看一看，拍一拍，单身旅行？<br><img src="/26Birthday/birth.jpg" width=50% height=50% align=center/></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS，一行代码进行RSA、DES 、AES、MD5加密、解密</title>
    <url>/2019/03/21/Encrypt/</url>
    <content><![CDATA[<p><a href="https://github.com/iamlay/Encryptions" target="_blank" rel="noopener">加密的Demo，欢迎下载</a></p>
<p>java端的加密解密，读者可以看我同事的<a href="https://note.youdao.com/" target="_blank" rel="noopener">这篇文章</a></p>
<a id="more"></a>

<p>最近做了一个移动项目，是有服务器和客户端类型的项目，客户端是要登录才行的，服务器也会返回数据，服务器是用Java开发的，客户端要同时支持多平台（Android、iOS），在处理iOS的数据加密的时候遇到了一些问题。起初采取的方案是DES加密，老大说DES加密是对称的，网络抓包加上反编译可能会被破解，故采取RSA方式加密。RSA加密时需要公钥和私钥，客户端保存公钥加密数据，服务器保存私钥解密数据。（iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签）。</p>
<h3 id="问题1：iOS端公钥加密的数据用Java端私钥解密"><a href="#问题1：iOS端公钥加密的数据用Java端私钥解密" class="headerlink" title="问题1：iOS端公钥加密的数据用Java端私钥解密"></a>问题1：iOS端公钥加密的数据用Java端私钥解密</h3><p>iOS无论使用系统自带的sdk函数，用mac产生的或者使用java的jdk产生的公钥和私钥，进行加密解密自己都可以使用。不过ios加密，java解密，或者反过来就不能用了。要么是无法创建报告个-9809或-50的错误，要么解出来是乱码。ios系统函数种只有用公钥加密，私钥解密的方式。而公钥加密每次结果都不同。</p>
<h3 id="MAC上生成公钥、私钥的方法，及使用"><a href="#MAC上生成公钥、私钥的方法，及使用" class="headerlink" title="MAC上生成公钥、私钥的方法，及使用"></a>MAC上生成公钥、私钥的方法，及使用</h3><ul>
<li>打开终端，切换到自己想输出的文件夹下</li>
<li>输入指令:<code>openssl</code>（openssl是生成各种秘钥的工具，mac已经嵌入</li>
<li>.输入指令:<code>genrsa -out rsa_private_key.pem 1024</code> (生成私钥，java端使用的)</li>
<li>输入指令:<code>rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout</code> (生成公钥)</li>
<li>.输入指令:<code>pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt</code>(私钥转格式，在ios端使用私钥解密时用这个私钥)</li>
</ul>
<p>注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端）</p>
<p><a href="http://blog.sina.com.cn/s/blog_12c8ae0d80102vy21.html" target="_blank" rel="noopener">详细步骤</a></p>
<h4 id="服务器返回数据也要加密，老大打算用java私钥加密-ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式"><a href="#服务器返回数据也要加密，老大打算用java私钥加密-ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式" class="headerlink" title="服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式"></a>服务器返回数据也要加密，老大打算用java私钥加密,ios用公钥解密（由于iOS做不到用私钥加密公钥解密，只能私钥加密公钥验签），所以这种方案也有问题。通过看一些大牛的介绍，了解了iOS常用的加密方式</h4><ul>
<li>通过简单的URLENCODE ＋ BASE64编码防止数据明文传输</li>
<li>对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验</li>
<li>对于重要数据，使用RSA进行数字签名，起到防篡改作</li>
<li>对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密</li>
</ul>
<p>因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；如果使用DES的话，可以通过破解客户端获取密钥，安全性较低。而服务器返回之所以使用DES，是因为不管使用DES还是RSA，密钥（或私钥）都存储在客户端，都存在被破解的风险，因此，需要采用动态密钥，而RSA的密钥生成比较复杂，不太适合动态密钥，并且RSA速度相对较慢，所以选用DES）</p>
<p>所以此次加密，我们选择了第四种加密方式</p>
<h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><h4 id="iOS端进行DES加密、解密时非常方便"><a href="#iOS端进行DES加密、解密时非常方便" class="headerlink" title="iOS端进行DES加密、解密时非常方便"></a>iOS端进行DES加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;DES3Util.h&quot;</span><br><span class="line">2、加密时调用类方法  +(NSString *) encryptUseDES:(NSString *)plainText key:(NSString *)key;</span><br><span class="line">3、解密时调用类方法  +(NSString *)decryptUseDES:(NSString *)cipherText key:(NSString *)key;</span><br></pre></td></tr></table></figure>

<h4 id="iOS端进行RSA加密、解密时非常方便"><a href="#iOS端进行RSA加密、解密时非常方便" class="headerlink" title="iOS端进行RSA加密、解密时非常方便"></a>iOS端进行RSA加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;RSAUtil.h&quot;</span><br><span class="line">2、公钥加密时调用类方法：</span><br><span class="line">+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;</span><br><span class="line">+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;</span><br><span class="line">3、私钥解密时调用类方法 </span><br><span class="line">+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;</span><br><span class="line">+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey;</span><br></pre></td></tr></table></figure>

<h4 id="iOS端进行MD5加密、解密时非常方便"><a href="#iOS端进行MD5加密、解密时非常方便" class="headerlink" title="iOS端进行MD5加密、解密时非常方便"></a>iOS端进行MD5加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;MD5Util&quot;</span><br><span class="line">2、加密时调用方法：- (NSString *)md5:(NSString *)str;</span><br></pre></td></tr></table></figure>
<h4 id="iOS端进行AES加密、解密时非常方便"><a href="#iOS端进行AES加密、解密时非常方便" class="headerlink" title="iOS端进行AES加密、解密时非常方便"></a>iOS端进行AES加密、解密时非常方便</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、引入头文件 #import &quot;AES.h&quot;</span><br><span class="line">2、加密时调用方法</span><br><span class="line">+ (NSString *)encrypt:(NSString *)message password:(NSString *)password;</span><br><span class="line">2、解密时调用的方法</span><br><span class="line">+ (NSString *)decrypt:(NSString *)base64EncodedString password:(NSString *)password;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/2927ca2b3719" target="_blank" rel="noopener">有关RSA、MD5、AES加密的原理介绍</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>cocoapods依赖关系可视化</title>
    <url>/2019/03/21/cocoapodsVisual/</url>
    <content><![CDATA[<p><a href="https://www.weichao.ren/ios/2018/12/27/cocoapods-graph/" target="_blank" rel="noopener">转载</a></p>
<blockquote>
<p>cocoapods管理的三方库之间有时候存在依赖关系，Podfile.lock藏满了各个版本库的版本号信息和彼此的依赖关系。</p>
</blockquote>
<h3 id="网页可视化导出-cocoapods-graph"><a href="#网页可视化导出-cocoapods-graph" class="headerlink" title="网页可视化导出-cocoapods-graph"></a>网页可视化导出-cocoapods-graph</h3><p>终端安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install cocoapods-graph</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>使用方式</p>
<p>进入到工程的根目录，执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cocoapods-graph -f Podfile.lock --html</span><br></pre></td></tr></table></figure>

<h3 id="图片可视化导出"><a href="#图片可视化导出" class="headerlink" title="图片可视化导出"></a>图片可视化导出</h3><p>终端安装插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods-dependencies</span><br><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure>
<p>使用方式:<br>进入到工程的根目录，执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod dependencies [PODSPEC] [--graphviz] [--image]</span><br></pre></td></tr></table></figure>

<p>Use the –graphviz option to generate .gv or Podfile.gv containing the dependency graph in graphviz format.</p>
<p>Use the –image option to generate .png or Podfile.png containing a rendering of the dependency graph.</p>
<p>[!] Note that for either graphviz or image output, GraphViz must be installed and dot must be accessible via $PATH.</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>用Cocoapods制作属于自己的仓库</title>
    <url>/2018/12/21/MakeCocoapods/</url>
    <content><![CDATA[<blockquote>
<p>在开发的过程中很多功能模块可能会在同一个App的不同的业务模块出现，也可能在不同的App出现，为了提高我们的开发效率，我们应该将普遍使用的功能模块封装成组件，并通过Cocoapods来管理</p>
</blockquote>
<p><a href="https://cyrill.win/articles/2016/12/04/pod-trunk" target="_blank" rel="noopener">利用pod trunk发布程序</a></p>
<a id="more"></a>

<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk register 邮箱 &#39;用户名&#39; --description&#x3D;&#39;电脑描述&#39;</span><br></pre></td></tr></table></figure>
<h3 id="查收邮件"><a href="#查收邮件" class="headerlink" title="查收邮件"></a>查收邮件</h3><ul>
<li>如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱”</li>
<li>点击邮件中的链接： <a href="https://trunk.cocoapods.org/sessions/verify/xxxx" target="_blank" rel="noopener">https://trunk.cocoapods.org/sessions/verify/xxxx</a></li>
</ul>
<h3 id="查看个人信息"><a href="#查看个人信息" class="headerlink" title="查看个人信息"></a>查看个人信息</h3><ul>
<li>pod trunk me</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Name:     &#39;Cyrill&#39;</span><br><span class="line">- Email:    lichunyang@outlook.com</span><br><span class="line">- Since:    December 4th, 2016 21:22</span><br><span class="line">- Pods:     None</span><br><span class="line">- Sessions:</span><br><span class="line">- December 4th, 2016 21:22 - July 13th, 21:00. IP: 103.244.255.84 Description: ‘MacbookProOfCyrill’</span><br></pre></td></tr></table></figure>
<p>中间可能遇到这种错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NoMethodError - undefined method &#39;last&#39; for #&lt;Netrc::Entry:0x007fc59c246378&gt;</span><br></pre></td></tr></table></figure>
<p>这时候需要尝试更新gem源或者pod</p>
<ul>
<li>sudo gem update –system</li>
<li>sudo gem install cocoapods</li>
<li>sudo gem install cocospods-trunk</li>
</ul>
<h3 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h3><p>接下来需要在项目根路径创建一个podspec文件来描述你的项目信息</p>
<ul>
<li>pod spec cretae 文件名 (比如pod spec cretae MJExtension就会生成一个MJExtension.podspec)</li>
</ul>
<h3 id="填写podspec内容"><a href="#填写podspec内容" class="headerlink" title="填写podspec内容"></a>填写podspec内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># spec开始  s作为spec的别名</span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">    # 项目名称</span><br><span class="line">    s.name         &#x3D; &quot;CYPhotoLib&quot;  </span><br><span class="line">    # 版本号</span><br><span class="line">    s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">    # 简介</span><br><span class="line">    s.summary      &#x3D; &quot;A photo selection framework used PhotoLib.&quot;</span><br><span class="line">    # 项目地址，主页</span><br><span class="line">    s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;CoderCYLee&#x2F;CYPhotoLib&quot;</span><br><span class="line">    # 开源协议</span><br><span class="line">    s.license      &#x3D; &quot;MIT&quot;</span><br><span class="line">    # 作者</span><br><span class="line">    s.author             &#x3D; &#123; &quot;Cyrill&quot; &#x3D;&gt; &quot;lichunyang@outlook.com&quot; &#125;</span><br><span class="line">    # 作者的社交url</span><br><span class="line">    s.social_media_url   &#x3D; &quot;http:&#x2F;&#x2F;weibo.com&#x2F;exceptions&quot;</span><br><span class="line">    # 支持最低ios版本</span><br><span class="line">    s.platform     &#x3D; :ios, &quot;8.0&quot;</span><br><span class="line">    # 代码的git源地址 这里的tag&#x3D;&gt;&quot;#&#123;s.version&#125;&quot; 引用了上面的s.version  如果，在打tag的时候是用的  git tag &#39;v1.0.0&#39;  那么这里需要使用   tag &#x3D;&gt; &quot;v#&#123;s.version&#125;&quot; </span><br><span class="line">    s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;CoderCYLee&#x2F;CYPhotoLib.git&quot;, :tag &#x3D;&gt; s.version &#125;</span><br><span class="line">    # 项目需要用到的ios framework </span><br><span class="line">    s.frameworks &#x3D; &quot;UIKit&quot;, &quot;Photos&quot;</span><br><span class="line">    # 项目中用到的库</span><br><span class="line">    # s.libraries    &#x3D; &quot;stdc++ </span><br><span class="line">    # 代码文件</span><br><span class="line">    s.source_files  &#x3D; &quot;CYPhotoLib&#x2F;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line">    # 资源文件</span><br><span class="line">    s.resources &#x3D; &quot;CYPhotoLib&#x2F;Resource&#x2F;*.png&quot;</span><br><span class="line">    # 是否ARC</span><br><span class="line">    s.requires_arc &#x3D; true</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag 0.0.1</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<ul>
<li>删除tag</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d 1.0</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;1.0</span><br><span class="line">git tag -a 1.0 -m &quot;Version 1.0&quot;</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<h3 id="检测podspec语法"><a href="#检测podspec语法" class="headerlink" title="检测podspec语法"></a>检测podspec语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint CYPhotoLib.podspec</span><br><span class="line"></span><br><span class="line">pod lib lint CYPhotoLib.podspec</span><br><span class="line"></span><br><span class="line">pod spec相对于pod lib会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。</span><br></pre></td></tr></table></figure>
<h3 id="发布podspec"><a href="#发布podspec" class="headerlink" title="发布podspec"></a>发布podspec</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push CYPhotoLib.podspec</span><br><span class="line">如果是第一次发布pod，需要去 https:&#x2F;&#x2F;trunk.cocoapods.org&#x2F;claims&#x2F;new 认领pod</span><br></pre></td></tr></table></figure>
<p>有可能出现的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod lib lint 的时候是通过了的，没有错误</span><br><span class="line">然后 pod trunk push 的时候报错，如下：</span><br><span class="line">    [iOS] unknown: Encountered an unknown error (Pod::DSLError) during validation.</span><br><span class="line">解决：这种状况有可能是git的tag和podspec的tag不对</span><br></pre></td></tr></table></figure>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod setup : 初始化</span><br><span class="line">pod repo update : 更新仓库</span><br><span class="line">pod search CYPhotoLib</span><br></pre></td></tr></table></figure>

<h3 id="仓库更新"><a href="#仓库更新" class="headerlink" title="仓库更新"></a>仓库更新</h3><p>如果仓库更新慢，可以考虑更换仓库镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo remove master</span><br><span class="line">pod repo add master http:&#x2F;&#x2F;git.oschina.net&#x2F;akuandev&#x2F;Specs.git</span><br></pre></td></tr></table></figure>

<h3 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h3><ol>
<li>每次修改完代码，podspec内容的version字段都要修改，否则一直会读取原来的内容</li>
<li>podspec的version字段和git提交的tag需要保持相同的</li>
<li>代码中引入三方库的时候，不要用 <code>#import&quot;xxx.h&quot;</code>,要通过<code>#import&lt;xxx/xxxx.h&gt;</code>来引入，否则的话，会报 <code>include of non-modular header inside framework module “xxx.h”</code>的错误</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins自动打包搭建之路</title>
    <url>/2018/04/21/Jenkins/</url>
    <content><![CDATA[<blockquote>
<p>本文的大部分步骤参考的是<a href="https://halfrost.com/ios_jenkins/" target="_blank" rel="noopener">一缕殇流化隐半边冰霜的博客</a>，所以截图和很多步骤都是直接拷贝的该博客，然后补充了自己踩的一些坑。最后的脚本问题我没有拷贝过来，如果大家希望有所了解，可以去原博客，本文主要是个人以后回忆所用</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h3><blockquote>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
</blockquote>
<h3 id="为什么使用持续集成"><a href="#为什么使用持续集成" class="headerlink" title="为什么使用持续集成"></a>为什么使用持续集成</h3><ol>
<li>减少重复过程</li>
<li>减少风险</li>
<li>任何时间、任何地点生成可部署的软件</li>
<li>增强项目的可见性</li>
</ol>
<h3 id="环境准备步骤"><a href="#环境准备步骤" class="headerlink" title="环境准备步骤"></a>环境准备步骤</h3><p>现在我们来开始安装Jenkins。从<a href="https://jenkins.io/zh/" target="_blank" rel="noopener">官网</a> 上下载最新的pkg安装包。但是，这个时候直接安装是装不上的，Jenkins依赖于Java运行环境，因此需要首先安装<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">Java的SDK</a>。</p>
<p>下载JAVA的SDK，并安装。安装完成后，打开终端，cd进入到jenkins.war包所在目录，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war --httpPort&#x3D;8080</span><br></pre></td></tr></table></figure>

<p>httpPort指的就是Jenkins所使用的http端口，这里指定8080(默认的就是这个)，可根据具体情况来修改。待Jenkins启动后，在浏览器页面输入以下地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

<p>这样就打开Jenkins管理页面了。这个时候Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开<code>http://localhost:8080</code> 会出现下图的重设初始密码的界面。</p>
<p><img src="http://note.youdao.com/yws/res/1298/WEBRESOURCEd5879d0b987483584e7210f42c1ae538" alt="jenkins02.png"></p>
<p>按照提示，找到<code>/Users/Shared/Jenkins/Home/</code>这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。<br><img src="http://note.youdao.com/yws/res/1306/WEBRESOURCE59136e0f76e9485dabf6aa11c831eed8" alt="jenkins03.png"><br><img src="http://note.youdao.com/yws/res/1325/WEBRESOURCEb870694f4f95091ef1f27c2af4c949e7" alt="jenkins04.png"></p>
<p>打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图<br><img src="http://note.youdao.com/yws/res/1313/WEBRESOURCEd98e678c651a6f7982898b20a44e0603" alt="jenkins05.png"><br><img src="http://note.youdao.com/yws/res/1321/WEBRESOURCE4633044a8998eb9ca1d6762983820209" alt="jenkins06.png"></p>
<p><img src="http://note.youdao.com/yws/res/1330/WEBRESOURCE0f51f72be50dc888890f7ccedbed70e5" alt="jenkins07.png"><br><img src="http://note.youdao.com/yws/res/1333/WEBRESOURCE8248226bda9083f7462b405cdab99b56" alt="jenkins08.png"><br><img src="http://note.youdao.com/yws/res/1336/WEBRESOURCE89de23a6fb116f2d4c67b70ecf0fcc94" alt="jenkins09.png"></p>
<p>一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。Jenkins安装完成之后，需要安装一些插件。</p>
<h3 id="安装GitLab插件"><a href="#安装GitLab插件" class="headerlink" title="安装GitLab插件"></a>安装GitLab插件</h3><p>GitLab用来管理源代码，Jenkins本身并没有自带GitLab插件，所以我们需要依次选择 系统管理-&gt;管理插件，在“可选插件”中选中<code>“GitLab Plugin”</code>和<code>“Gitlab Hook Plugin”</code>这两项，然后安装。</p>
<h3 id="安装Xcode插件"><a href="#安装Xcode插件" class="headerlink" title="安装Xcode插件"></a>安装Xcode插件</h3><p>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中<code>“Xcode integration”</code>安装。</p>
<h3 id="安装签名证书管理插件"><a href="#安装签名证书管理插件" class="headerlink" title="安装签名证书管理插件"></a>安装签名证书管理插件</h3><p>OS打包内测版时，需要发布证书及相关签名文件，因此这两个插件对于管理iOS证书非常方便。还是在系统管理-&gt;管理插件，在“可选插件”中选中<code>“Credentials Plugin”</code>和<code>“Keychains and Provisioning Profiles Management”</code>安装。</p>
<h3 id="安装脚本插件"><a href="#安装脚本插件" class="headerlink" title="安装脚本插件"></a>安装脚本插件</h3><p>这个插件的功能主要是用于在build后执行相关脚本。在系统管理-&gt;管理插件，在“可选插件”中选中<code>“Post-Build Script Plug-in”</code>安装。</p>
<p>安装完了插件，我们就可以配置一个构建项目了。</p>
<p><img src="http://note.youdao.com/yws/res/1359/WEBRESOURCE27388c3022800f5ece02c453024d61b9" alt="jenkins10.png"><br><img src="http://note.youdao.com/yws/res/1363/WEBRESOURCE7404116416dd889fe751ef3d0781c338" alt="jenkins11.png"></p>
<p>点击新建好的项目，进来配置一下General参数。<br>接着设置源码管理。<br>由于现在我用到的是Github，在Jenkins的证书管理中添加账号、密码。在Jenkins管理页面，选择<code>“Credentials”</code>，然后选择<code>“Global credentials (unrestricted)”</code>，点击<code>“Add Credentials”</code>，如下图所示，我们填写自己的账号密码信息，然后点击<code>“Save”</code>，这样就把账号密码添加到Jenkins的全局域中去了</p>
<p><img src="http://note.youdao.com/yws/res/1369/WEBRESOURCE2bd3fae9e340547143ee8ed6c23b7f86" alt="jenkins12.png"></p>
<p>如果正常的配置正确的话，是不会出现下图中的那段红色的警告。如果有下图的提示，就说明Jenkins还没有连通Github或者SVN，那就请再检查账号密码是否配置正确。</p>
<p><img src="http://note.youdao.com/yws/res/1373/WEBRESOURCE8edf202168e3b8f0cf12cf79f804d01e" alt="jenkins13.png"></p>
<p>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。<br>不过这里有两个配置还是需要是配置的<br><code>Poll SCM (poll source code management)</code>轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br><code>Build periodically</code>(定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>
<p>格式是这样的</p>
<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>
<p><img src="http://note.youdao.com/yws/res/1378/WEBRESOURCEefbc4ef07d4183f5ee0b8e17fc342120" alt="jenkins14.png"></p>
<h3 id="构建环境设置"><a href="#构建环境设置" class="headerlink" title="构建环境设置"></a>构建环境设置</h3><p>iOS打包需要签名文件和证书，所以这部分我们勾选<code>“Keychains and Code Signing Identities”</code>和<code>“Mobile Provisioning Profiles”</code>。<br>这里我们又需要用到Jenkins的插件，在系统管理页面，选择<code>“Keychains and Provisioning Profiles Management”</code>。</p>
<p><img src="http://note.youdao.com/yws/res/1386/WEBRESOURCE990306bccdcefdecca63a78321bdf836" alt="jenkins15.png"></p>
<p><img src="http://note.youdao.com/yws/res/1389/WEBRESOURCEa808abd84a06ad96d3b37e88d988aa83" alt="jenkins16.png"></p>
<p>注意：这里可以上传的一种是<code>login.keychain</code>文件一种是<code>ProvisioningProfiles</code>文件。这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名<code>/Library/keychains/login.keychain</code>,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到<code>/Users/Shared/Jenkins/Library/keychains</code>这里，(Library是隐藏文件)。Tips:后面的Code Signing Identity里面的开发者账号是手写的，而不是上传完keychain文件之后，自动识别的，这里坑了我好久</p>
<p>找到对应的<code>Provisioning Profiles</code>文件(这个文件不是直接在开发者平台下载下来的文件名字，而是安装到本地之后的文件名)上传之后， <code>Provisioning Profiles</code>也直接拷贝到<code>/Users/Shared/Jenkins/Library/MobileDevic</code>e文件目录下。</p>
<p>Tips: 如图的那个路径也是填写的，而不是上传后直接识别的，同上。</p>
<p>这样证书和签名文件就在Jenkins中配置好了，接下来我们只需要在item设置中指定相关文件即可。 回到我们新建的item，找到构建环境，按下图选好自己的相关证书和签名文件。Tips：在这里有时候你发现上传完上面的文件并填写完相应的账号和路径之后，点击下拉箭头，啥都没有，这个时候点击保存，然后退出，从新进来配置，多试几次。</p>
<p><img src="http://note.youdao.com/yws/res/1397/WEBRESOURCEcc2a06e472a6ae0e64296f0279fca262" alt="jenkins17.png"></p>
<p>接下来在进行构建的设置，这里没有用Xcode插件，用的是执行脚本。我本地项目Xcode证书和描述文件不是自动配置的，而是手动选择的。本地配置好之后，一定要执行git上传到远程仓库。</p>
<p>在导出ipa包的时候，注意xcodebuild 命令，里面选项配置是一个plist文件，我在下面贴出来plist内容</p>
<p><img src="http://note.youdao.com/yws/res/1401/WEBRESOURCEb45964a4fc4489c3a1ac574bf03e633e" alt="jenkins18.png"></p>
<h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 工程名</span><br><span class="line">APP_NAME&#x3D;&quot;KIFTestDemo&quot;  </span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION&#x3D;&quot;iPhone Distribution: China Mobile Group Guangdong Company Limited&quot;  </span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path&#x3D;&quot;.&#x2F;$&#123;APP_NAME&#125;&#x2F;Info.plist&quot;</span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">#取build值</span><br><span class="line">bundleVersion&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE&#x3D;&quot;$(date +%Y%m%d)&quot;  </span><br><span class="line">IPANAME&#x3D;&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;.ipa&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">IPA_PATH&#x3D;&quot;$HOME&#x2F;$&#123;IPANAME&#125;&quot;  </span><br><span class="line">echo $&#123;IPA_PATH&#125;  </span><br><span class="line">echo &quot;$&#123;IPA_PATH&#125;&quot;&gt;&gt; text.txt</span><br><span class="line">RchivePath&#x3D;&quot;.&#x2F;KIFTestDemo.xcarchive&quot;</span><br><span class="line">IPAPath&#x3D;&quot;.&#x2F;KIFTestDemoipa&quot;</span><br><span class="line">optionsPlist&#x3D;&quot;.&#x2F;EnterpriseExportOptions.plist&quot;  </span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;  </span><br><span class="line">xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme &quot;$&#123;APP_NAME&#125;&quot;  -configuration &#39;Release&#39; clean</span><br><span class="line">echo &quot;+++++++++++++++++build+++++++++++++++++&quot;  </span><br><span class="line">xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme &quot;$&#123;APP_NAME&#125;&quot; -sdk iphoneos -configuration &#39;Release&#39; -archivePath $RchivePath</span><br><span class="line">xcodebuild -exportArchive -archivePath $RchivePath -exportPath $IPAPath   -exportOptionsPlist $optionsPlist</span><br><span class="line">plist内容</span><br></pre></td></tr></table></figure>

<h3 id="plist内容"><a href="#plist内容" class="headerlink" title="plist内容"></a>plist内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;&#x2F;key&gt;</span><br><span class="line">&lt;false&#x2F;&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.gmcc.gdmobileimoa&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ee4c1dc2-cf62-41d5-9871-93f0abbacad5&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;key&gt;method&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>
<h3 id="构建后，将ipa包上传到蒲公英"><a href="#构建后，将ipa包上传到蒲公英" class="headerlink" title="构建后，将ipa包上传到蒲公英"></a>构建后，将ipa包上传到蒲公英</h3><p><img src="http://note.youdao.com/yws/res/1414/WEBRESOURCE47afdfde035cb2c30bee8744ef45af41" alt="jenkins19.png"></p>
<h3 id="构建后脚本内容"><a href="#构建后脚本内容" class="headerlink" title="构建后脚本内容"></a>构建后脚本内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">蒲公英上的User Key</span><br><span class="line">uKey&#x3D;&quot;24d26944ee1ffacec4faeb1ac73a0a48&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey&#x3D;&quot;8d418599c52f8bf47f6cd7db1c3116b7&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">IPA_PATH&#x3D;&quot;.&#x2F;KIFTestDemoipa&#x2F;KIFTestDemo.ipa&quot;</span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey&#x3D;$&#123;uKey&#125;&quot; -F &quot;_api_key&#x3D;$&#123;apiKey&#125;&quot; http:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>
<p>这里我们选择<code>Execute a set of scripts</code>，这里也是一个脚本，这个脚本用来上传自动打包好的ipa文件。</p>
<p>至此，我们的Jenkins设置就全部完成了。点击构建，就会开始构建项目了。</p>
<p>构建一次，各个颜色代表的意义如下：</p>
<p><img src="http://note.youdao.com/yws/res/1423/WEBRESOURCE0fe47eda22ef39d06d8cb4e1ef58c791" alt="jenkins20.png"></p>
<p>如果构建失败了，可以去查看Console Output可以查看log日志。</p>
<p><img src="http://note.youdao.com/yws/res/1427/WEBRESOURCE6379bd2c3fcd8456c6462b5d993efb65" alt="jenkins21.png"></p>
<h3 id="Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充"><a href="#Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充" class="headerlink" title="Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充"></a>Jenkins自动打包，断断续续持续了一年才成功，开始的时候一直失败，中间一段时间因为没有时间尝试，最近重新拾起来了。遇到的坑，我想起来的时候，会持续补充</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://halfrost.com/ios_jenkins/" target="_blank" rel="noopener">手把手教你利用 Jenkins 持续集成 iOS 项目</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>OCSQLCipher</title>
    <url>/2018/03/21/OCSQLCipher/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据安全越来越成为生活中非常重要的问题，用户隐私泄露的问题时有发生，如何保护用户数据的安全，越来越成为一个负责公司有限考虑的问题。本篇文章不涉及接口安全、传输安全等方面，只是对App使用的sqlite数据库安全做分析。</p>
<a id="more"></a>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>使用SQLite数据库的时候，有时候对于数据库要求比较高，特别是在iOS8.3之前，未越狱的系统也可以通过工具拿到应用程序沙盒里面的文件，这个时候我们就可以考虑对SQLite数据库进行加密，这样就不用担心sqlite文件泄露了</p>
<p>通常数据库加密一般有两种方式</p>
<p>对所有数据进行加密<br>对数据库文件加密<br>第一种方式虽然加密了数据，但是并不完全，还是可以通过数据库查看到表结构等信息，并且对于数据库的数据，数据都是分散的，要对所有数据都进行加解密操作会严重影响性能，通常的做法是采取对文件加密的方式</p>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>LZ接手的项目原来使用cocoapod导入过FMDB,因为项目本身SVN管理的问题，原本不打算使用cocoapod导入SQLCipher,但是尝试过网上的解决方案但是没有加密成功，最后还是使用cocoapod导入的。</p>
<p><code>pod ‘FMDB/SQLCipher’, ‘~&gt; 2.6.2’</code></p>
<p>确保自己的cocoapod版本号可以导入该库,LZ的cocoapod库原本是0.0.39版本的，老是报错，最后只得升级,如果原来的版本低于1.0.0，要注意修改podfile文件的格式</p>
<p>导入成功后，打开<code>FMDatabase.m</code>文件，找到下面的一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)open &#123;</span><br><span class="line">  if (_db) &#123;</span><br><span class="line">  return YES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">int err &#x3D; sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db );</span><br><span class="line">if(err !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">&#x2F;&#x2F; set the handler</span><br><span class="line">[self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F;数据库open后设置加密key</span><br><span class="line">[self setKey:encryptKey_];</span><br><span class="line">&#125;   </span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName &#123;</span><br><span class="line"></span><br><span class="line"># if SQLITE_VERSION_NUMBER &gt;&#x3D; 3005000</span><br><span class="line"></span><br><span class="line">if (_db) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int err &#x3D; sqlite3_open_v2([self sqlitePath], (sqlite3**)&amp;_db, flags, [vfsName UTF8String]);</span><br><span class="line">if(err !&#x3D; SQLITE_OK) &#123;</span><br><span class="line">NSLog(@&quot;error opening!: %d&quot;, err);</span><br><span class="line">return NO;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;数据库open后设置加密key</span><br><span class="line">[self setKey:encryptKey_];</span><br><span class="line">&#125;</span><br><span class="line">if (_maxBusyRetryTimeInterval &gt; 0.0) &#123;</span><br><span class="line">&#x2F;&#x2F; set the handler</span><br><span class="line">[self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line"># else</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;openWithFlags requires SQLite 3.5&quot;);</span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步就可以在初始化数据库时对数据库进行加密</p>
<p>通过客户端验证是否可以读取数据库信息<br>取到app中的数据库<br>真机连接<code>xcode-&gt;window-&gt;Devices</code></p>
<p>将会得到下面的文件，然后右键显示包含内容，找到自己创建的数据库</p>
<p>打开数据库的工具,笔者使用的是<a href="https://www.waitsun.com/navicat-premium-11-1-15.html" target="_blank" rel="noopener">Navicat Premium</a></p>
<p>打开Navicat Premium,链接数据库，选择sqlite</p>
<p>选中本地保存的数据库文件，点击ok打开</p>
<p>将会提示</p>
<p>提醒</p>
<p>注意:笔者这里修改的是源码，是因为接手的工程FMDB又被封装，更改起来比较困难，为了不修改FMDB的源代码，可以继承自FMDatabase类重写需要setKey的几个方法，具体写法可见demo,到这一步就可以在初始化数据库时对数据库进行加密，不过很多情况下，我们可能会遇到对已经存在的数据库进行加密</p>
<p>SQLite数据库加解密</p>
<p>SQLCipher提供了几个命令用于加解密操作</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;sqlcipher plaintext.db  </span><br><span class="line">sqlite&gt; ATTACH DATABASE &#39;encrypted.db&#39; AS encrypted KEY &#39;testkey&#39;;  </span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&#39;encrypted&#39;);  </span><br><span class="line">sqlite&gt; DETACH DATABASE encrypted;</span><br></pre></td></tr></table></figure>
<ul>
<li>打开非加密数据库</li>
<li>创建一个新的加密的数据库附加到原数据库上</li>
<li>导出数据到新数据库上</li>
<li>卸载新数据库</li>
</ul>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; PRAGMA key &#x3D; &#39;testkey&#39;;  </span><br><span class="line">sqlite&gt; ATTACH DATABASE &#39;plaintext.db&#39; AS plaintext KEY &#39;&#39;;  -- empty key will disable encryption</span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&#39;plaintext&#39;);  </span><br><span class="line">sqlite&gt; DETACH DATABASE plaintext;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开加密数据库</li>
<li>创建一个新的不加密的数据库附加到原数据库上</li>
<li>导出数据到新数据库上</li>
<li>卸载新数据库</li>
</ul>
<h3 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** encrypt sqlite database to new file *&#x2F;</span><br><span class="line"></span><br><span class="line">+ (BOOL)encryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey</span><br><span class="line">&#123;</span><br><span class="line">const char* sqlQ &#x3D; [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS encrypted KEY &#39;%@&#39;;&quot;, targetPath, encryptKey] UTF8String];</span><br><span class="line">sqlite3 *unencrypted_DB;</span><br><span class="line">if (sqlite3_open([sourcePath UTF8String], &amp;unencrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">char *errmsg;</span><br><span class="line">&#x2F;&#x2F; Attach empty encrypted database to unencrypted database</span><br><span class="line">sqlite3_exec(unencrypted_DB, sqlQ, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export database</span><br><span class="line">sqlite3_exec(unencrypted_DB, &quot;SELECT sqlcipher_export(&#39;encrypted&#39;);&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Detach encrypted database</span><br><span class="line">sqlite3_exec(unencrypted_DB, &quot;DETACH DATABASE encrypted;&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(unencrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(unencrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** decrypt sqlite database to new file *&#x2F;</span><br><span class="line">+ (BOOL)unEncryptDatabase:(NSString *)sourcePath targetPath:(NSString *)targetPath encryptKey:(NSString *)encryptKey</span><br><span class="line">&#123;</span><br><span class="line">const char* sqlQ &#x3D; [[NSString stringWithFormat:@&quot;ATTACH DATABASE &#39;%@&#39; AS plaintext KEY &#39;&#39;;&quot;, targetPath] UTF8String];</span><br><span class="line">sqlite3 *encrypted_DB;</span><br><span class="line">if (sqlite3_open([sourcePath UTF8String], &amp;encrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">char* errmsg;</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key &#x3D; &#39;%@&#39;;&quot;, encryptKey] UTF8String], NULL, NULL, &amp;errmsg);</span><br><span class="line">&#x2F;&#x2F; Attach empty unencrypted database to encrypted database</span><br><span class="line">sqlite3_exec(encrypted_DB, sqlQ, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export database</span><br><span class="line">sqlite3_exec(encrypted_DB, &quot;SELECT sqlcipher_export(&#39;plaintext&#39;);&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Detach unencrypted database</span><br><span class="line">sqlite3_exec(encrypted_DB, &quot;DETACH DATABASE plaintext;&quot;, NULL, NULL, &amp;errmsg);</span><br><span class="line">if (errmsg) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:errmsg]);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** change secretKey for sqlite database *&#x2F;</span><br><span class="line">+ (BOOL)changeKey:(NSString *)dbPath originKey:(NSString *)originKey newKey:(NSString *)newKey</span><br><span class="line">&#123;</span><br><span class="line">sqlite3 *encrypted_DB;</span><br><span class="line">if (sqlite3_open([dbPath UTF8String], &amp;encrypted_DB) &#x3D;&#x3D; SQLITE_OK) &#123;</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA key &#x3D; &#39;%@&#39;;&quot;, originKey] UTF8String], NULL, NULL, NULL);</span><br><span class="line">sqlite3_exec(encrypted_DB, [[NSString stringWithFormat:@&quot;PRAGMA rekey &#x3D; &#39;%@&#39;;&quot;, newKey] UTF8String], NULL, NULL, NULL);</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sqlite3_close(encrypted_DB);</span><br><span class="line">NSAssert1(NO, @&quot;Failed to open database with message &#39;%s&#39;.&quot;, sqlite3_errmsg(encrypted_DB));</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>SQLCipher使用起来还是很方便的，基本上不需要怎么配置，需要注意的是，尽量不要在操作过程中修改secretKey，否则，可能导致读不了数据，在使用第三方库的时候尽量不去修改源代码，可以通过扩展或继承的方式修改原来的行为，这样第三方库代码可以与官方保持一致，可以跟随官方版本升级，具体代码可以到<a href="https://github.com/zhengbomo/sqlcipherDemo" target="_blank" rel="noopener">github上下载</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>致---25岁的自己,路过的都是风景，留下的都是青春</title>
    <url>/2016/03/21/25Birthday/</url>
    <content><![CDATA[<p>今天重感冒，鼻子不通气，喉咙巨疼，不停地咳嗽。推算着大概快到25岁了，翻了一下日历，没想到就是今天，差一点错过。像极了自己的人生的前25年，好像很有目标，其实就是浑浑噩噩的过来了，没有大悲大喜，平庸的一无是处。</p>
<a id="more"></a>
<p>其实，早就奔三了，二十五岁显得尤其特别，像一个关键的节点，我想，是时候回顾一下平凡的过去，给这平凡的二十五年画上一个句号。</p>
<h3 id="青春"><a href="#青春" class="headerlink" title="青春"></a>青春</h3><p>其实，我应该没有资格说了吧，25岁，从法律上讲已经到了一个男孩晚婚的年纪，只不过还想矫情的最后再说一次，以后再也不会了</p>
<p>把自己定位成心智比较早熟的人，15、6岁的时候考虑很多很多事情，现在去翻那时候的日记，我才发现，那些看起来老练的文字只是一个孩子的理想主义。那些建立在旁听来的社会经验、书本和幻想上的人生态度是一个象牙塔的孩子在青春期对青春期的反抗。回想起来，我以一种不可思议的平静度过了整个青春期，没有叛逆，没有歇斯底里。那些幼稚的文字，成为最初的人生观，压制住了青春期的愤怒，也压制住了青春期的荷尔蒙。</p>
<p>从上学到大学毕业，那么那么多课，我缺席的只有两节，一节是初一重感冒，英语课上到一半，烧到不行，打了个点滴；另一节是大学为了体验一次逃课而逃课，而且是不那么重要的马哲，根本没有惊心动魄可言。接近二十年的求学生涯，竟然没有几个印象深刻的瞬间，我太听话了，太守规矩了。我想，未来的某天，不管是和哪个阶段的同学一起回忆的时候，我都不会成为回忆的主角，甚至配角也不是。如果可以，我愿回到当初，打一场假，逃一次课，冒犯一次老师，搞乱一次课堂</p>
<p>之所以做一个规矩的模范生，不敢任性,除了老师引诱，片刻的虚荣，还是因为出生在农村这样一个父母不懂得孩子性格引导、正确的表达情感，价值观确立的环境，一切都要靠自己的野蛮生长，自我调整。需要花费更多的努力获取别人的认同，没有犯错的资本，没有任性的本钱。如果犯错、逃课，除了担负逆子的骂名，我想不到还有什么好的结果，而这确实不是我愿意触碰的底线，实在不想为生活奔波的父母因为我还要到学校跑来跑去，在老师面前毫无尊严可言。</p>
<p>我的每个小小的成绩可能都让父母感到了骄傲，可是对自己而言，确实失去了很多本来可以去回忆的青春，更为遗憾的是，失去了青春成长必须付出的代价，而这一直是我觉得自己性格不够完整的原因。</p>
<h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>年轻哪有资格谈恋爱，花的都是父母的钱<br>15岁左右，也是情窦初开的时候，第一次接触到这句话，加上本身自己就是个有强烈自我约束倾向的人，觉得拒绝早恋是自己的使命，有着对爱情最原始的拒绝。所以，每次前排的女生回过头来温柔的看着我的同桌时，我都在想，又成不了，真浪费时间。尽管我承认那个女生很好看，我也很喜欢。</p>
<p>二十岁的时候，也就是刚上大学的时候，要交学费，加上生活费，每次就要六七千，第一次体会到生活的压力，开学的前一天都不好意思管父母张口要钱。这个时候，确实有了恋爱的时间，也有了恋爱的心里需求，不过这次是真正的觉得恋爱是一场烧钱的游戏，是恋爱不起了。我很想花费心思追一个女生，可是，有资格那么做吗？</p>
<p>二十五岁，工作一年，也攒了一些钱，虽然不多，好歹自足。再去看这句话，完全有了不同的心态：这是哪个圣母说出来的言论！<br>15、6岁在该恋爱的年纪，在该学习处理两性关系的年纪，对早恋的鄙视换来的是未来面对女生的时候的局促，换来的单身，换来的是一个人吃饭时来自老板娘异样的目光。把克制当做骄傲，把懂事当做骄傲，把月考的成绩当做骄傲，把理想当做骄傲，这些所谓的骄傲并没有在后来的人生轨道上起到什么作用，早恋的依然优秀，早恋过程中养成的高情商反而成为进入社会后单身狗并不具备的优势。单身却成为长大以后一个无法辩驳的槽点，被不停地挖苦挖苦。</p>
<p>前几天，老郭发了条微博：这个年龄再谈爱情，会被别人笑话的。我干净利落的回了句：傻逼。毕业之后，似乎真的没有人再谈爱情了，所有人都急着结婚，好像这个世界就要快没有女人了。其实，我真的想再等一等，作为一个满口情怀的伪文艺青年，我真的想用一次心跳加速来结束青春，走进人生的下一个节点。</p>
<p>我想过好多好多浪漫的场景，我想，我遇到一个，大概就会义无反顾的去爱。有时候，我想，妈的，我这么好，没有不良嗜好，不嫖不偷，凭什么做一个接盘侠。可是，这个年纪，，谁还有时间陪你来一场恋爱呢？</p>
<p>前段时间，有几个人给介对象，自己都拒绝了。寻找爱情很难，慢慢的发现，寻找一个合适的也很难很难。</p>
<p>我渴望一场恋爱，然后走进婚姻，仅此而已</p>
<h3 id="友情"><a href="#友情" class="headerlink" title="友情"></a>友情</h3><p>我温和善良的对待认识的每个人，也希望每个人温和善良的对待我，我总在自己的承受能力之内，尽全力做到最好。我总是把自己最好的生活状态呈现给别人，不让别人担心，也不会为别人添加累赘，这并不意味着我的生活没有负担，我没有困难。越来越不想解释，为什么我没有在你困难的时候伸出手来，可能你并不知道，那也是我最困难的时候，只是我没有呈现在你的面前，也没有说出来而已 。</p>
<p>有几个特别好的朋友，从初三到现在接近十年的时间了，初三的时候关系特别好，我一直以为我们会一直是最好的。有一段时间，我发现一个朋友的空间晒了大量的和发小的照片，并配上了大量的兄弟之类的文字，我特别难过，就像一个孩子失去了心爱的玩具。随着长大，有我就慢慢释怀了，每个人都有自己的生活态度，都有自己选择的生活方式，谁都不是谁的必需品。所以，有的时候，要接受朋友最亲近的朋友换成别人的落差。成为朋友那段时间是因为我们刚好遇到，恰好脾气相投，所以我们一起走了一段时间，能一起走下去那当然最好，倘若有一天你发现曾经的某些人消失了，默默地祝福就好，不要怪别人为什么不辞而别，也不要气急败坏的绝交。</p>
<p>某一天，你来了，call我，我会欢喜的请你吃饭，没有call我，即便我知道了自己该干嘛还是干嘛，你没有联系我，可能我不是你最好的朋友了，我没联系你可能因为我也很忙，也可能我不想让已经约了别人的你尴尬，但是你要记住，我对你的感情没有少，依然维持在我们分别的时候，我长大了，不在浮夸的表达自己而已。</p>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>在北京呆了一年半，也不知道还能待多久，还是没有摆脱蜗居的状态，生活并没有明显的改善。</p>
<p>应该读读书了吧，看看自己写的这些没有文采和逻辑的文字<br>应该动一动了吧，周末别老睡觉，找个朋友打场球，吃个饭<br>应该换个房子了吧，住在这里能找到女朋友吗<br>技术上，应该开始稳步前进了吧，既然选择这一行，就好好干，技术上欠缺的还是太多太多。前端，后台，数据结构，算法，swift，都应该涉猎，学会高效和稳定的团队开发，尽然没有敏捷开发就尝试着自己搭建敏捷开发平台，没有单元测试，就自己引入单元测试，没有高效的打包工具，就自己使用jenkins自动化打包，没有用户体验的优化就用产品的心态做好优化。<br>2017年，雷传营，加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>NSScanner,一个陌生的条件判断利器!</title>
    <url>/2016/03/21/NSScanner/</url>
    <content><![CDATA[<p><a href="https://developer.apple.com/documentation/foundation/scanner#//apple_ref/occ/instm/NSScanner/scanInteger:" target="_blank" rel="noopener">NSScanner官方文档</a></p>
<p>NSScanner类是一个<a href="https://baike.baidu.com/item/%E7%B1%BB%E7%B0%87?fr=aladdin" target="_blank" rel="noopener">类簇</a>的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。</p>
<a id="more"></a>

<p>NSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。</p>
<p>由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和<a href="https://developer.apple.com/documentation/foundation/scanner#//apple_ref/doc/uid/20000159-SW1" target="_blank" rel="noopener">Configuring a Scanner</a>方法下面列举的所有的方法。</p>
<p>在 NSScanner 对象扫描字符串的时候，你可以通过设置属性<code>charactersToBeSkipped</code>忽略某些字符。在扫描字符串之前，那些位于<code>忽略字符集</code>中的字符将会被跳过。默认的忽略字符是空格和回车字符。</p>
<p>可以通过<code>[[scanner string] substringFromIndex:[scanner scanLocation]]</code>获取未扫描的字符串。</p>
<h3 id="创建-Scanner对象"><a href="#创建-Scanner对象" class="headerlink" title="创建 Scanner对象"></a>创建 Scanner对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)scannerWithString:(NSString *)aString</span><br><span class="line"></span><br><span class="line">+ (id)localizedScannerWithString:(NSString *)aString</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithString:(NSString *)aString</span><br></pre></td></tr></table></figure>

<ul>
<li>scannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;</li>
<li>localizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;</li>
<li>initWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化</li>
</ul>
<h3 id="获取Scanner的字符串"><a href="#获取Scanner的字符串" class="headerlink" title="获取Scanner的字符串"></a>获取Scanner的字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property(readonly, copy) NSString *string</span><br></pre></td></tr></table></figure>
<h3 id="配置Scanner"><a href="#配置Scanner" class="headerlink" title="配置Scanner"></a>配置Scanner</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property NSUInteger scanLocation</span><br><span class="line">@property BOOL caseSensitive</span><br><span class="line">@property(copy) NSCharacterSet *charactersToBeSkipped</span><br><span class="line">@property(retain) id locale</span><br></pre></td></tr></table></figure>
<ul>
<li>scanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起NSRangeException,该属性在发生错误后重新扫描时非常有用。</li>
<li>caseSensitive，是否区分字符串中大小写的标志。默认为NO，注意：该设置不会应用到<code>被跳过的字符集</code>。</li>
<li>charactersToBeSkipped,在扫描时<code>被跳过的字符集</code>，默认是空白格和回车键。<code>被跳过的字符集</code>优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”};</li>
<li>locale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。</li>
</ul>
<h3 id="扫描字符串"><a href="#扫描字符串" class="headerlink" title="扫描字符串"></a>扫描字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)scanCharactersFromSet:(NSCharacterSet *)scanSet   intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanUpToCharactersFromSet:(NSCharacterSet *)stopSet    intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanString:(NSString *)string  intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanUpToString:(NSString *)stopString   intoString:(NSString * _Nullable *)stringValue;</span><br><span class="line">- (BOOL)scanDecimal:(NSDecimal *)decimalValue;</span><br><span class="line">- (BOOL)scanDouble:(double *)doubleValue;</span><br><span class="line">- (BOOL)scanFloat:(float *)floatValue;</span><br><span class="line">- (BOOL)scanHexDouble:(double *)result;</span><br><span class="line">- (BOOL)scanHexFloat:(float *)result;</span><br><span class="line">- (BOOL)scanHexInt:(unsigned int *)intValue;</span><br><span class="line">- (BOOL)scanHexLongLong:(unsigned long long *)result;</span><br><span class="line">- (BOOL)scanInt:(int *)intValue;</span><br><span class="line">- (BOOL)scanInteger:(NSInteger *)value;</span><br><span class="line">- (BOOL)scanUnsignedLongLong:(unsigned long long *)unsignedLongLongValue;</span><br><span class="line">@property(getter&#x3D;isAtEnd, readonly) BOOL atEnd;</span><br></pre></td></tr></table></figure>

<ul>
<li>scanCharactersFromSet:intoString:扫描字符串中和NSCharacterSet字符集中匹配的字符，是按字符单个匹配的，例如，NSCharacterSet字符集为@”test123Dmo”，scanner字符串为 @” 123test12Demotest”，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为”123test12Demotest”</li>
<li>scanUpToCharactersFromSet:intoString：扫描字符串直到遇到NSCharacterSet字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容</li>
<li>scanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回YES,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，如果当前的扫描位置为0，那么扫描不到，但是如果将扫描位置设置成3，就可以扫描到了。</li>
<li>scanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，存储的内容为123</li>
<li>scanDecimal:扫描NSDecimal类型的值，有关NSDecimal类型的值更多的信息可以查看<a href="ttps://developer.apple.com/documentation/foundation/nsdecimalnumber#//apple_ref/occ/cl/NSDecimalNumber">NSDecimalNumber</a></li>
<li>scanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。</li>
<li>scanFloat：扫描单精度浮点型字符，具体内容同scanDouble</li>
<li>scanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加 0x或者 0X。</li>
<li>scanHexInt 扫描十六进制无符整型，unsigned int指针指向的地址值为 扫描到的值，包含溢出时的UINT_MAX。</li>
<li>scanHexLongLong 同scanHexDouble</li>
<li>scanInt 扫描整型，溢出也被认为是有效的整型，int 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。</li>
<li>scanInteger 同scanInt</li>
<li>scanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ConditionJudgmentController : NSObject</span><br><span class="line">&#x2F;&#x2F;输入框中只能输入数字和小数点，且小数点只能输入一位，参数number 可以设置小数的位数，该函数在-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string调用；</span><br><span class="line">+(BOOL)isValidAboutInputText:(UITextField *)textfield shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string  decimalNumber: (NSInteger) number;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;ConditionJudgmentController.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ConditionJudgmentController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+(BOOL)isValidAboutInputText:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string decimalNumber:(NSInteger)number&#123;</span><br><span class="line"></span><br><span class="line">    NSScanner      *scanner    &#x3D; [NSScanner scannerWithString:string];</span><br><span class="line">    NSCharacterSet *numbers;</span><br><span class="line">    NSRange         pointRange &#x3D; [textField.text rangeOfString:@&quot;.&quot;];</span><br><span class="line">    if ( (pointRange.length &gt; 0) &amp;&amp; (pointRange.location &lt; range.location  || pointRange.location &gt; range.location + range.length) )&#123;</span><br><span class="line">    numbers &#x3D; [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    numbers &#x3D; [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789.&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    if ( [textField.text isEqualToString:@&quot;&quot;] &amp;&amp; [string isEqualToString:@&quot;.&quot;] )&#123;</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    short remain &#x3D; number; &#x2F;&#x2F;保留 number位小数</span><br><span class="line">    NSString *tempStr &#x3D; [textField.text stringByAppendingString:string];</span><br><span class="line">    NSUInteger strlen &#x3D; [tempStr length];</span><br><span class="line">    if(pointRange.length &gt; 0 &amp;&amp; pointRange.location &gt; 0)&#123; &#x2F;&#x2F;判断输入框内是否含有“.”。</span><br><span class="line">    if([string isEqualToString:@&quot;.&quot;])&#123; &#x2F;&#x2F;当输入框内已经含有“.”时，如果再输入“.”则被视为无效。</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    if(strlen &gt; 0 &amp;&amp; (strlen - pointRange.location) &gt; remain+1)&#123; &#x2F;&#x2F;当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSRange zeroRange &#x3D; [textField.text rangeOfString:@&quot;0&quot;];</span><br><span class="line">    if(zeroRange.length &#x3D;&#x3D; 1 &amp;&amp; zeroRange.location &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;判断输入框第一个字符是否为“0”</span><br><span class="line">    if(![string isEqualToString:@&quot;0&quot;] &amp;&amp; ![string isEqualToString:@&quot;.&quot;] &amp;&amp; [textField.text length] &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。</span><br><span class="line">    textField.text &#x3D; string;</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    if(pointRange.length &#x3D;&#x3D; 0 &amp;&amp; pointRange.location &gt; 0)&#123; &#x2F;&#x2F;当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。</span><br><span class="line">    if([string isEqualToString:@&quot;0&quot;])&#123;</span><br><span class="line">    return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *buffer;</span><br><span class="line">if ( ![scanner scanCharactersFromSet:numbers intoString:&amp;buffer] &amp;&amp; ([string length] !&#x3D; 0) )&#123;</span><br><span class="line">    return NO;</span><br><span class="line">    </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:上面的方法要结合UITextField的代理方法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">return [ConditionJudgmentController isValidAboutInputText:textField shouldChangeCharactersInRange:range replacementString:string decimalNumber:3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h3><p>平时读者在进行条件判断时，可能使用正则表达式或者用if语句比较多一点，其实NSScanner类为我们提供了一个非常好的方式进行判断。把它们结合起来使用，可以获得更好的效果。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS：关于iPhone连接Xcode时，RSA加密失败的一点总结</title>
    <url>/2015/12/21/RSAEncryptFail/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>前段时间做RSA加密的时候，在调试的过程中，经常失败，后台接收到的加密参数为空，但是这种不是经常发生，而是随机的。经过测试，发现，这种情况在单独使用真机、模拟器的时候都不发生，只有在真机连接xcode进行调试的时候才会发生。</p>
<a id="more"></a>
<h3 id="追踪："><a href="#追踪：" class="headerlink" title="追踪："></a>追踪：</h3><p>在笔者打了N多断点之后，终于找到了问题发生的根源。在RSA加密的类中，有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFTypeRef persistKey &#x3D; nil;</span><br><span class="line">OSStatus status &#x3D; SecItemAdd((__bridge CFDictionaryRef)publicKey, &amp;persistKey);</span><br><span class="line">if (persistKey !&#x3D; nil)&#123;</span><br><span class="line">CFRelease(persistKey);</span><br><span class="line">&#125;</span><br><span class="line">if ((status !&#x3D; noErr) &amp;&amp; (status !&#x3D; errSecDuplicateItem)) &#123;</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [publicKey removeObjectForKey:(__bridge id)kSecValueData];</span><br><span class="line">       [publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];</span><br><span class="line">       [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];</span><br><span class="line">       [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; Now fetch the SecKeyRef version of the key</span><br><span class="line">       SecKeyRef keyRef &#x3D; nil;</span><br><span class="line">       status &#x3D; SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&amp;keyRef);</span><br><span class="line">           </span><br><span class="line">           if(status !&#x3D; noErr)&#123;</span><br><span class="line">           return nil;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">return keyRef;</span><br></pre></td></tr></table></figure>
<p>在模拟器上测试的时候：<br><img src="http://note.youdao.com/yws/res/1743/WEBRESOURCE6aabbee371cdc4958f97a82fd2e10bfd" alt="rsafail01.png"></p>
<p>真机连接Xcode的时候：<br><img src="https://note.youdao.com/src/WEBRESOURCE45dc12158d7d802e94f9aa97a2dac957" alt="rsafail02.png"></p>
<p>问题就出在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OSStatus status &#x3D; SecItemAdd((__bridge CFDictionaryRef)publicKey, &amp;persistKey);</span><br></pre></td></tr></table></figure>

<p>在<a href="https://stackoverflow.com/questions/20344255/secitemadd-and-secitemcopymatching-returns-error-code-34018-errsecmissingentit" target="_blank" rel="noopener">stack overflow</a>发现有的人也遇到了类似的问题，现总问题结如下：</p>
<blockquote>
<p>1.当我在连接着Xcode的真机设备上运行app的时候,我试图获取钥匙串，却由于-34018的错误导致运行失败。缺乏钥匙串错误代码开发文档，而且也很难重现此错误(发生的概率大概30%，我也不知道为什么发生)。由于缺乏相关的文档，所以调试这种错误就变得非常困难。为什么会出现此错误，如何解决？xcode5、ios7</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h5><p>你不得不通过在你的test target中添加下面的代码作为运行脚本来签名你的 .xcttest文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codesign --verify --force --sign &quot;$CODE_SIGN_IDENTITY&quot; &quot;$CODESIGNING_FOLDER_PATH&quot;</span><br></pre></td></tr></table></figure>
<h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>在查看<a href="https://opensource.apple.com/source/Security/Security-55471/sec/Security/" target="_blank" rel="noopener">源码</a> 之后，我注意到钥匙串通过一种安全进程(区别于app的进程)获取。<br>app和<code>安全进程</code>通过一项称之为<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html" target="_blank" rel="noopener">XPC</a>的技术进行<code>对话</code>。<code>安全进程</code>经由<code>XPC</code>的启动命令启动。你可以发现真机（模拟器也是如此）app的<code>安全进程</code>正在运行，它的父进程也已经启动。<br>我猜测，有可能某些未知的原因导致<code>安全进程</code>启动失败或者启动太慢，使得你使用它的时候还没有准备好。<br>或许，你可以考虑如何重启<code>安全进程</code>。</p>
<h5 id="来自苹果官方回复："><a href="#来自苹果官方回复：" class="headerlink" title="来自苹果官方回复："></a>来自苹果官方回复：</h5><p>1.我们终于能够在ios8.3里重现-34018错误，这是我们查找问题根源和修复问题的第一步。<br>可是，我们并不能给出确切的解决时间，但是由于已经影响了很多的开发者，我们也非常希望尽快解决。<br>作为变通方案，我建议在在didFinishLaunchingWithOptions 和applicationDidBecomeActive: 两个方法之前添加一个小的延时给获取字符串争取一点时间。然而，好像并没有明显的作用，这就意味着除了重启app确实没有更好的解决方法。<br>这个问题似乎和内存压力也有一定的关系，在解决这个问题的时候，要积极处理内存警告的问题</p>
<h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><ul>
<li>一些情况下是由于不正确的app签名造成的，你可以很清楚的辨别这种原因，因为它100%可以重现。</li>
<li>有些情况下这种问题的造成是由于iOS支持app开发环境中的一个bug<br>造成的。由于os中的另一个bug掩盖了它的影响，排查这个问题非常困难，这就意味着这个问题在内存面临巨大压力的时候会突然出现，我们相信这个问题在ios9.3中已经解决。</li>
<li>我们猜测可能有其他的原因造成了这个问题</li>
</ul>
<p>所以，如果你在运行ios9.3及以后系统的用户设备上（<code>未和Xcode链接</code>）遇到此问题，请记录此bug并报告给我们。）</p>
<h5 id="方案四："><a href="#方案四：" class="headerlink" title="方案四："></a>方案四：</h5><p>我的app（iOS8.4）现在极少遇到 -34018的错误，在做过一些调查之后，我发现当app频繁的从钥匙串请求数据的时候就会造成这种问题。例如，在同一时间，在不同的加载模块，两次读同一个specific key 的值。为了解决这个问题，我在内存中缓存了这个值。</p>
<h5 id="方案五："><a href="#方案五：" class="headerlink" title="方案五："></a>方案五：</h5><p>其他的方式对我都没有用，我清空了我设备上所有的配置文件，以及一些通配符配置文件（这些文件似乎是重点），为了这么做，去window的Devices，然后右击你的（连接）的iphone:<br><img src="https://note.youdao.com/src/WEBRESOURCE60da2ee59d90630d2153e1c32eeea6ad" alt="rsafail03.png"></p>
<p>点击”Show provisioning profiles”删除相关的文件，尤其是team相关的配置文件包括带*号的文件，然后重新导入。</p>
<h5 id="方案五：-1"><a href="#方案五：-1" class="headerlink" title="方案五："></a>方案五：</h5><p>点击”Show provisioning profiles”删除相关的文件，尤其是team相关的配置文件包括带*号的文件，然后重新导入。<br><img src="https://note.youdao.com/src/WEBRESOURCE98ddbdf80709cc5b154da3a6b13bdb09" alt="rsafail04.png"></p>
<h5 id="方案六："><a href="#方案六：" class="headerlink" title="方案六："></a>方案六：</h5><p>我在Xcode6.2 、iphone6、ios8.3环境下，在测试设备上也出现这种问题。更清楚的说，在运行Xcode tests的时候这种情况没有发生，在我的真机，模拟器上都是正常的。</p>
<p>以上的方式都对我无效。</p>
<p>我临时的改变了获取的方式从<br>kSecAttrAccessibleAfterFirstUnlock 到kSecAttrAccessibleAlwaysThisDeviceOnly，运行app,完美运行，且可以写到钥匙串，然后我再改回到kSecAttrAccessibleAfterFirstUnlock,问题似乎永久性的解决了。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>非常遗憾，笔者这个问题仍旧没有解决，希望笔者摘录的几种解决方式给大家一点思路。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>四胞胎之----nil 、 Nil 、 NULL 、NSNull</title>
    <url>/2015/10/21/Nill/</url>
    <content><![CDATA[<p><a href="https://nshipster.cn/nil/" target="_blank" rel="noopener">转自：nil / Nil / NULL / NSNull</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在OC开发过程中，我们会遇到nil 、 Nil 、 NULL 、NSNull这个四个长得极为相似的字符，nill应该是使用最频繁的，在创建对象之初我们往往会把对象的指针指向nill，但是它们之间的区别到底是什么，我们可能不太清楚。</p>
<a id="more"></a>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>在Objective－C中，有几个不同种类的不存在。</p>
<p>C用0来作为不存在的原始值，而NULL作为指针(这在指针环境中相当于0)。</p>
<p>Objective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。虽然它在语义上与NULL不同，但它们在技术上是相等的。</p>
<p>在框架层面，Foundation定义了NSNull，即一个类方法+null，它返回一个单独的NSNull对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。</p>
<p>另外，在Foundation/NSObjCRuntime.h中，Nil被定义为指向零的类指针。这个nil的鲜为人知的大写的表兄并不常常出现，但它至少值得注意。</p>
<h3 id="关于-nil-的一些事"><a href="#关于-nil-的一些事" class="headerlink" title="关于 nil 的一些事"></a>关于 nil 的一些事</h3><p>刚被分配的NSObject的内容被设置为0。也就是说那个对象所有的指向其他对象的指针都从nil开始，所以在init方法中设置self.(association) = nil之类的表达是没有必要的。</p>
<p>也许nil最显著的行为是，它虽然为零，仍然可以有消息发送给它。</p>
<p>在其他的语言中，比如C++，这样做会使你的程序崩溃，但在Objective-C中，在nil上调用方法返回一个零值。这大大的简化了表达，因为它避免了在使用nil之前对它的检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 举个例子，这个表达...</span><br><span class="line">if (name !&#x3D; nil &amp;&amp; [name isEqualToString:@&quot;Steve&quot;]) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; …可以被简化为：</span><br><span class="line">if ([name isEqualToString:@&quot;steve&quot;]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>了解nil如何在Objective-C中工作可以让你将这个便利变成一个功能，而不是潜伏在你的应用中的bug。要确保避免当nil值不需要的情况，要么通过检查或者提前返回来安静的失败，或者通过增加一个NSParameterAssert来抛出异常。</p>
<h3 id="NSNull：有作没有"><a href="#NSNull：有作没有" class="headerlink" title="NSNull：有作没有"></a>NSNull：有作没有</h3><p>SNull在Foundation和其它框架中被广泛的使用，以解决如NSArray和NSDictionary之类的集合不能有nil值的缺陷。你可以将NSNull理解为有效的将NULL或者nil值封装boxing，以达到在集合中使用它们的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *mutableDictionary &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">mutableDictionary[@&quot;someKey&quot;] &#x3D; [NSNull null]; &#x2F;&#x2F; Sets value of NSNull singleton for &#96;someKey&#96;</span><br><span class="line">NSLog(@&quot;Keys: %@&quot;, [mutableDictionary allKeys]); &#x2F;&#x2F; @[@&quot;someKey&quot;]</span><br></pre></td></tr></table></figure>
<p>总的来说，这里的四个表达没有的值是每个Objective-C程序员都应该知道的：</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
